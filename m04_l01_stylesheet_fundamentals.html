<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StyleSheet Fundamentals | React Native & Expo Course</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="stylesheet" href="styles/main.css">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <header class="top-nav">
        <div class="nav-container">
            <a href="index.html" class="logo" aria-label="Course Home">
                <span class="logo-react">‚öõÔ∏è</span> RN
            </a>
            <nav class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="appendix_c_component_reference.html">Reference</a>
            </nav>
            <button class="mobile-menu-toggle" id="mobile-menu-toggle" aria-label="Toggle menu" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </header>

    <nav class="breadcrumb" aria-label="Breadcrumb">
        <div class="container">
            <a href="index.html">Home</a>
            <span aria-hidden="true">‚Ä∫</span>
            <a href="index.html#module4">Module 4</a>
            <span aria-hidden="true">‚Ä∫</span>
            <span aria-current="page">StyleSheet Fundamentals</span>
        </div>
    </nav>

    <main id="main-content">
        <article class="lesson-container">
            <header class="lesson-header">
                <div class="module-badge">Module 4: StyleSheet Deep Dive</div>
                <h1>StyleSheet Fundamentals</h1>
                <p class="lesson-subtitle">Master the styling system that makes React Native apps beautiful</p>
            </header>

            <details class="toc-container" id="toc">
                <summary>Table of Contents</summary>
                <nav class="toc-nav" aria-label="Table of Contents">
                    <ul>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#what-is-stylesheet">What is StyleSheet?</a></li>
                        <li><a href="#stylesheet-create">StyleSheet.create() Explained</a></li>
                        <li><a href="#css-vs-rn-styles">Web CSS vs React Native Styles</a></li>
                        <li><a href="#style-properties">Core Style Properties</a></li>
                        <li><a href="#units-and-values">Units and Values</a></li>
                        <li><a href="#inline-vs-stylesheet">Inline Styles vs StyleSheet</a></li>
                        <li><a href="#combining-styles">Combining Multiple Styles</a></li>
                        <li><a href="#style-inheritance">Style Inheritance Rules</a></li>
                        <li><a href="#common-pitfalls">Common Pitfalls</a></li>
                        <li><a href="#hands-on">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </nav>
            </details>

            <div class="learning-objectives card">
                <h2>üéØ Learning Objectives</h2>
                <ul>
                    <li>Understand why React Native has its own styling system</li>
                    <li>Use <code>StyleSheet.create()</code> to define optimized styles</li>
                    <li>Translate your CSS knowledge to React Native style properties</li>
                    <li>Choose the right units and values for mobile layouts</li>
                    <li>Combine multiple styles effectively with style arrays</li>
                    <li>Avoid common styling mistakes web developers make</li>
                </ul>
            </div>

            <section id="introduction">
                <h2>Introduction</h2>

                <p>If you've been building web applications with CSS, you've developed strong intuitions about how styling works. The good news? About 80% of that knowledge transfers directly to React Native. The challenge? That other 20% can trip you up in surprising ways if you're not prepared for it.</p>

                <p>In Module 3, you learned about React Native's core components ‚Äî <code>View</code>, <code>Text</code>, <code>Image</code>, and others. You saw style props sprinkled throughout our examples, but we never took a deep dive into how the styling system actually works. That changes now.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üé® The Big Picture</h4>
                    <p style="color: white;">React Native's <strong>StyleSheet</strong> API gives you a CSS-like syntax that compiles down to native platform styles. It's not CSS ‚Äî it's a JavaScript object that describes how components should look, which then gets translated to iOS UIKit styles or Android View styles.</p>
                </div>

                <p>Think of StyleSheet as a <em>dialect</em> of CSS. If CSS is British English, React Native styles are American English ‚Äî mostly the same, with some spelling differences and a few words that mean completely different things. Once you learn the differences, you'll move fluently between both.</p>

                <h3>What We'll Cover</h3>

                <p>This lesson establishes your styling foundation. We'll explore what StyleSheet actually does under the hood, how to use it effectively, and ‚Äî critically ‚Äî where it differs from web CSS. Future lessons in this module will build on these fundamentals to cover Flexbox layouts, responsive design patterns, platform-specific styling, and organizing styles at scale.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Prerequisites Check</h4>
                    <p>This lesson assumes you're comfortable with:</p>
                    <ul>
                        <li>CSS fundamentals (selectors, properties, values)</li>
                        <li>React component basics (props, JSX)</li>
                        <li>JavaScript objects and their syntax</li>
                        <li>The core components from Module 3 (<code>View</code>, <code>Text</code>, etc.)</li>
                    </ul>
                </div>
            </section>

            <section id="what-is-stylesheet">
                <h2>What is StyleSheet?</h2>

                <p>Let's start with a fundamental question: why does React Native have its own styling system at all? Why not just use CSS?</p>

                <p>The answer lies in what React Native actually is. When you write a React Native app, you're not creating a web page that runs in a browser. You're creating a truly native application where your JavaScript code controls real native UI components. iOS buttons, Android text fields, native scroll views ‚Äî these are the actual building blocks of your app.</p>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Key Insight</h4>
                    <p>There's no browser in a React Native app. No DOM, no CSS engine, no media queries. Native platforms have their own styling systems, and React Native needs to bridge the gap between the styles you write and what those platforms understand.</p>
                </div>

                <p><code>StyleSheet</code> is React Native's answer to this challenge. It's an API that lets you:</p>

                <ol>
                    <li><strong>Define styles</strong> using a familiar, CSS-like syntax</li>
                    <li><strong>Validate styles</strong> at creation time (catching typos early)</li>
                    <li><strong>Optimize performance</strong> by creating style references once</li>
                    <li><strong>Bridge platforms</strong> by translating to native style formats</li>
                </ol>

                <h3>The StyleSheet Object</h3>

                <p><code>StyleSheet</code> is imported from <code>react-native</code> and provides several useful methods and properties:</p>

<pre><code class="language-typescript">import { StyleSheet } from 'react-native';

// The main method you'll use constantly
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
});

// Utility for combining styles
StyleSheet.compose(style1, style2);

// Flattens an array of styles into one object
StyleSheet.flatten([style1, style2]);

// A constant representing an absolutely positioned element
// that fills its parent completely
StyleSheet.absoluteFill;

// Same as absoluteFill but as a style object you can spread
StyleSheet.absoluteFillObject;

// Returns a "hairline" width (thinnest possible line on device)
StyleSheet.hairlineWidth;</code></pre>

                <p>Of these, <code>StyleSheet.create()</code> is by far the most important. Let's explore it in depth.</p>

                <h3>How Native Platforms Handle Styles</h3>

                <p>To truly understand StyleSheet, it helps to know what happens when your styles reach the native side:</p>

                <pre class="mermaid">
flowchart TD
    subgraph JS["JavaScript Thread"]
        A["StyleSheet.create()"] --> B["Style Object with IDs"]
    end
    
    subgraph Bridge["React Native Bridge"]
        B --> C["Serialized Style Data"]
    end
    
    subgraph Native["Native Thread"]
        C --> D{Platform?}
        D -->|iOS| E["UIKit Styles<br/>NSLayoutConstraint<br/>CALayer properties"]
        D -->|Android| F["Android View Styles<br/>LayoutParams<br/>Paint/Canvas"]
    end
    
    style A fill:#e1f5fe
    style E fill:#f3e5f5
    style F fill:#e8f5e9
                </pre>

                <p>When you call <code>StyleSheet.create()</code>, React Native doesn't just store your style objects. In production builds, it can optimize these styles and send references (IDs) across the bridge instead of full style objects every time a component renders. This is a significant performance optimization that we'll discuss more shortly.</p>
            </section>

            <section id="stylesheet-create">
                <h2>StyleSheet.create() Explained</h2>

                <p><code>StyleSheet.create()</code> takes an object where each key becomes a named style, and each value is an object of style properties. Think of it like defining CSS classes, but in JavaScript:</p>

<pre><code class="language-typescript">import { StyleSheet, View, Text } from 'react-native';

const styles = StyleSheet.create({
  // Like a CSS class called ".container"
  container: {
    flex: 1,
    backgroundColor: '#ffffff',
    padding: 20,
  },
  
  // Like a CSS class called ".title"
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#1a1a1a',
    marginBottom: 12,
  },
  
  // Like a CSS class called ".subtitle"  
  subtitle: {
    fontSize: 16,
    color: '#666666',
    lineHeight: 24,
  },
});

// Usage - reference styles by their keys
function MyComponent() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Welcome&lt;/Text&gt;
      &lt;Text style={styles.subtitle}&gt;
        Getting started with StyleSheet
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Why Use StyleSheet.create()?</h3>

                <p>You might wonder: can't I just pass plain objects to the <code>style</code> prop? Technically, yes:</p>

<pre><code class="language-typescript">// This works, but it's not recommended
&lt;View style={{ flex: 1, padding: 20 }}&gt;
  &lt;Text style={{ fontSize: 24, fontWeight: 'bold' }}&gt;
    Hello
  &lt;/Text&gt;
&lt;/View&gt;</code></pre>

                <p>So why bother with <code>StyleSheet.create()</code>? Several important reasons:</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of StyleSheet.create()</h4>
                    <ul>
                        <li><strong>Validation:</strong> Style property names are checked when styles are created. Typos like <code>fontSise</code> trigger warnings immediately.</li>
                        <li><strong>Performance:</strong> Styles are created once and referenced by ID. Inline objects are recreated every render.</li>
                        <li><strong>Organization:</strong> All component styles live in one place, making them easier to find and modify.</li>
                        <li><strong>Reusability:</strong> Named styles can be applied to multiple elements consistently.</li>
                        <li><strong>Debugging:</strong> Named styles show up clearly in React DevTools.</li>
                    </ul>
                </div>

                <h3>Style Validation in Action</h3>

                <p>One of the most helpful features of <code>StyleSheet.create()</code> is immediate feedback on invalid styles:</p>

<pre><code class="language-typescript">// This will show a warning in development
const styles = StyleSheet.create({
  broken: {
    display: 'inline-block',  // ‚ùå Not supported in RN
    fontSise: 16,             // ‚ùå Typo - should be fontSize
    margin: '20px',           // ‚ùå String units not allowed
  },
});

// Correct version
const styles = StyleSheet.create({
  working: {
    display: 'flex',          // ‚úÖ Supported value
    fontSize: 16,             // ‚úÖ Correct spelling
    margin: 20,               // ‚úÖ Number (density-independent pixels)
  },
});</code></pre>

                <p>In development mode, React Native checks your styles against known valid properties and values. This catches many common mistakes before they become visual bugs.</p>

                <h3>Placement Conventions</h3>

                <p>Where should you put your <code>StyleSheet.create()</code> call? The community convention is at the bottom of your component file, after the component definition:</p>

<pre><code class="language-typescript">// MyComponent.tsx

import { StyleSheet, View, Text } from 'react-native';

// Component first
export function MyComponent() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.text}&gt;Hello&lt;/Text&gt;
    &lt;/View&gt;
  );
}

// Styles at the bottom
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 18,
  },
});</code></pre>

                <p>This pattern keeps your component's render logic at the top where it's easy to find, with styling details below. Since JavaScript hoists <code>const</code> declarations within modules, you can reference <code>styles</code> in your component even though it's defined after.</p>
            </section>
            <section id="css-vs-rn-styles">
                <h2>Web CSS vs React Native Styles</h2>

                <p>This is where your web CSS experience becomes both an asset and a potential source of confusion. Let's systematically compare the two systems so you know exactly what transfers and what doesn't.</p>

                <h3>Syntax Differences</h3>

                <p>The most visible difference is the syntax. CSS uses kebab-case property names and various value formats. React Native uses camelCase and JavaScript values:</p>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                    <div class="card" style="margin: 0;">
                        <h4>Web CSS</h4>
<pre><code class="language-css">.card {
  background-color: #ffffff;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  padding: 16px;
  margin-bottom: 12px;
  font-size: 14px;
  font-weight: bold;
  text-align: center;
}</code></pre>
                    </div>
                    <div class="card" style="margin: 0;">
                        <h4>React Native</h4>
<pre><code class="language-typescript">const styles = StyleSheet.create({
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 8,
    // Shadow is platform-specific!
    padding: 16,
    marginBottom: 12,
    fontSize: 14,
    fontWeight: 'bold',
    textAlign: 'center',
  },
});</code></pre>
                    </div>
                </div>

                <p>Notice the patterns:</p>
                <ul>
                    <li><code>background-color</code> ‚Üí <code>backgroundColor</code> (camelCase)</li>
                    <li><code>16px</code> ‚Üí <code>16</code> (unitless numbers)</li>
                    <li><code>bold</code> ‚Üí <code>'bold'</code> (string values in quotes)</li>
                    <li><code>box-shadow</code> ‚Üí Different approach entirely (platform-specific)</li>
                </ul>

                <h3>What Transfers Directly</h3>

                <p>Many CSS concepts work almost identically in React Native. Here's what you can rely on:</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Works the Same (or Nearly So)</h4>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                        <thead>
                            <tr style="text-align: left; border-bottom: 2px solid #4CAF50;">
                                <th style="padding: 8px;">Concept</th>
                                <th style="padding: 8px;">CSS</th>
                                <th style="padding: 8px;">React Native</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Colors</td>
                                <td style="padding: 8px;"><code>#fff</code>, <code>rgb()</code>, <code>rgba()</code></td>
                                <td style="padding: 8px;">Same formats work!</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Flexbox</td>
                                <td style="padding: 8px;"><code>display: flex</code></td>
                                <td style="padding: 8px;">Default for all Views</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Padding/Margin</td>
                                <td style="padding: 8px;"><code>padding: 16px</code></td>
                                <td style="padding: 8px;"><code>padding: 16</code></td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Border radius</td>
                                <td style="padding: 8px;"><code>border-radius: 8px</code></td>
                                <td style="padding: 8px;"><code>borderRadius: 8</code></td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Positioning</td>
                                <td style="padding: 8px;"><code>position: absolute</code></td>
                                <td style="padding: 8px;"><code>position: 'absolute'</code></td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;">Opacity</td>
                                <td style="padding: 8px;"><code>opacity: 0.5</code></td>
                                <td style="padding: 8px;"><code>opacity: 0.5</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>What's Different</h3>

                <p>Now for the gotchas. These differences catch web developers most often:</p>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Key Differences</h4>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                        <thead>
                            <tr style="text-align: left; border-bottom: 2px solid #ffc107;">
                                <th style="padding: 8px;">Concept</th>
                                <th style="padding: 8px;">Web CSS</th>
                                <th style="padding: 8px;">React Native</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Default display</td>
                                <td style="padding: 8px;"><code>block</code></td>
                                <td style="padding: 8px;"><code>flex</code></td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Flex direction</td>
                                <td style="padding: 8px;"><code>row</code> (default)</td>
                                <td style="padding: 8px;"><code>column</code> (default)</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Units</td>
                                <td style="padding: 8px;"><code>px</code>, <code>em</code>, <code>rem</code>, <code>%</code>, <code>vh</code></td>
                                <td style="padding: 8px;">Numbers (dp) and <code>%</code> only</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Shorthand</td>
                                <td style="padding: 8px;"><code>margin: 10px 20px</code></td>
                                <td style="padding: 8px;">Must use individual props</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 8px;">Inheritance</td>
                                <td style="padding: 8px;">Many properties inherit</td>
                                <td style="padding: 8px;">Almost nothing inherits</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;">Shadows</td>
                                <td style="padding: 8px;"><code>box-shadow</code></td>
                                <td style="padding: 8px;">Platform-specific APIs</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>What Doesn't Exist</h3>

                <p>Some CSS features have no equivalent in React Native because they don't make sense in a native context:</p>

                <div class="card" style="background: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Not Available in React Native</h4>
                    <ul>
                        <li><strong>CSS Selectors:</strong> No <code>.class</code>, <code>#id</code>, <code>:hover</code>, <code>::before</code></li>
                        <li><strong>Media Queries:</strong> No <code>@media</code> (we have other solutions)</li>
                        <li><strong>CSS Grid:</strong> Layout is Flexbox-only</li>
                        <li><strong>CSS Variables:</strong> No <code>var(--custom)</code> (use JS constants)</li>
                        <li><strong>Cascading:</strong> No stylesheet cascade or specificity</li>
                        <li><strong>Animation:</strong> No <code>@keyframes</code> (use Animated/Reanimated)</li>
                        <li><strong>Pseudo-elements:</strong> No <code>::before</code>, <code>::after</code></li>
                        <li><strong>Float:</strong> No <code>float: left/right</code></li>
                        <li><strong>Display types:</strong> No <code>inline</code>, <code>block</code>, <code>inline-block</code>, <code>grid</code></li>
                    </ul>
                </div>

                <p>Don't panic! Each of these missing features has a React Native alternative. We'll cover responsive design without media queries in Lesson 4 of this module, and animations are covered extensively in Module 9.</p>

                <h3>Mental Model Shift</h3>

                <p>The key mental shift is this: in CSS, you're describing how elements should look, and the browser's CSS engine handles the cascade, inheritance, and specificity rules. In React Native, you're directly telling each component exactly how to style itself. There's no cascade, no inheritance to rely on, no "styles flowing down."</p>

                <pre class="mermaid">
flowchart TB
    subgraph CSS["Web CSS Model"]
        direction TB
        S1["Global Stylesheet"] --> C1["Cascade Rules"]
        C1 --> S2["Specificity Calculation"]
        S2 --> I1["Inheritance"]
        I1 --> F1["Final Computed Style"]
    end
    
    subgraph RN["React Native Model"]
        direction TB
        ST["StyleSheet.create()"] --> D["Direct Application"]
        D --> COMP["Component receives<br/>exact style object"]
    end
    
    style CSS fill:#e3f2fd
    style RN fill:#e8f5e9
                </pre>

                <p>This directness is actually a feature, not a bug. It makes styles predictable ‚Äî what you write is exactly what you get, with no surprises from inherited styles or specificity battles.</p>
            </section>

            <section id="style-properties">
                <h2>Core Style Properties</h2>

                <p>React Native supports a subset of CSS properties, organized into categories based on what they affect. Let's survey the most important ones you'll use daily.</p>

                <h3>Layout Properties</h3>

                <p>These control how components are sized and positioned. We'll dive deep into Flexbox in the next lesson, but here's an overview:</p>

<pre><code class="language-typescript">const layoutStyles = StyleSheet.create({
  container: {
    // Flexbox (covered in detail next lesson)
    flex: 1,
    flexDirection: 'column',    // 'row', 'column', 'row-reverse', 'column-reverse'
    justifyContent: 'center',   // main axis alignment
    alignItems: 'center',       // cross axis alignment
    flexWrap: 'wrap',           // 'nowrap', 'wrap', 'wrap-reverse'
    gap: 10,                    // spacing between flex children
    
    // Sizing
    width: 200,
    height: 100,
    minWidth: 50,
    maxWidth: 300,
    minHeight: 50,
    maxHeight: 400,
    
    // Aspect ratio (very useful for images/videos!)
    aspectRatio: 16 / 9,
    
    // Positioning
    position: 'relative',       // 'relative' or 'absolute'
    top: 10,
    right: 10,
    bottom: 10,
    left: 10,
    zIndex: 100,
  },
});</code></pre>

                <h3>Spacing Properties</h3>

                <p>Padding and margin work like CSS, but without shorthand:</p>

<pre><code class="language-typescript">const spacingStyles = StyleSheet.create({
  card: {
    // Individual sides
    paddingTop: 20,
    paddingRight: 16,
    paddingBottom: 20,
    paddingLeft: 16,
    
    // Axis shortcuts (these DO exist!)
    paddingHorizontal: 16,  // = paddingLeft + paddingRight
    paddingVertical: 20,    // = paddingTop + paddingBottom
    
    // All sides at once
    padding: 16,            // applies to all four sides
    
    // Same pattern for margin
    margin: 10,
    marginHorizontal: 20,
    marginVertical: 10,
    marginTop: 8,
    // ... etc
  },
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° RN-Specific Shortcuts</h4>
                    <p><code>paddingHorizontal</code>, <code>paddingVertical</code>, <code>marginHorizontal</code>, and <code>marginVertical</code> are React Native additions that don't exist in CSS. They're incredibly handy shortcuts!</p>
                </div>

                <h3>Visual Properties</h3>

                <p>Colors, backgrounds, borders, and visual effects:</p>

<pre><code class="language-typescript">const visualStyles = StyleSheet.create({
  card: {
    // Background
    backgroundColor: '#ffffff',
    
    // Borders (no shorthand!)
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderStyle: 'solid',      // 'solid', 'dotted', 'dashed'
    
    // Individual border sides
    borderTopWidth: 2,
    borderTopColor: '#2196F3',
    
    // Border radius
    borderRadius: 8,
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    borderBottomLeftRadius: 0,
    borderBottomRightRadius: 0,
    
    // Opacity
    opacity: 0.9,
    
    // Overflow (important for borderRadius to work on children!)
    overflow: 'hidden',        // 'visible', 'hidden', 'scroll'
  },
});</code></pre>

                <h3>Typography Properties</h3>

                <p>These only apply to <code>Text</code> components (remember from Module 3 ‚Äî all text must be in <code>&lt;Text&gt;</code>):</p>

<pre><code class="language-typescript">const textStyles = StyleSheet.create({
  heading: {
    // Font
    fontSize: 24,
    fontWeight: 'bold',        // '100'-'900', 'normal', 'bold'
    fontStyle: 'italic',       // 'normal', 'italic'
    fontFamily: 'System',      // Platform font or custom font name
    
    // Color
    color: '#1a1a1a',
    
    // Alignment
    textAlign: 'center',       // 'left', 'center', 'right', 'justify'
    textAlignVertical: 'center', // Android only: 'auto', 'top', 'center', 'bottom'
    
    // Decoration
    textDecorationLine: 'underline', // 'none', 'underline', 'line-through', 'underline line-through'
    textDecorationStyle: 'solid',    // 'solid', 'double', 'dotted', 'dashed'
    textDecorationColor: '#2196F3',
    
    // Spacing
    letterSpacing: 1.5,
    lineHeight: 32,
    
    // Transform
    textTransform: 'uppercase', // 'none', 'uppercase', 'lowercase', 'capitalize'
    
    // Shadow (text shadow, not box shadow)
    textShadowColor: 'rgba(0, 0, 0, 0.25)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
});</code></pre>

                <h3>Shadow Properties (Platform Differences)</h3>

                <p>This is one area where iOS and Android diverge significantly:</p>

<pre><code class="language-typescript">const shadowStyles = StyleSheet.create({
  cardWithShadow: {
    backgroundColor: '#ffffff', // Required for shadows to show!
    
    // iOS Shadow (these only work on iOS)
    shadowColor: '#000000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    
    // Android Shadow (this only works on Android)
    elevation: 4,
  },
});</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Shadow Reality Check</h4>
                    <p>You'll often need to specify both iOS shadow properties AND Android <code>elevation</code> to get consistent shadows across platforms. We'll cover platform-specific styling patterns in Lesson 5 of this module.</p>
                </div>

                <h3>Image-Specific Properties</h3>

                <p>When styling <code>Image</code> components (remember our Image lesson in Module 3?):</p>

<pre><code class="language-typescript">const imageStyles = StyleSheet.create({
  photo: {
    width: 200,
    height: 200,
    
    // How the image fills its container
    resizeMode: 'cover',  // 'cover', 'contain', 'stretch', 'center', 'repeat'
    
    // Tint (colorize the image)
    tintColor: '#2196F3', // Useful for icons!
    
    // Border radius works on images
    borderRadius: 100,    // Makes circular images
  },
});</code></pre>
            </section>

            <section id="units-and-values">
                <h2>Units and Values</h2>

                <p>One of the biggest adjustments for web developers is React Native's approach to units. Let's break it down completely.</p>

                <h3>No px, em, rem, vh, vw</h3>

                <p>In CSS, you have many unit options. In React Native, you have essentially two: <strong>unitless numbers</strong> and <strong>percentages</strong>.</p>

<pre><code class="language-typescript">// ‚ùå This won't work - string units are invalid
const wrongStyles = {
  width: '200px',      // Error!
  fontSize: '1.5rem',  // Error!
  height: '100vh',     // Error!
};

// ‚úÖ This is correct
const rightStyles = StyleSheet.create({
  container: {
    width: 200,        // Density-independent pixels
    fontSize: 24,      // Points
    height: '100%',    // Percentage (as string)
  },
});</code></pre>

                <h3>Density-Independent Pixels (dp)</h3>

                <p>When you write <code>width: 200</code> in React Native, you're specifying 200 <em>density-independent pixels</em> (also called "points" on iOS or "dp" on Android). This is a crucial concept:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Density-Independent Pixels</h4>
                    <p style="color: white;">A density-independent pixel is a virtual unit that scales based on screen density. On a standard 1x display, 1dp = 1 physical pixel. On a 2x Retina display, 1dp = 2 physical pixels. This means <code>width: 100</code> looks the same physical size across all devices, regardless of their pixel density.</p>
                </div>

                <p>This automatic scaling is why you don't need <code>px</code> ‚Äî React Native handles the conversion to actual pixels based on device density.</p>

                <svg viewBox="0 0 600 250" style="width: 100%; max-width: 600px; margin: 20px auto; display: block;">
                    <!-- Background -->
                    <rect width="600" height="250" fill="#f8f9fa"/>
                    
                    <!-- 1x Device -->
                    <g transform="translate(50, 30)">
                        <text x="70" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">1x Display</text>
                        <rect x="20" y="15" width="100" height="100" fill="#e3f2fd" stroke="#2196F3" stroke-width="2"/>
                        <text x="70" y="70" text-anchor="middle" font-size="12" fill="#1976D2">100dp</text>
                        <text x="70" y="85" text-anchor="middle" font-size="10" fill="#666">= 100px</text>
                        <text x="70" y="135" text-anchor="middle" font-size="11" fill="#666">100 physical pixels</text>
                    </g>
                    
                    <!-- 2x Device -->
                    <g transform="translate(220, 30)">
                        <text x="70" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">2x Retina</text>
                        <rect x="20" y="15" width="100" height="100" fill="#e8f5e9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="70" y="70" text-anchor="middle" font-size="12" fill="#388E3C">100dp</text>
                        <text x="70" y="85" text-anchor="middle" font-size="10" fill="#666">= 200px</text>
                        <text x="70" y="135" text-anchor="middle" font-size="11" fill="#666">200 physical pixels</text>
                    </g>
                    
                    <!-- 3x Device -->
                    <g transform="translate(390, 30)">
                        <text x="70" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">3x Display</text>
                        <rect x="20" y="15" width="100" height="100" fill="#fff3e0" stroke="#FF9800" stroke-width="2"/>
                        <text x="70" y="70" text-anchor="middle" font-size="12" fill="#F57C00">100dp</text>
                        <text x="70" y="85" text-anchor="middle" font-size="10" fill="#666">= 300px</text>
                        <text x="70" y="135" text-anchor="middle" font-size="11" fill="#666">300 physical pixels</text>
                    </g>
                    
                    <!-- Bottom note -->
                    <text x="300" y="200" text-anchor="middle" font-size="13" fill="#333">Same visual size on all devices!</text>
                    <text x="300" y="220" text-anchor="middle" font-size="11" fill="#666">React Native handles the pixel density conversion automatically</text>
                </svg>

                <h3>Percentages</h3>

                <p>Percentages work for sizing, but they must be strings:</p>

<pre><code class="language-typescript">const percentStyles = StyleSheet.create({
  halfWidth: {
    width: '50%',      // 50% of parent width
    height: '100%',    // Full parent height
  },
  
  positioned: {
    position: 'absolute',
    top: '10%',        // 10% from top of parent
    left: '5%',        // 5% from left of parent
  },
});</code></pre>

                <p>Percentages are relative to the <em>parent</em> container, not the screen. This differs from CSS's <code>vh</code> and <code>vw</code> units, which are relative to the viewport.</p>

                <h3>Getting Screen Dimensions</h3>

                <p>Since there's no <code>vh</code> or <code>vw</code>, how do you size things relative to the screen? Use the <code>Dimensions</code> API or the <code>useWindowDimensions</code> hook:</p>

<pre><code class="language-typescript">import { 
  StyleSheet, 
  Dimensions, 
  useWindowDimensions,
  View 
} from 'react-native';

// Method 1: Dimensions API (static, doesn't update on rotation)
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;

const staticStyles = StyleSheet.create({
  halfScreen: {
    width: screenWidth / 2,
    height: screenHeight * 0.3,  // 30vh equivalent
  },
});

// Method 2: useWindowDimensions hook (reactive, updates on rotation)
function ResponsiveComponent() {
  const { width, height } = useWindowDimensions();
  
  return (
    &lt;View 
      style={{ 
        width: width * 0.8,   // 80vw equivalent
        height: height * 0.5  // 50vh equivalent
      }} 
    /&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practice</h4>
                    <p>Prefer <code>useWindowDimensions()</code> over <code>Dimensions.get()</code> in components. The hook automatically updates when the screen size changes (like device rotation), while the API call returns a static value.</p>
                </div>

                <h3>Font Sizes</h3>

                <p>Font sizes are also unitless numbers, representing points:</p>

<pre><code class="language-typescript">const textStyles = StyleSheet.create({
  small: { fontSize: 12 },    // 12pt
  body: { fontSize: 16 },     // 16pt - good default
  large: { fontSize: 20 },    // 20pt
  title: { fontSize: 28 },    // 28pt
  hero: { fontSize: 48 },     // 48pt
});</code></pre>

                <p>Unlike web where you might use <code>rem</code> for scalable typography, React Native fonts are fixed sizes. For accessible, user-scalable text, you'll need to implement scaling yourself or use libraries ‚Äî we'll cover this in the responsive design lesson.</p>
            </section>
            <section id="inline-vs-stylesheet">
                <h2>Inline Styles vs StyleSheet</h2>

                <p>You have two main options for applying styles in React Native: inline style objects and <code>StyleSheet.create()</code>. Let's understand when to use each.</p>

                <h3>Inline Styles</h3>

                <p>Inline styles are JavaScript objects passed directly to the <code>style</code> prop:</p>

<pre><code class="language-typescript">// Inline style - object created every render
&lt;View style={{ flex: 1, padding: 16 }}&gt;
  &lt;Text style={{ fontSize: 24, color: '#333' }}&gt;
    Hello World
  &lt;/Text&gt;
&lt;/View&gt;</code></pre>

                <h3>StyleSheet Styles</h3>

                <p>StyleSheet styles are defined once and referenced by name:</p>

<pre><code class="language-typescript">// StyleSheet - objects created once, reused
&lt;View style={styles.container}&gt;
  &lt;Text style={styles.title}&gt;Hello World&lt;/Text&gt;
&lt;/View&gt;

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16 },
  title: { fontSize: 24, color: '#333' },
});</code></pre>

                <h3>When to Use Each</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use StyleSheet.create() For:</h4>
                    <ul>
                        <li>Static styles that don't change based on props or state</li>
                        <li>Styles reused across multiple elements</li>
                        <li>The majority of your styling needs</li>
                        <li>Better performance and validation</li>
                    </ul>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Use Inline Styles For:</h4>
                    <ul>
                        <li>Dynamic values that depend on props, state, or calculations</li>
                        <li>One-off overrides combined with StyleSheet styles</li>
                        <li>Styles computed from <code>useWindowDimensions()</code></li>
                        <li>Animated values (which must be inline)</li>
                    </ul>
                </div>

                <h3>Real-World Pattern: Combining Both</h3>

                <p>In practice, you'll often combine StyleSheet styles with inline dynamic values:</p>

<pre><code class="language-typescript">import { StyleSheet, View, Text, useWindowDimensions } from 'react-native';

interface CardProps {
  title: string;
  isHighlighted: boolean;
  customColor?: string;
}

function Card({ title, isHighlighted, customColor }: CardProps) {
  const { width } = useWindowDimensions();
  const isWideScreen = width > 600;
  
  return (
    &lt;View 
      style={[
        styles.card,
        // Dynamic: conditional style
        isHighlighted && styles.highlighted,
        // Dynamic: prop-based color
        customColor && { borderColor: customColor },
        // Dynamic: responsive width
        { width: isWideScreen ? 400 : width - 32 },
      ]}
    &gt;
      &lt;Text style={styles.title}&gt;{title}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

// Static styles in StyleSheet
const styles = StyleSheet.create({
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    borderWidth: 2,
    borderColor: '#e0e0e0',
  },
  highlighted: {
    borderColor: '#2196F3',
    backgroundColor: '#e3f2fd',
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1a1a1a',
  },
});</code></pre>

                <p>This pattern gives you the best of both worlds: validated, optimized static styles from StyleSheet, plus the flexibility of inline styles for dynamic values.</p>
            </section>

            <section id="combining-styles">
                <h2>Combining Multiple Styles</h2>

                <p>React Native's <code>style</code> prop accepts either a single style object or an <strong>array of styles</strong>. This is incredibly powerful for composition.</p>

                <h3>Style Arrays</h3>

                <p>When you pass an array, styles are merged left-to-right, with later styles overriding earlier ones (just like Object.assign or spread):</p>

<pre><code class="language-typescript">// Later styles override earlier ones
&lt;View style={[styles.base, styles.override]}&gt;
  {/* If both define backgroundColor, override wins */}
&lt;/View&gt;

const styles = StyleSheet.create({
  base: {
    padding: 16,
    backgroundColor: '#ffffff',
    borderRadius: 8,
  },
  override: {
    backgroundColor: '#e3f2fd',  // This wins!
    borderRadius: 16,            // This wins!
    // padding stays 16 from base
  },
});</code></pre>

                <h3>Conditional Styles</h3>

                <p>Arrays shine for conditional styling. Use JavaScript's <code>&&</code> or ternary operators:</p>

<pre><code class="language-typescript">interface ButtonProps {
  label: string;
  variant: 'primary' | 'secondary' | 'danger';
  disabled?: boolean;
  size?: 'small' | 'large';
}

function Button({ label, variant, disabled, size }: ButtonProps) {
  return (
    &lt;Pressable
      style={[
        styles.button,
        styles[variant],                        // Dynamic key lookup
        size === 'small' && styles.small,       // Conditional
        size === 'large' && styles.large,       // Conditional
        disabled && styles.disabled,            // Conditional
      ]}
      disabled={disabled}
    &gt;
      &lt;Text style={[
        styles.label,
        styles[`${variant}Label`],              // Dynamic key
        disabled && styles.disabledLabel,
      ]}&gt;
        {label}
      &lt;/Text&gt;
    &lt;/Pressable&gt;
  );
}

const styles = StyleSheet.create({
  button: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignItems: 'center',
  },
  primary: { backgroundColor: '#2196F3' },
  secondary: { backgroundColor: '#e0e0e0' },
  danger: { backgroundColor: '#f44336' },
  small: { paddingVertical: 8, paddingHorizontal: 16 },
  large: { paddingVertical: 16, paddingHorizontal: 32 },
  disabled: { opacity: 0.5 },
  
  label: { fontSize: 16, fontWeight: '600' },
  primaryLabel: { color: '#ffffff' },
  secondaryLabel: { color: '#333333' },
  dangerLabel: { color: '#ffffff' },
  disabledLabel: { color: '#999999' },
});</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Falsy Values in Arrays</h4>
                    <p>React Native gracefully handles <code>false</code>, <code>null</code>, and <code>undefined</code> in style arrays ‚Äî they're simply ignored. This is what makes <code>condition && styles.something</code> work safely.</p>
                </div>

                <h3>StyleSheet.compose() and StyleSheet.flatten()</h3>

                <p>React Native provides two utility methods for combining styles:</p>

<pre><code class="language-typescript">import { StyleSheet } from 'react-native';

// compose: Combines two styles (returns a new style reference)
const combined = StyleSheet.compose(styles.base, styles.variant);
// Use: &lt;View style={combined} /&gt;

// flatten: Merges an array into a single plain object
const flattened = StyleSheet.flatten([styles.a, styles.b, styles.c]);
// Returns: { ...a, ...b, ...c } as a plain object

// flatten is useful when you need to read computed values:
const finalStyles = StyleSheet.flatten([styles.base, { backgroundColor: 'red' }]);
console.log(finalStyles.backgroundColor); // 'red'</code></pre>

                <p>In practice, style arrays <code>[style1, style2]</code> are more commonly used than these utility methods, but <code>flatten()</code> is handy when you need to inspect the final computed style values.</p>
            </section>

            <section id="style-inheritance">
                <h2>Style Inheritance Rules</h2>

                <p>This is one of the most surprising differences from web CSS. In React Native, <strong>almost no styles inherit from parent to child</strong>.</p>

                <h3>The Web CSS Model</h3>

                <p>In web CSS, many properties cascade down to descendants:</p>

<pre><code class="language-html">&lt;!-- Web HTML/CSS --&gt;
&lt;div style="color: blue; font-family: Arial; font-size: 16px;"&gt;
  This text is blue, Arial, 16px.
  &lt;span&gt;This span inherits all of that!&lt;/span&gt;
  &lt;p&gt;So does this paragraph.&lt;/p&gt;
&lt;/div&gt;</code></pre>

                <h3>The React Native Model</h3>

                <p>In React Native, the same structure behaves very differently:</p>

<pre><code class="language-typescript">// React Native - NO inheritance!
&lt;View style={{ /* View styles don't affect Text children */ }}&gt;
  &lt;Text style={styles.parentText}&gt;
    This text has explicit styles.
    &lt;Text&gt;This nested Text inherits NOTHING by default!&lt;/Text&gt;
  &lt;/Text&gt;
&lt;/View&gt;

// You must explicitly style every Text
const styles = StyleSheet.create({
  parentText: {
    color: 'blue',
    fontSize: 16,
    fontFamily: 'System',
  },
});</code></pre>

                <h3>The One Exception: Nested Text</h3>

                <p>There is exactly one case where inheritance works: <code>Text</code> nested directly inside <code>Text</code>:</p>

<pre><code class="language-typescript">// Text nested in Text DOES inherit text styles
&lt;Text style={styles.paragraph}&gt;
  This is normal text.
  &lt;Text style={styles.bold}&gt; This inherits paragraph styles AND adds bold.&lt;/Text&gt;
  &lt;Text style={styles.link}&gt; This inherits AND changes color.&lt;/Text&gt;
&lt;/Text&gt;

const styles = StyleSheet.create({
  paragraph: {
    fontSize: 16,
    color: '#333333',
    lineHeight: 24,
  },
  bold: {
    fontWeight: 'bold',
    // Inherits fontSize, color, lineHeight from parent Text
  },
  link: {
    color: '#2196F3',       // Overrides inherited color
    textDecorationLine: 'underline',
    // Inherits fontSize, lineHeight from parent Text
  },
});</code></pre>

                <pre class="mermaid">
flowchart TD
    subgraph NoInherit["No Inheritance"]
        V["View (styled)"] --> T1["Text"]
        T1 -.->|"‚ùå No inheritance"| NOTE1["View styles don't<br/>cascade to Text"]
    end
    
    subgraph Inherit["Text-to-Text Inheritance"]
        T2["Text (parent styles)"] --> T3["Text (child)"]
        T3 -.->|"‚úÖ Inherits text styles"| NOTE2["fontSize, color, etc.<br/>cascade to nested Text"]
    end
    
    style NoInherit fill:#ffebee
    style Inherit fill:#e8f5e9
                </pre>

                <h3>Practical Implication: Default Styles</h3>

                <p>Since nothing inherits, you'll often create base text styles and apply them everywhere:</p>

<pre><code class="language-typescript">// Common pattern: create reusable text style presets
const styles = StyleSheet.create({
  // Base text style - apply to all Text components
  text: {
    fontSize: 16,
    color: '#1a1a1a',
    fontFamily: 'System',
  },
  
  // Variants build on or override base
  heading: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#1a1a1a',
    fontFamily: 'System',
  },
  
  caption: {
    fontSize: 12,
    color: '#666666',
    fontFamily: 'System',
  },
});

// Usage: always include a text style
&lt;Text style={styles.text}&gt;Body text&lt;/Text&gt;
&lt;Text style={styles.heading}&gt;Page Title&lt;/Text&gt;
&lt;Text style={styles.caption}&gt;Small print&lt;/Text&gt;</code></pre>

                <p>In Lesson 7, we'll explore patterns for organizing and scaling these base styles across large applications.</p>
            </section>

            <section id="common-pitfalls">
                <h2>Common Pitfalls</h2>

                <p>Let's look at the mistakes web developers most commonly make when starting with React Native styling.</p>

                <h3>Pitfall 1: Using String Units</h3>

<pre><code class="language-typescript">// ‚ùå WRONG - string units don't work
const badStyles = {
  width: '200px',
  fontSize: '16px',
  margin: '10rem',
};

// ‚úÖ CORRECT - use numbers
const goodStyles = StyleSheet.create({
  container: {
    width: 200,
    fontSize: 16,
    margin: 10,
  },
});</code></pre>

                <h3>Pitfall 2: Expecting CSS Shorthand</h3>

<pre><code class="language-typescript">// ‚ùå WRONG - shorthand doesn't exist
const badStyles = {
  margin: '10 20',              // Nope
  padding: '10px 20px 10px',    // Nope
  border: '1px solid black',    // Nope
  background: 'linear-gradient(...)',  // Nope
};

// ‚úÖ CORRECT - use individual properties
const goodStyles = StyleSheet.create({
  box: {
    marginVertical: 10,
    marginHorizontal: 20,
    // Or individually:
    paddingTop: 10,
    paddingRight: 20,
    paddingBottom: 10,
    paddingLeft: 20,
    // Border must be separate
    borderWidth: 1,
    borderStyle: 'solid',
    borderColor: 'black',
  },
});</code></pre>

                <h3>Pitfall 3: Forgetting flexDirection Default</h3>

<pre><code class="language-typescript">// Web CSS: flex items default to row
// React Native: flex items default to COLUMN

// If you want horizontal layout, you MUST specify:
const styles = StyleSheet.create({
  row: {
    flexDirection: 'row',  // Required for horizontal!
  },
});</code></pre>

                <h3>Pitfall 4: Applying Text Styles to View</h3>

<pre><code class="language-typescript">// ‚ùå WRONG - text styles on View don't work
&lt;View style={{ fontSize: 16, color: 'blue' }}&gt;
  &lt;Text&gt;This text won't be blue or 16pt!&lt;/Text&gt;
&lt;/View&gt;

// ‚úÖ CORRECT - text styles go on Text
&lt;View&gt;
  &lt;Text style={{ fontSize: 16, color: 'blue' }}&gt;
    Now it works!
  &lt;/Text&gt;
&lt;/View&gt;</code></pre>

                <h3>Pitfall 5: Expecting borderRadius to Clip Children</h3>

<pre><code class="language-typescript">// ‚ùå PROBLEM - children overflow rounded corners
&lt;View style={{ borderRadius: 20 }}&gt;
  &lt;Image source={...} style={{ width: '100%', height: 200 }} /&gt;
  {/* Image corners stick out! */}
&lt;/View&gt;

// ‚úÖ SOLUTION - add overflow: 'hidden'
&lt;View style={{ borderRadius: 20, overflow: 'hidden' }}&gt;
  &lt;Image source={...} style={{ width: '100%', height: 200 }} /&gt;
  {/* Image properly clipped to rounded corners */}
&lt;/View&gt;</code></pre>

                <h3>Pitfall 6: Inline Object Recreation</h3>

<pre><code class="language-typescript">// ‚ùå SUBOPTIMAL - new object every render
function MyComponent() {
  return (
    &lt;View style={{ flex: 1, padding: 16 }}&gt;
      {/* This object is recreated on every render */}
    &lt;/View&gt;
  );
}

// ‚úÖ BETTER - StyleSheet created once
function MyComponent() {
  return (
    &lt;View style={styles.container}&gt;
      {/* Reference to pre-created style */}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16 },
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Summary of Pitfalls</h4>
                    <ol>
                        <li>Use numbers, not string units (<code>200</code> not <code>'200px'</code>)</li>
                        <li>No shorthand ‚Äî specify each property individually</li>
                        <li>Remember <code>flexDirection: 'column'</code> is the default</li>
                        <li>Text styles only work on <code>Text</code> components</li>
                        <li>Add <code>overflow: 'hidden'</code> for <code>borderRadius</code> clipping</li>
                        <li>Use <code>StyleSheet.create()</code> for static styles</li>
                    </ol>
                </div>
            </section>

            <section id="hands-on">
                <h2>Hands-On Exercises</h2>

                <p>Let's put your new StyleSheet knowledge into practice. Complete these exercises to solidify your understanding.</p>

                <div class="exercise-container">
                    <h3>Exercise 1: Convert CSS to React Native</h3>
                    <p>Convert this CSS to a React Native StyleSheet:</p>

<pre><code class="language-css">.profile-card {
  background-color: #ffffff;
  border-radius: 12px;
  padding: 20px;
  margin: 16px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.profile-name {
  font-size: 24px;
  font-weight: bold;
  color: #1a1a1a;
  margin-bottom: 8px;
}

.profile-bio {
  font-size: 14px;
  color: #666666;
  line-height: 20px;
}</code></pre>

                    <details>
                        <summary>Show Solution</summary>
<pre><code class="language-typescript">import { StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  profileCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 20,
    margin: 16,
    // iOS shadow
    shadowColor: '#000000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    // Android shadow
    elevation: 4,
  },
  profileName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#1a1a1a',
    marginBottom: 8,
  },
  profileBio: {
    fontSize: 14,
    color: '#666666',
    lineHeight: 20,
  },
});</code></pre>
                        <p><strong>Key conversions:</strong> kebab-case ‚Üí camelCase, removed <code>px</code> units, split <code>box-shadow</code> into platform-specific properties.</p>
                    </details>
                </div>

                <div class="exercise-container">
                    <h3>Exercise 2: Build a Button Component with Variants</h3>
                    <p>Create a <code>Button</code> component that accepts <code>variant</code> ('primary' | 'outline'), <code>size</code> ('small' | 'medium' | 'large'), and <code>disabled</code> props. Use style arrays to combine the appropriate styles.</p>

                    <details>
                        <summary>Show Solution</summary>
<pre><code class="language-typescript">import { StyleSheet, Pressable, Text } from 'react-native';

interface ButtonProps {
  title: string;
  variant?: 'primary' | 'outline';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onPress?: () => void;
}

export function Button({ 
  title, 
  variant = 'primary', 
  size = 'medium',
  disabled = false,
  onPress 
}: ButtonProps) {
  return (
    &lt;Pressable
      style={[
        styles.base,
        styles[variant],
        styles[size],
        disabled && styles.disabled,
      ]}
      onPress={onPress}
      disabled={disabled}
    &gt;
      &lt;Text style={[
        styles.text,
        variant === 'outline' && styles.outlineText,
        disabled && styles.disabledText,
      ]}&gt;
        {title}
      &lt;/Text&gt;
    &lt;/Pressable&gt;
  );
}

const styles = StyleSheet.create({
  base: {
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  
  // Variants
  primary: {
    backgroundColor: '#2196F3',
  },
  outline: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: '#2196F3',
  },
  
  // Sizes
  small: {
    paddingVertical: 8,
    paddingHorizontal: 16,
  },
  medium: {
    paddingVertical: 12,
    paddingHorizontal: 24,
  },
  large: {
    paddingVertical: 16,
    paddingHorizontal: 32,
  },
  
  // States
  disabled: {
    opacity: 0.5,
  },
  
  // Text styles
  text: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
  outlineText: {
    color: '#2196F3',
  },
  disabledText: {
    color: '#999999',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-container">
                    <h3>Exercise 3: Identify the Bugs</h3>
                    <p>Find and fix all the bugs in this code:</p>

<pre><code class="language-typescript">const styles = StyleSheet.create({
  container: {
    display: 'block',
    width: '100%',
    padding: '16px',
  },
  card: {
    background: '#fff',
    border-radius: 8,
    box-shadow: '0 2px 4px rgba(0,0,0,0.1)',
  },
  title: {
    font-size: '24px',
    font-weight: 'bold',
  },
});

function Card() {
  return (
    &lt;View style={styles.card}&gt;
      &lt;Text&gt;Hello World&lt;/Text&gt;
    &lt;/View&gt;
  );
}</code></pre>

                    <details>
                        <summary>Show Solution</summary>
<pre><code class="language-typescript">const styles = StyleSheet.create({
  container: {
    // ‚ùå display: 'block' ‚Üí ‚úÖ removed (View uses flex by default)
    // ‚ùå width: '100%' ‚Üí ‚úÖ width: '100%' (percentages are strings, this is OK)
    width: '100%',
    // ‚ùå padding: '16px' ‚Üí ‚úÖ padding: 16
    padding: 16,
  },
  card: {
    // ‚ùå background ‚Üí ‚úÖ backgroundColor
    backgroundColor: '#fff',
    // ‚ùå border-radius ‚Üí ‚úÖ borderRadius (camelCase!)
    borderRadius: 8,
    // ‚ùå box-shadow doesn't exist ‚Üí ‚úÖ platform-specific shadow
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  title: {
    // ‚ùå font-size ‚Üí ‚úÖ fontSize
    // ‚ùå '24px' ‚Üí ‚úÖ 24
    fontSize: 24,
    // ‚ùå font-weight ‚Üí ‚úÖ fontWeight
    fontWeight: 'bold',
  },
});

function Card() {
  return (
    &lt;View style={styles.card}&gt;
      {/* Note: Text has no style, so default system font/size/color */}
      &lt;Text style={styles.title}&gt;Hello World&lt;/Text&gt;
    &lt;/View&gt;
  );
}</code></pre>
                        <p><strong>Bugs found:</strong> <code>display: 'block'</code> invalid, kebab-case properties, string units, <code>background</code> should be <code>backgroundColor</code>, <code>box-shadow</code> doesn't exist, Text component missing style.</p>
                    </details>
                </div>
            </section>

            <section id="summary">
                <h2>Summary</h2>

                <p>You've now built a solid foundation in React Native styling. Let's recap the key takeaways:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üéØ Key Concepts</h4>
                    <ul style="color: white;">
                        <li><strong>StyleSheet.create()</strong> validates and optimizes your styles ‚Äî use it for all static styles</li>
                        <li><strong>No CSS engine</strong> ‚Äî React Native translates JS style objects to native platform styles</li>
                        <li><strong>camelCase properties</strong>, <strong>unitless numbers</strong>, and <strong>no shorthand</strong></li>
                        <li><strong>Flexbox is default</strong> and <code>flexDirection</code> defaults to <code>'column'</code></li>
                        <li><strong>Style arrays</strong> let you combine and conditionally apply styles</li>
                        <li><strong>No inheritance</strong> except for nested <code>Text</code> components</li>
                        <li><strong>Platform differences</strong> exist, especially for shadows</li>
                    </ul>
                </div>

                <h3>Coming Up Next</h3>

                <p>In the next lesson, we'll dive deep into <strong>Flexbox in React Native</strong>. You'll learn how the default <code>flex</code> layout system works, master alignment and distribution, and build common layout patterns used in real mobile apps. The Flexbox knowledge you have from web development will serve you well, but there are some important differences we'll cover.</p>

                <h3>Quick Reference</h3>

<pre><code class="language-typescript">// StyleSheet fundamentals cheat sheet
import { StyleSheet, View, Text } from 'react-native';

// 1. Create styles (at bottom of file)
const styles = StyleSheet.create({
  container: {
    flex: 1,                    // Takes full available space
    backgroundColor: '#fff',    // camelCase!
    padding: 16,                // Unitless number (dp)
  },
  text: {
    fontSize: 16,               // On Text only
    color: '#333',              // On Text only
    fontWeight: 'bold',         // String values
  },
});

// 2. Apply styles
&lt;View style={styles.container}&gt;
  &lt;Text style={styles.text}&gt;Hello&lt;/Text&gt;
&lt;/View&gt;

// 3. Combine styles (array)
&lt;View style={[styles.base, styles.variant, { padding: 20 }]} /&gt;

// 4. Conditional styles
&lt;View style={[styles.box, isActive && styles.active]} /&gt;

// 5. Dynamic inline (for calculated values)
&lt;View style={{ width: screenWidth * 0.8 }} /&gt;</code></pre>
            </section>

            <nav class="lesson-nav">
                <a href="m03_l08_switch_activityindicator_statusbar.html" class="prev-link">‚Üê Previous: Switch, ActivityIndicator & StatusBar</a>
                <a href="index.html" class="home-link">Course Home</a>
                <a href="m04_l02_flexbox_in_react_native.html" class="next-link">Next: Flexbox in React Native ‚Üí</a>
            </nav>
        </article>
    </main>

    <footer class="main-footer">
        <div class="container">
            <p>React Native & Expo Course ¬© 2025</p>
        </div>
    </footer>

    <script>
        // Mobile menu toggle
        const toggle = document.getElementById('mobile-menu-toggle');
        const navLinks = document.getElementById('nav-links');
        
        toggle?.addEventListener('click', () => {
            const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
            toggle.setAttribute('aria-expanded', !isExpanded);
            navLinks?.classList.toggle('active');
        });

        // TOC smooth scrolling
        document.querySelectorAll('.toc-nav a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').slice(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                    // Close TOC on mobile after clicking
                    const toc = document.getElementById('toc');
                    if (toc && window.innerWidth < 768) {
                        toc.removeAttribute('open');
                    }
                }
            });
        });
    </script>
</body>
</html>
