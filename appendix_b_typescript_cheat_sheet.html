<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="TypeScript cheat sheet for React Native development">
    <meta name="author" content="React Native & Expo Course">
    <title>Appendix B: TypeScript Cheat Sheet | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
</head>
<body>
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">‚ò∞</button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#appendices">Appendices</a> &gt;
            <span>Appendix B</span>
        </div>
    </div>
    <main id="main-content">
        <div class="container">
            <header>
                <p class="module-tag">Appendix B</p>
                <h1>üìò TypeScript Cheat Sheet</h1>
                <p class="lesson-subtitle">Essential TypeScript patterns for React Native development</p>
            </header>

            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#component-types">Component Types</a></li>
                        <li><a href="#props-patterns">Props Patterns</a></li>
                        <li><a href="#hooks-types">Hooks Types</a></li>
                        <li><a href="#style-types">Style Types</a></li>
                        <li><a href="#navigation-types">Navigation Types</a></li>
                        <li><a href="#event-types">Event Types</a></li>
                        <li><a href="#api-types">API and Data Types</a></li>
                        <li><a href="#utility-types">Utility Types</a></li>
                    </ul>
                </details>
            </div>

            <!-- Component Types -->
            <section id="component-types">
                <h2>Component Types</h2>

                <div class="card">
                    <h4>Basic Function Component</h4>
                    <pre><code>import { View, Text } from 'react-native';

// Simple component without props
function Welcome(): JSX.Element {
  return &lt;Text&gt;Welcome!&lt;/Text&gt;;
}

// With React.FC (includes children by default)
const Welcome: React.FC = () =&gt; {
  return &lt;Text&gt;Welcome!&lt;/Text&gt;;
};

// Recommended: explicit return type
function Welcome(): React.ReactElement {
  return &lt;Text&gt;Welcome!&lt;/Text&gt;;
}</code></pre>
                </div>

                <div class="card">
                    <h4>Component with Props</h4>
                    <pre><code>// Define props interface
interface GreetingProps {
  name: string;
  age?: number; // Optional prop
}

// Function component with props
function Greeting({ name, age }: GreetingProps): JSX.Element {
  return (
    &lt;View&gt;
      &lt;Text&gt;Hello, {name}!&lt;/Text&gt;
      {age &amp;&amp; &lt;Text&gt;Age: {age}&lt;/Text&gt;}
    &lt;/View&gt;
  );
}

// Arrow function variant
const Greeting = ({ name, age }: GreetingProps): JSX.Element =&gt; {
  return &lt;Text&gt;Hello, {name}!&lt;/Text&gt;;
};</code></pre>
                </div>

                <div class="card">
                    <h4>Component with Children</h4>
                    <pre><code>import { PropsWithChildren } from 'react';

// Using PropsWithChildren helper
interface CardProps {
  title: string;
}

function Card({ title, children }: PropsWithChildren&lt;CardProps&gt;): JSX.Element {
  return (
    &lt;View&gt;
      &lt;Text&gt;{title}&lt;/Text&gt;
      {children}
    &lt;/View&gt;
  );
}

// Explicit children type
interface CardProps {
  title: string;
  children: React.ReactNode;
}

// Specific children type
interface ListProps {
  children: React.ReactElement | React.ReactElement[];
}</code></pre>
                </div>

                <div class="card">
                    <h4>Generic Components</h4>
                    <pre><code>// Generic list component
interface ListProps&lt;T&gt; {
  items: T[];
  renderItem: (item: T) =&gt; React.ReactElement;
  keyExtractor: (item: T) =&gt; string;
}

function List&lt;T&gt;({ items, renderItem, keyExtractor }: ListProps&lt;T&gt;): JSX.Element {
  return (
    &lt;View&gt;
      {items.map(item =&gt; (
        &lt;View key={keyExtractor(item)}&gt;
          {renderItem(item)}
        &lt;/View&gt;
      ))}
    &lt;/View&gt;
  );
}

// Usage
&lt;List
  items={users}
  renderItem={(user) =&gt; &lt;Text&gt;{user.name}&lt;/Text&gt;}
  keyExtractor={(user) =&gt; user.id}
/&gt;</code></pre>
                </div>
            </section>

            <!-- Props Patterns -->
            <section id="props-patterns">
                <h2>Props Patterns</h2>

                <div class="card">
                    <h4>Default Props</h4>
                    <pre><code>interface ButtonProps {
  title: string;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

// Default values in destructuring
function Button({ 
  title, 
  variant = 'primary', 
  disabled = false 
}: ButtonProps): JSX.Element {
  return (
    &lt;Pressable disabled={disabled}&gt;
      &lt;Text&gt;{title}&lt;/Text&gt;
    &lt;/Pressable&gt;
  );
}</code></pre>
                </div>

                <div class="card">
                    <h4>Extending Native Props</h4>
                    <pre><code>import { PressableProps, TextInputProps, ViewProps } from 'react-native';

// Extend Pressable props
interface CustomButtonProps extends PressableProps {
  title: string;
  variant?: 'primary' | 'secondary';
}

function CustomButton({ title, variant, ...pressableProps }: CustomButtonProps) {
  return (
    &lt;Pressable {...pressableProps}&gt;
      &lt;Text&gt;{title}&lt;/Text&gt;
    &lt;/Pressable&gt;
  );
}

// Extend TextInput props
interface CustomInputProps extends TextInputProps {
  label: string;
  error?: string;
}

// Extend View props
interface CardProps extends ViewProps {
  title: string;
}</code></pre>
                </div>

                <div class="card">
                    <h4>Discriminated Unions (Conditional Props)</h4>
                    <pre><code>// Button can be 'button' type with onPress OR 'link' type with href
type ButtonProps = 
  | {
      type: 'button';
      onPress: () =&gt; void;
      href?: never;
    }
  | {
      type: 'link';
      href: string;
      onPress?: never;
    };

interface BaseButtonProps {
  title: string;
  disabled?: boolean;
}

function Button({ title, ...props }: BaseButtonProps &amp; ButtonProps) {
  if (props.type === 'button') {
    return &lt;Pressable onPress={props.onPress}&gt;&lt;Text&gt;{title}&lt;/Text&gt;&lt;/Pressable&gt;;
  }
  return &lt;Link href={props.href}&gt;{title}&lt;/Link&gt;;
}</code></pre>
                </div>

                <div class="card">
                    <h4>Callback Props</h4>
                    <pre><code>interface FormProps {
  // Simple callback
  onSubmit: () =&gt; void;
  
  // Callback with parameter
  onChange: (value: string) =&gt; void;
  
  // Callback with multiple parameters
  onError: (error: Error, context: string) =&gt; void;
  
  // Async callback
  onSave: () =&gt; Promise&lt;void&gt;;
  
  // Optional callback
  onCancel?: () =&gt; void;
  
  // Callback returning value
  validate: (value: string) =&gt; boolean;
}</code></pre>
                </div>
            </section>

            <!-- Hooks Types -->
            <section id="hooks-types">
                <h2>Hooks Types</h2>

                <div class="card">
                    <h4>useState</h4>
                    <pre><code>// Type inferred from initial value
const [count, setCount] = useState(0); // number
const [name, setName] = useState(''); // string
const [active, setActive] = useState(false); // boolean

// Explicit type for complex values
interface User {
  id: string;
  name: string;
  email: string;
}

const [user, setUser] = useState&lt;User | null&gt;(null);
const [users, setUsers] = useState&lt;User[]&gt;([]);

// Union types
const [status, setStatus] = useState&lt;'idle' | 'loading' | 'success' | 'error'&gt;('idle');

// Lazy initialization
const [state, setState] = useState&lt;ExpensiveState&gt;(() =&gt; computeExpensiveValue());</code></pre>
                </div>

                <div class="card">
                    <h4>useRef</h4>
                    <pre><code>import { useRef } from 'react';
import { TextInput, View, ScrollView } from 'react-native';

// DOM/Native element refs
const inputRef = useRef&lt;TextInput&gt;(null);
const viewRef = useRef&lt;View&gt;(null);
const scrollRef = useRef&lt;ScrollView&gt;(null);

// Usage
inputRef.current?.focus();
scrollRef.current?.scrollToEnd();

// Mutable value ref (doesn't trigger re-render)
const countRef = useRef&lt;number&gt;(0);
countRef.current = 5;

// Store previous value
const prevValueRef = useRef&lt;string&gt;();
useEffect(() =&gt; {
  prevValueRef.current = value;
}, [value]);</code></pre>
                </div>

                <div class="card">
                    <h4>useReducer</h4>
                    <pre><code>// Define state and action types
interface State {
  count: number;
  error: string | null;
}

type Action = 
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset'; payload: number }
  | { type: 'setError'; payload: string };

// Reducer function
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + 1 };
    case 'decrement':
      return { ...state, count: state.count - 1 };
    case 'reset':
      return { ...state, count: action.payload };
    case 'setError':
      return { ...state, error: action.payload };
    default:
      return state;
  }
}

// Usage
const [state, dispatch] = useReducer(reducer, { count: 0, error: null });
dispatch({ type: 'increment' });
dispatch({ type: 'reset', payload: 10 });</code></pre>
                </div>

                <div class="card">
                    <h4>useContext</h4>
                    <pre><code>import { createContext, useContext, PropsWithChildren } from 'react';

// Define context type
interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) =&gt; Promise&lt;void&gt;;
  logout: () =&gt; void;
  isLoading: boolean;
}

// Create context with default value
const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);

// Custom hook with type safety
function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Provider component
function AuthProvider({ children }: PropsWithChildren): JSX.Element {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [isLoading, setIsLoading] = useState(false);
  
  const login = async (email: string, password: string) =&gt; { /* ... */ };
  const logout = () =&gt; { /* ... */ };
  
  return (
    &lt;AuthContext.Provider value={{ user, login, logout, isLoading }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}</code></pre>
                </div>

                <div class="card">
                    <h4>Custom Hooks</h4>
                    <pre><code>// Return tuple
function useToggle(initial: boolean = false): [boolean, () =&gt; void] {
  const [value, setValue] = useState(initial);
  const toggle = useCallback(() =&gt; setValue(v =&gt; !v), []);
  return [value, toggle];
}

// Return object
interface UseCounterReturn {
  count: number;
  increment: () =&gt; void;
  decrement: () =&gt; void;
  reset: () =&gt; void;
}

function useCounter(initial: number = 0): UseCounterReturn {
  const [count, setCount] = useState(initial);
  return {
    count,
    increment: () =&gt; setCount(c =&gt; c + 1),
    decrement: () =&gt; setCount(c =&gt; c - 1),
    reset: () =&gt; setCount(initial),
  };
}

// Generic custom hook
function useAsync&lt;T&gt;(asyncFn: () =&gt; Promise&lt;T&gt;) {
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  const [loading, setLoading] = useState(false);
  
  // ... implementation
  
  return { data, error, loading };
}</code></pre>
                </div>
            </section>

            <!-- Style Types -->
            <section id="style-types">
                <h2>Style Types</h2>

                <div class="card">
                    <h4>StyleSheet Types</h4>
                    <pre><code>import { StyleSheet, ViewStyle, TextStyle, ImageStyle } from 'react-native';

// Individual style types
const containerStyle: ViewStyle = {
  flex: 1,
  backgroundColor: '#fff',
};

const textStyle: TextStyle = {
  fontSize: 16,
  fontWeight: 'bold',
};

const imageStyle: ImageStyle = {
  width: 100,
  height: 100,
  resizeMode: 'cover',
};

// StyleSheet.create is typed automatically
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
  },
});</code></pre>
                </div>

                <div class="card">
                    <h4>Style Props</h4>
                    <pre><code>import { StyleProp, ViewStyle, TextStyle } from 'react-native';

interface CardProps {
  // Single style
  style?: ViewStyle;
  
  // Style prop (allows arrays and undefined)
  containerStyle?: StyleProp&lt;ViewStyle&gt;;
  titleStyle?: StyleProp&lt;TextStyle&gt;;
}

function Card({ style, containerStyle, titleStyle }: CardProps) {
  return (
    &lt;View style={[styles.container, containerStyle]}&gt;
      &lt;Text style={[styles.title, titleStyle]}&gt;Title&lt;/Text&gt;
    &lt;/View&gt;
  );
}

// Usage - all valid
&lt;Card style={{ padding: 10 }} /&gt;
&lt;Card containerStyle={[styles.custom, { margin: 5 }]} /&gt;
&lt;Card containerStyle={isActive &amp;&amp; styles.active} /&gt;</code></pre>
                </div>

                <div class="card">
                    <h4>Dynamic Styles</h4>
                    <pre><code>// Function returning styles
const getDynamicStyles = (isActive: boolean): ViewStyle =&gt; ({
  backgroundColor: isActive ? 'blue' : 'gray',
  opacity: isActive ? 1 : 0.5,
});

// Typed style function
type VariantStyles = {
  [key in 'primary' | 'secondary' | 'danger']: ViewStyle;
};

const variantStyles: VariantStyles = {
  primary: { backgroundColor: '#007AFF' },
  secondary: { backgroundColor: '#5856D6' },
  danger: { backgroundColor: '#FF3B30' },
};

// Usage
const buttonStyle = variantStyles[variant];</code></pre>
                </div>
            </section>

            <!-- Navigation Types -->
            <section id="navigation-types">
                <h2>Navigation Types (Expo Router)</h2>

                <div class="card">
                    <h4>Route Parameters</h4>
                    <pre><code>import { useLocalSearchParams, useGlobalSearchParams } from 'expo-router';

// Simple params
export default function UserScreen() {
  const { id } = useLocalSearchParams&lt;{ id: string }&gt;();
  return &lt;Text&gt;User ID: {id}&lt;/Text&gt;;
}

// Multiple params
interface ProductParams {
  id: string;
  category?: string;
  sort?: 'price' | 'name' | 'date';
}

export default function ProductScreen() {
  const { id, category, sort } = useLocalSearchParams&lt;ProductParams&gt;();
  // ...
}

// Array params (for catch-all routes)
export default function CatchAll() {
  const { slug } = useLocalSearchParams&lt;{ slug: string[] }&gt;();
  // slug is string[]
}</code></pre>
                </div>

                <div class="card">
                    <h4>Typed Navigation</h4>
                    <pre><code>import { router, Link, Href } from 'expo-router';

// Programmatic navigation
router.push('/users/123');
router.push({
  pathname: '/users/[id]',
  params: { id: '123' }
});

// Type-safe Link
&lt;Link href="/profile"&gt;Profile&lt;/Link&gt;
&lt;Link 
  href={{
    pathname: '/users/[id]',
    params: { id: user.id }
  }}
&gt;
  View User
&lt;/Link&gt;

// Navigation with replace
router.replace('/home');

// Go back
router.back();</code></pre>
                </div>

                <div class="card">
                    <h4>Stack Screen Options</h4>
                    <pre><code>import { Stack } from 'expo-router';

// Typed screen options
&lt;Stack.Screen
  name="profile"
  options={{
    title: 'Profile',
    headerShown: true,
    presentation: 'modal',
    animation: 'slide_from_right',
  }}
/&gt;

// Dynamic options
&lt;Stack.Screen
  name="[id]"
  options={({ route }) =&gt; ({
    title: `Item ${route.params?.id}`,
  })}
/&gt;</code></pre>
                </div>
            </section>

            <!-- Event Types -->
            <section id="event-types">
                <h2>Event Types</h2>

                <div class="card">
                    <h4>Common Event Types</h4>
                    <pre><code>import {
  GestureResponderEvent,
  NativeSyntheticEvent,
  TextInputChangeEventData,
  TextInputSubmitEditingEventData,
  TextInputFocusEventData,
  LayoutChangeEvent,
  NativeScrollEvent,
} from 'react-native';

// Press events
const handlePress = (event: GestureResponderEvent) =&gt; {
  console.log('Pressed at:', event.nativeEvent.locationX);
};

// TextInput events
const handleChange = (e: NativeSyntheticEvent&lt;TextInputChangeEventData&gt;) =&gt; {
  console.log('New text:', e.nativeEvent.text);
};

const handleSubmit = (e: NativeSyntheticEvent&lt;TextInputSubmitEditingEventData&gt;) =&gt; {
  console.log('Submitted:', e.nativeEvent.text);
};

// Simpler: just use the value
const handleChangeText = (text: string) =&gt; {
  setValue(text);
};

// Layout events
const handleLayout = (event: LayoutChangeEvent) =&gt; {
  const { width, height, x, y } = event.nativeEvent.layout;
};

// Scroll events
const handleScroll = (event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) =&gt; {
  const { contentOffset, contentSize } = event.nativeEvent;
};</code></pre>
                </div>

                <div class="card">
                    <h4>FlatList Event Types</h4>
                    <pre><code>import { ListRenderItem, ListRenderItemInfo } from 'react-native';

interface Item {
  id: string;
  title: string;
}

// renderItem function type
const renderItem: ListRenderItem&lt;Item&gt; = ({ item, index }) =&gt; (
  &lt;Text&gt;{item.title}&lt;/Text&gt;
);

// Or with full info object
const renderItem = ({ item, index, separators }: ListRenderItemInfo&lt;Item&gt;) =&gt; (
  &lt;Pressable
    onPressIn={() =&gt; separators.highlight()}
    onPressOut={() =&gt; separators.unhighlight()}
  &gt;
    &lt;Text&gt;{item.title}&lt;/Text&gt;
  &lt;/Pressable&gt;
);

// keyExtractor
const keyExtractor = (item: Item, index: number): string =&gt; item.id;</code></pre>
                </div>
            </section>

            <!-- API Types -->
            <section id="api-types">
                <h2>API and Data Types</h2>

                <div class="card">
                    <h4>API Response Types</h4>
                    <pre><code>// Define your data types
interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  createdAt: string;
}

interface PaginatedResponse&lt;T&gt; {
  data: T[];
  page: number;
  totalPages: number;
  totalItems: number;
}

interface ApiError {
  message: string;
  code: string;
  status: number;
}

// Typed fetch function
async function fetchUsers(): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {
  const response = await fetch('/api/users');
  if (!response.ok) {
    const error: ApiError = await response.json();
    throw new Error(error.message);
  }
  return response.json();
}

// Generic fetch wrapper
async function api&lt;T&gt;(url: string, options?: RequestInit): Promise&lt;T&gt; {
  const response = await fetch(url, options);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  return response.json() as Promise&lt;T&gt;;
}

// Usage
const users = await api&lt;User[]&gt;('/api/users');
const user = await api&lt;User&gt;('/api/users/123');</code></pre>
                </div>

                <div class="card">
                    <h4>Form Data Types</h4>
                    <pre><code>// Form state type
interface LoginForm {
  email: string;
  password: string;
  rememberMe: boolean;
}

// Form errors type
type FormErrors&lt;T&gt; = Partial&lt;Record&lt;keyof T, string&gt;&gt;;

// Usage
const [form, setForm] = useState&lt;LoginForm&gt;({
  email: '',
  password: '',
  rememberMe: false,
});

const [errors, setErrors] = useState&lt;FormErrors&lt;LoginForm&gt;&gt;({});

// Validation function
function validate(form: LoginForm): FormErrors&lt;LoginForm&gt; {
  const errors: FormErrors&lt;LoginForm&gt; = {};
  if (!form.email) errors.email = 'Email is required';
  if (!form.password) errors.password = 'Password is required';
  return errors;
}</code></pre>
                </div>

                <div class="card">
                    <h4>AsyncStorage Types</h4>
                    <pre><code>import AsyncStorage from '@react-native-async-storage/async-storage';

// Typed storage helpers
async function storeData&lt;T&gt;(key: string, value: T): Promise&lt;void&gt; {
  const jsonValue = JSON.stringify(value);
  await AsyncStorage.setItem(key, jsonValue);
}

async function getData&lt;T&gt;(key: string): Promise&lt;T | null&gt; {
  const jsonValue = await AsyncStorage.getItem(key);
  return jsonValue != null ? JSON.parse(jsonValue) as T : null;
}

// Usage
interface Settings {
  theme: 'light' | 'dark';
  notifications: boolean;
}

await storeData&lt;Settings&gt;('settings', { theme: 'dark', notifications: true });
const settings = await getData&lt;Settings&gt;('settings');</code></pre>
                </div>
            </section>

            <!-- Utility Types -->
            <section id="utility-types">
                <h2>Utility Types</h2>

                <div class="card">
                    <h4>Built-in Utility Types</h4>
                    <pre><code>interface User {
  id: string;
  name: string;
  email: string;
  age: number;
}

// Partial - all properties optional
type PartialUser = Partial&lt;User&gt;;
// { id?: string; name?: string; email?: string; age?: number; }

// Required - all properties required
type RequiredUser = Required&lt;PartialUser&gt;;

// Pick - select specific properties
type UserPreview = Pick&lt;User, 'id' | 'name'&gt;;
// { id: string; name: string; }

// Omit - exclude specific properties
type UserWithoutEmail = Omit&lt;User, 'email'&gt;;
// { id: string; name: string; age: number; }

// Record - create object type
type UserRoles = Record&lt;string, 'admin' | 'user' | 'guest'&gt;;
// { [key: string]: 'admin' | 'user' | 'guest' }

// Exclude - remove types from union
type Status = 'idle' | 'loading' | 'success' | 'error';
type ActiveStatus = Exclude&lt;Status, 'idle'&gt;;
// 'loading' | 'success' | 'error'

// Extract - keep only matching types
type SuccessStatus = Extract&lt;Status, 'success' | 'error'&gt;;
// 'success' | 'error'

// NonNullable - remove null and undefined
type MaybeString = string | null | undefined;
type DefiniteString = NonNullable&lt;MaybeString&gt;;
// string</code></pre>
                </div>

                <div class="card">
                    <h4>Custom Utility Types</h4>
                    <pre><code>// Make specific properties optional
type PartialBy&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; Partial&lt;Pick&lt;T, K&gt;&gt;;

// Usage: User with optional email
type UserOptionalEmail = PartialBy&lt;User, 'email'&gt;;

// Make specific properties required
type RequiredBy&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;;

// Deep partial (nested objects also partial)
type DeepPartial&lt;T&gt; = {
  [P in keyof T]?: T[P] extends object ? DeepPartial&lt;T[P]&gt; : T[P];
};

// Nullable type
type Nullable&lt;T&gt; = T | null;

// Array element type
type ArrayElement&lt;T&gt; = T extends (infer E)[] ? E : never;

// Usage
type Users = User[];
type SingleUser = ArrayElement&lt;Users&gt;; // User

// Function return type
type FetchUserReturn = ReturnType&lt;typeof fetchUser&gt;;

// Function parameter types
type FetchUserParams = Parameters&lt;typeof fetchUser&gt;;</code></pre>
                </div>

                <div class="card">
                    <h4>Type Guards</h4>
                    <pre><code>// Type guard function
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &amp;&amp;
    obj !== null &amp;&amp;
    'id' in obj &amp;&amp;
    'name' in obj &amp;&amp;
    'email' in obj
  );
}

// Usage
function processData(data: unknown) {
  if (isUser(data)) {
    // TypeScript knows data is User here
    console.log(data.email);
  }
}

// Array type guard
function isUserArray(arr: unknown): arr is User[] {
  return Array.isArray(arr) &amp;&amp; arr.every(isUser);
}

// Discriminated union guard
type Result&lt;T&gt; = 
  | { success: true; data: T }
  | { success: false; error: string };

function handleResult&lt;T&gt;(result: Result&lt;T&gt;) {
  if (result.success) {
    // TypeScript knows result.data exists
    console.log(result.data);
  } else {
    // TypeScript knows result.error exists
    console.error(result.error);
  }
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9;">
                    <h4>‚úÖ TypeScript Best Practices</h4>
                    <ul>
                        <li>Prefer <code>interface</code> for object types, <code>type</code> for unions/intersections</li>
                        <li>Use <code>unknown</code> instead of <code>any</code> when type is truly unknown</li>
                        <li>Enable strict mode in tsconfig.json</li>
                        <li>Use type inference when the type is obvious</li>
                        <li>Create reusable types in a central <code>types/</code> directory</li>
                        <li>Use type guards for runtime type checking</li>
                        <li>Avoid type assertions (<code>as</code>) when possible</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a href="appendix_a_common_errors_and_solutions.html" class="prev-link">‚Üê Previous: Common Errors</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="appendix_c_component_reference.html" class="next-link">Next: Component Reference ‚Üí</a>
            </div>
        </div>
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>