<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Understanding React Native app performance fundamentals and metrics">
    <meta name="author" content="React Native & Expo Course">
    <title>App Performance Fundamentals | Module 10: Performance Optimization | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m10_l01_app_performance.html">Module 10</a> &gt;
            <span>Lesson 10.1</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 10: Performance Optimization</p>
                <h1>App Performance Fundamentals</h1>
                <p class="lesson-subtitle">Understanding performance metrics, bottlenecks, and optimization strategies</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Understand React Native's architecture and performance implications</li>
                    <li>Learn key performance metrics and how to measure them</li>
                    <li>Identify common performance bottlenecks</li>
                    <li>Understand the difference between JS and UI thread performance</li>
                    <li>Develop a performance-first mindset</li>
                    <li>Learn when and how to optimize</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#why-performance">Why Performance Matters</a></li>
                        <li><a href="#architecture">React Native Architecture</a></li>
                        <li><a href="#metrics">Key Performance Metrics</a></li>
                        <li><a href="#bottlenecks">Common Bottlenecks</a></li>
                        <li><a href="#threads">JS Thread vs UI Thread</a></li>
                        <li><a href="#measuring">Measuring Performance</a></li>
                        <li><a href="#optimization-mindset">Optimization Mindset</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- Why Performance Matters -->
            <section id="why-performance">
                <h2>Why Performance Matters</h2>

                <p>Performance isn't just about speed‚Äîit directly impacts user experience, engagement, and business metrics. Users have high expectations for mobile apps, and poor performance leads to uninstalls.</p>

                <h3>The Business Impact</h3>

                <!-- SVG: Performance Impact -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 280" style="max-width: 700px; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="280" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="350" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">Performance Impact on User Behavior</text>
                        
                        <!-- Stats cards -->
                        <g transform="translate(30, 60)">
                            <rect width="140" height="100" fill="#f44336" rx="10"/>
                            <text x="70" y="35" text-anchor="middle" font-size="28" font-weight="bold" fill="white">53%</text>
                            <text x="70" y="55" text-anchor="middle" font-size="10" fill="white">of users abandon</text>
                            <text x="70" y="70" text-anchor="middle" font-size="10" fill="white">apps that take</text>
                            <text x="70" y="85" text-anchor="middle" font-size="10" fill="white">&gt;3s to load</text>
                        </g>
                        
                        <g transform="translate(190, 60)">
                            <rect width="140" height="100" fill="#FF9800" rx="10"/>
                            <text x="70" y="35" text-anchor="middle" font-size="28" font-weight="bold" fill="white">1 star</text>
                            <text x="70" y="55" text-anchor="middle" font-size="10" fill="white">rating drop for</text>
                            <text x="70" y="70" text-anchor="middle" font-size="10" fill="white">every 100ms of</text>
                            <text x="70" y="85" text-anchor="middle" font-size="10" fill="white">added latency</text>
                        </g>
                        
                        <g transform="translate(350, 60)">
                            <rect width="140" height="100" fill="#4CAF50" rx="10"/>
                            <text x="70" y="35" text-anchor="middle" font-size="28" font-weight="bold" fill="white">60 FPS</text>
                            <text x="70" y="55" text-anchor="middle" font-size="10" fill="white">target frame rate</text>
                            <text x="70" y="70" text-anchor="middle" font-size="10" fill="white">for smooth</text>
                            <text x="70" y="85" text-anchor="middle" font-size="10" fill="white">animations</text>
                        </g>
                        
                        <g transform="translate(510, 60)">
                            <rect width="140" height="100" fill="#2196F3" rx="10"/>
                            <text x="70" y="35" text-anchor="middle" font-size="28" font-weight="bold" fill="white">16ms</text>
                            <text x="70" y="55" text-anchor="middle" font-size="10" fill="white">frame budget</text>
                            <text x="70" y="70" text-anchor="middle" font-size="10" fill="white">for each render</text>
                            <text x="70" y="85" text-anchor="middle" font-size="10" fill="white">(1000ms / 60fps)</text>
                        </g>
                        
                        <!-- Bottom insight -->
                        <rect x="30" y="180" width="620" height="80" fill="#e3f2fd" rx="10"/>
                        <text x="350" y="210" text-anchor="middle" font-size="12" font-weight="bold" fill="#1976D2">Key Insight</text>
                        <text x="350" y="235" text-anchor="middle" font-size="11" fill="#333">Users perceive delays as short as 100ms. Anything over 1 second breaks flow.</text>
                        <text x="350" y="250" text-anchor="middle" font-size="11" fill="#333">Smooth 60 FPS animations require completing all work within 16ms per frame.</text>
                    </svg>
                </div>

                <h3>User Perception of Speed</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Delay</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">User Perception</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Recommended Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">0-100ms</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Instant</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">No feedback needed</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">100-300ms</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Slight delay</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Subtle feedback (button press effect)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">300-1000ms</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Noticeable delay</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Loading indicator recommended</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">1-5 seconds</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Waiting</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Progress indicator required</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">&gt;5 seconds</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Frustration / abandonment</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Optimize or use background processing</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- React Native Architecture -->
            <section id="architecture">
                <h2>React Native Architecture</h2>

                <p>Understanding React Native's architecture is essential for optimizing performance. The way your JavaScript code communicates with native components directly affects app speed.</p>

                <h3>The Bridge Architecture (Legacy)</h3>

                <pre class="mermaid">
flowchart LR
    subgraph JS["JavaScript Thread"]
        A[React Components] --> B[JS Bundle]
    end
    
    subgraph Bridge["Bridge (Async, JSON)"]
        C[Serialization]
    end
    
    subgraph Native["Native Thread"]
        D[Native Modules]
        E[Native UI]
    end
    
    B --> C
    C --> D
    C --> E
    
    style Bridge fill:#ffeb3b,stroke:#f57c00
    style JS fill:#61dafb,stroke:#21a1c4
    style Native fill:#4CAF50,stroke:#2e7d32
</pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Bridge Bottleneck</h4>
                    <p>The bridge serializes all communication as JSON. This creates overhead when:</p>
                    <ul>
                        <li>Sending large amounts of data</li>
                        <li>Making frequent calls (animations, gestures)</li>
                        <li>Synchronizing state between JS and Native</li>
                    </ul>
                </div>

                <h3>The New Architecture (Fabric + TurboModules)</h3>

                <pre class="mermaid">
flowchart LR
    subgraph JS["JavaScript Thread"]
        A[React Components]
        B[JSI - JavaScript Interface]
    end
    
    subgraph Native["Native Thread"]
        C[TurboModules]
        D[Fabric Renderer]
    end
    
    B <-->|"Direct C++ Calls"| C
    B <-->|"Synchronous"| D
    
    style JS fill:#61dafb,stroke:#21a1c4
    style Native fill:#4CAF50,stroke:#2e7d32
</pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ New Architecture Benefits</h4>
                    <ul>
                        <li><strong>JSI (JavaScript Interface):</strong> Direct communication without JSON serialization</li>
                        <li><strong>TurboModules:</strong> Lazy loading of native modules</li>
                        <li><strong>Fabric:</strong> Synchronous rendering with concurrent features</li>
                        <li><strong>Codegen:</strong> Type-safe native code generation</li>
                    </ul>
                </div>

                <h3>Enabling New Architecture</h3>

                <pre><code>// app.json (Expo SDK 51+)
{
  "expo": {
    "newArchEnabled": true
  }
}

// For bare React Native, see official migration guide</code></pre>
            </section>

            <!-- Key Performance Metrics -->
            <section id="metrics">
                <h2>Key Performance Metrics</h2>

                <p>To optimize performance, you need to measure it. These are the key metrics to track in React Native apps.</p>

                <h3>Frame Rate Metrics</h3>

                <!-- SVG: Frame Rate Visualization -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 600 200" style="max-width: 600px; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="600" height="200" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="300" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Frame Rate Comparison</text>
                        
                        <!-- 60 FPS (good) -->
                        <g transform="translate(30, 50)">
                            <text x="0" y="0" font-size="11" font-weight="bold" fill="#4CAF50">60 FPS (Smooth)</text>
                            <g transform="translate(0, 15)">
                                <!-- Evenly spaced frames -->
                                <rect x="0" y="0" width="8" height="40" fill="#4CAF50"/>
                                <rect x="15" y="0" width="8" height="40" fill="#4CAF50"/>
                                <rect x="30" y="0" width="8" height="40" fill="#4CAF50"/>
                                <rect x="45" y="0" width="8" height="40" fill="#4CAF50"/>
                                <rect x="60" y="0" width="8" height="40" fill="#4CAF50"/>
                                <rect x="75" y="0" width="8" height="40" fill="#4CAF50"/>
                                <rect x="90" y="0" width="8" height="40" fill="#4CAF50"/>
                                <rect x="105" y="0" width="8" height="40" fill="#4CAF50"/>
                                <text x="130" y="25" font-size="10" fill="#666">16ms per frame ‚úì</text>
                            </g>
                        </g>
                        
                        <!-- 30 FPS (janky) -->
                        <g transform="translate(30, 120)">
                            <text x="0" y="0" font-size="11" font-weight="bold" fill="#FF9800">30 FPS (Janky)</text>
                            <g transform="translate(0, 15)">
                                <!-- Unevenly spaced frames with gaps -->
                                <rect x="0" y="0" width="8" height="40" fill="#FF9800"/>
                                <rect x="30" y="0" width="8" height="40" fill="#FF9800"/>
                                <rect x="60" y="0" width="8" height="40" fill="#FF9800"/>
                                <rect x="90" y="0" width="8" height="40" fill="#FF9800"/>
                                <text x="130" y="25" font-size="10" fill="#666">33ms per frame - Dropped frames!</text>
                            </g>
                        </g>
                        
                        <!-- Timeline -->
                        <line x1="350" y1="60" x2="350" y2="180" stroke="#ddd" stroke-width="1"/>
                        <text x="470" y="80" font-size="10" fill="#333" font-weight="bold">Target: 60 FPS</text>
                        <text x="470" y="100" font-size="9" fill="#666">‚Ä¢ UI Thread: &lt;16ms</text>
                        <text x="470" y="115" font-size="9" fill="#666">‚Ä¢ JS Thread: &lt;16ms</text>
                        <text x="470" y="130" font-size="9" fill="#666">‚Ä¢ No dropped frames</text>
                        <text x="470" y="150" font-size="9" fill="#666">‚Ä¢ Smooth scrolling</text>
                        <text x="470" y="165" font-size="9" fill="#666">‚Ä¢ Responsive touches</text>
                    </svg>
                </div>

                <h3>Core Metrics</h3>

                <pre><code>// Key metrics to monitor

// 1. Frame Rate (FPS)
// Target: 60 FPS (or 120 FPS on ProMotion devices)
// Measured: JS thread FPS + UI thread FPS

// 2. Time to Interactive (TTI)
// Target: < 3 seconds
// When app becomes fully interactive after launch

// 3. First Contentful Paint (FCP)
// Target: < 1.8 seconds
// When first content appears on screen

// 4. JavaScript Bundle Size
// Target: < 1MB compressed
// Smaller = faster download and parse time

// 5. Memory Usage
// Target: < 200MB typical usage
// Monitor for leaks over time

// 6. App Size
// Target: < 50MB initial download
// Affects download conversion rates</code></pre>

                <h3>Metric Targets</h3>

                <div class="card">
                    <h4>üéØ Performance Budget</h4>
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f5f5f5;">
                                <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Metric</th>
                                <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Good</th>
                                <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Needs Work</th>
                                <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Poor</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Frame Rate</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #4CAF50;">‚â•55 FPS</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #FF9800;">45-55 FPS</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #f44336;">&lt;45 FPS</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">TTI</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #4CAF50;">&lt;2s</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #FF9800;">2-4s</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #f44336;">&gt;4s</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">JS Bundle</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #4CAF50;">&lt;500KB</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #FF9800;">500KB-1MB</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #f44336;">&gt;1MB</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Memory</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #4CAF50;">&lt;150MB</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #FF9800;">150-300MB</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee; color: #f44336;">&gt;300MB</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Common Bottlenecks -->
            <section id="bottlenecks">
                <h2>Common Bottlenecks</h2>

                <p>Knowing where performance problems typically occur helps you avoid them from the start.</p>

                <h3>Bottleneck Categories</h3>

                <pre class="mermaid">
mindmap
  root((Performance<br/>Bottlenecks))
    Rendering
      Unnecessary re-renders
      Large component trees
      Heavy inline styles
      Unoptimized images
    JavaScript
      Expensive calculations
      Large bundle size
      Blocking operations
      Memory leaks
    Bridge/Native
      Frequent bridge calls
      Large data transfers
      Unoptimized native code
    Network
      Slow API calls
      No caching
      Large payloads
      Waterfall requests
</pre>

                <h3>Top 10 Performance Issues</h3>

                <div class="card">
                    <h4>üî¥ Most Common Performance Killers</h4>
                    <ol>
                        <li><strong>Unnecessary re-renders</strong> - Components re-rendering when props haven't changed</li>
                        <li><strong>Inline function/object creation</strong> - Creating new references on every render</li>
                        <li><strong>Large lists without virtualization</strong> - Using ScrollView instead of FlatList</li>
                        <li><strong>Unoptimized images</strong> - Large images without caching or resizing</li>
                        <li><strong>Synchronous storage operations</strong> - Blocking the JS thread</li>
                        <li><strong>Complex animations on JS thread</strong> - Not using native driver</li>
                        <li><strong>Memory leaks</strong> - Subscriptions not cleaned up</li>
                        <li><strong>Large initial bundle</strong> - No code splitting or lazy loading</li>
                        <li><strong>Excessive console.log</strong> - Left in production builds</li>
                        <li><strong>Network waterfalls</strong> - Sequential instead of parallel requests</li>
                    </ol>
                </div>

                <h3>Quick Wins</h3>

                <pre><code>// ‚ùå Common mistakes

// 1. Inline functions cause re-renders
&lt;Button onPress={() => handlePress(id)} /&gt;

// ‚úÖ Fix: useCallback
const handlePressCallback = useCallback(() => {
  handlePress(id);
}, [id]);
&lt;Button onPress={handlePressCallback} /&gt;


// ‚ùå 2. Inline objects create new references
&lt;View style={{ marginTop: 10 }} /&gt;

// ‚úÖ Fix: StyleSheet
const styles = StyleSheet.create({
  container: { marginTop: 10 }
});
&lt;View style={styles.container} /&gt;


// ‚ùå 3. Computing in render
function UserList({ users }) {
  const sortedUsers = users.sort((a, b) => a.name.localeCompare(b.name));
  // ...
}

// ‚úÖ Fix: useMemo
function UserList({ users }) {
  const sortedUsers = useMemo(() => 
    [...users].sort((a, b) => a.name.localeCompare(b.name)),
    [users]
  );
  // ...
}


// ‚ùå 4. Console.log in production
console.log('Debug:', data);

// ‚úÖ Fix: Use __DEV__ check or remove
if (__DEV__) {
  console.log('Debug:', data);
}</code></pre>
            </section>

            <!-- JS Thread vs UI Thread -->
            <section id="threads">
                <h2>JS Thread vs UI Thread</h2>

                <p>React Native runs on multiple threads. Understanding their roles is crucial for optimization.</p>

                <h3>Thread Architecture</h3>

                <!-- SVG: Thread Visualization -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 320" style="max-width: 700px; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="320" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="350" y="25" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">React Native Thread Model</text>
                        
                        <!-- JS Thread -->
                        <g transform="translate(30, 50)">
                            <rect width="200" height="120" fill="#61dafb" rx="10"/>
                            <text x="100" y="25" text-anchor="middle" font-size="13" font-weight="bold" fill="white">JavaScript Thread</text>
                            <text x="100" y="50" text-anchor="middle" font-size="10" fill="white">‚Ä¢ React rendering</text>
                            <text x="100" y="65" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Business logic</text>
                            <text x="100" y="80" text-anchor="middle" font-size="10" fill="white">‚Ä¢ API calls</text>
                            <text x="100" y="95" text-anchor="middle" font-size="10" fill="white">‚Ä¢ State management</text>
                            <text x="100" y="110" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Event handling</text>
                        </g>
                        
                        <!-- UI Thread -->
                        <g transform="translate(250, 50)">
                            <rect width="200" height="120" fill="#4CAF50" rx="10"/>
                            <text x="100" y="25" text-anchor="middle" font-size="13" font-weight="bold" fill="white">UI Thread (Main)</text>
                            <text x="100" y="50" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Native UI rendering</text>
                            <text x="100" y="65" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Touch handling</text>
                            <text x="100" y="80" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Native animations</text>
                            <text x="100" y="95" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Layout calculations</text>
                            <text x="100" y="110" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Screen updates</text>
                        </g>
                        
                        <!-- Shadow Thread -->
                        <g transform="translate(470, 50)">
                            <rect width="200" height="120" fill="#9C27B0" rx="10"/>
                            <text x="100" y="25" text-anchor="middle" font-size="13" font-weight="bold" fill="white">Shadow Thread</text>
                            <text x="100" y="50" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Yoga layout engine</text>
                            <text x="100" y="65" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Flexbox calculations</text>
                            <text x="100" y="80" text-anchor="middle" font-size="10" fill="white">‚Ä¢ Diff computation</text>
                            <text x="100" y="95" text-anchor="middle" font-size="10" fill="white">‚Ä¢ View hierarchy</text>
                            <text x="100" y="110" text-anchor="middle" font-size="10" fill="white">‚Ä¢ (Background)</text>
                        </g>
                        
                        <!-- Communication arrows -->
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#666"/>
                            </marker>
                        </defs>
                        
                        <path d="M 230 110 L 250 110" stroke="#666" stroke-width="2" marker-end="url(#arrow)"/>
                        <path d="M 450 110 L 470 110" stroke="#666" stroke-width="2" marker-end="url(#arrow)"/>
                        
                        <!-- Impact boxes -->
                        <g transform="translate(30, 190)">
                            <rect width="200" height="100" fill="#e3f2fd" rx="8"/>
                            <text x="100" y="20" text-anchor="middle" font-size="11" font-weight="bold" fill="#1976D2">JS Thread Blocked?</text>
                            <text x="100" y="40" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Slow touch response</text>
                            <text x="100" y="55" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Laggy scrolling</text>
                            <text x="100" y="70" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Delayed updates</text>
                            <text x="100" y="85" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ JS FPS drops</text>
                        </g>
                        
                        <g transform="translate(250, 190)">
                            <rect width="200" height="100" fill="#e8f5e9" rx="8"/>
                            <text x="100" y="20" text-anchor="middle" font-size="11" font-weight="bold" fill="#388E3C">UI Thread Blocked?</text>
                            <text x="100" y="40" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Janky animations</text>
                            <text x="100" y="55" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Frozen UI</text>
                            <text x="100" y="70" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Dropped frames</text>
                            <text x="100" y="85" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ UI FPS drops</text>
                        </g>
                        
                        <g transform="translate(470, 190)">
                            <rect width="200" height="100" fill="#f3e5f5" rx="8"/>
                            <text x="100" y="20" text-anchor="middle" font-size="11" font-weight="bold" fill="#7B1FA2">Best Practice</text>
                            <text x="100" y="40" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Heavy work ‚Üí JS thread</text>
                            <text x="100" y="55" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Animations ‚Üí Native</text>
                            <text x="100" y="70" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Keep both under 16ms</text>
                            <text x="100" y="85" text-anchor="middle" font-size="10" fill="#333">‚Ä¢ Use Reanimated</text>
                        </g>
                    </svg>
                </div>

                <h3>Keeping Threads Responsive</h3>

                <pre><code>// Move heavy work off the JS thread

// ‚ùå Blocking the JS thread
function processLargeData(data) {
  // This blocks for 500ms
  return data.map(item => expensiveTransform(item));
}

// ‚úÖ Use InteractionManager for deferred work
import { InteractionManager } from 'react-native';

function processLargeDataDeferred(data, callback) {
  InteractionManager.runAfterInteractions(() => {
    const result = data.map(item => expensiveTransform(item));
    callback(result);
  });
}

// ‚úÖ Or batch processing
async function processInChunks(data, chunkSize = 100) {
  const results = [];
  
  for (let i = 0; i < data.length; i += chunkSize) {
    const chunk = data.slice(i, i + chunkSize);
    const processed = chunk.map(item => expensiveTransform(item));
    results.push(...processed);
    
    // Yield to allow other work
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  
  return results;
}

// ‚úÖ Use native driver for animations
Animated.timing(opacity, {
  toValue: 1,
  duration: 300,
  useNativeDriver: true, // Runs on UI thread!
}).start();</code></pre>
            </section>
            <!-- Measuring Performance -->
            <section id="measuring">
                <h2>Measuring Performance</h2>

                <p>You can't optimize what you don't measure. React Native provides several tools for performance monitoring.</p>

                <h3>React Native Performance Monitor</h3>

                <pre><code>// Enable the in-app performance monitor
// Shake device ‚Üí "Show Perf Monitor"
// Or via Dev Menu in Expo Go

// Shows:
// - JS thread FPS (target: 60)
// - UI thread FPS (target: 60)
// - RAM usage
// - Views count</code></pre>

                <h3>React DevTools Profiler</h3>

                <pre><code># Install React DevTools
npm install -g react-devtools

# Run in separate terminal
react-devtools

// In your app, connect via Dev Menu
// Use Profiler tab to:
// - Record rendering sessions
// - See component render times
// - Identify unnecessary re-renders
// - View "Why did this render?"</code></pre>

                <h3>Flipper for Deep Debugging</h3>

                <pre><code>// Flipper provides detailed performance insights

// 1. Install Flipper desktop app
// https://fbflipper.com/

// 2. For Expo development builds, add:
// npx expo install expo-dev-client
// npx expo install react-native-flipper

// Flipper features:
// - Network inspector (API call timing)
// - React DevTools integration
// - Layout inspector
// - Database viewer
// - Crash reporter
// - Performance plugin (CPU, memory)</code></pre>

                <h3>Custom Performance Tracking</h3>

                <pre><code>// Create a performance utility
// utils/performance.ts

class PerformanceTracker {
  private marks: Map&lt;string, number&gt; = new Map();

  mark(name: string) {
    this.marks.set(name, performance.now());
  }

  measure(name: string, startMark: string, endMark?: string) {
    const start = this.marks.get(startMark);
    const end = endMark ? this.marks.get(endMark) : performance.now();

    if (start === undefined) {
      console.warn(`Mark "${startMark}" not found`);
      return;
    }

    const duration = end! - start;
    
    if (__DEV__) {
      console.log(`‚è±Ô∏è ${name}: ${duration.toFixed(2)}ms`);
    }

    // Send to analytics in production
    if (!__DEV__) {
      analytics.track('performance', { name, duration });
    }

    return duration;
  }

  // Measure component mount time
  measureMount(componentName: string) {
    return {
      start: () => this.mark(`${componentName}_mount_start`),
      end: () => this.measure(
        `${componentName} mount`,
        `${componentName}_mount_start`
      ),
    };
  }
}

export const perf = new PerformanceTracker();

// Usage in components
function MyScreen() {
  const mountPerf = useRef(perf.measureMount('MyScreen'));

  useEffect(() => {
    mountPerf.current.start();
    
    return () => {
      mountPerf.current.end();
    };
  }, []);

  // ...
}</code></pre>

                <h3>Monitoring in Production</h3>

                <pre><code>// Use a monitoring service like:
// - Sentry Performance
// - Firebase Performance
// - New Relic

// Example with Sentry
import * as Sentry from '@sentry/react-native';

// Initialize
Sentry.init({
  dsn: 'YOUR_SENTRY_DSN',
  tracesSampleRate: 0.2, // 20% of transactions
  enableAutoPerformanceTracing: true,
});

// Custom transaction
const transaction = Sentry.startTransaction({
  name: 'checkout-flow',
});

// Add spans for each step
const fetchSpan = transaction.startChild({
  op: 'http',
  description: 'Fetch cart items',
});
await fetchCartItems();
fetchSpan.finish();

const renderSpan = transaction.startChild({
  op: 'render',
  description: 'Render checkout',
});
// Render completes
renderSpan.finish();

transaction.finish();</code></pre>
            </section>

            <!-- Optimization Mindset -->
            <section id="optimization-mindset">
                <h2>Optimization Mindset</h2>

                <p>Premature optimization is the root of all evil. Learn when and how to optimize effectively.</p>

                <h3>The Optimization Process</h3>

                <pre class="mermaid">
flowchart TD
    A[Identify Problem] --> B{Is it actually slow?}
    B -->|No| C[Don't optimize]
    B -->|Yes| D[Measure baseline]
    D --> E[Profile to find cause]
    E --> F[Hypothesize solution]
    F --> G[Implement fix]
    G --> H[Measure again]
    H --> I{Improved?}
    I -->|No| E
    I -->|Yes| J{Good enough?}
    J -->|No| E
    J -->|Yes| K[Document & ship]
    
    style A fill:#e3f2fd
    style K fill:#e8f5e9
</pre>

                <h3>Optimization Principles</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üß† Performance Principles</h4>
                    <ol style="color: white;">
                        <li><strong>Measure first:</strong> Never optimize without profiling</li>
                        <li><strong>Focus on bottlenecks:</strong> 20% of code causes 80% of slowdowns</li>
                        <li><strong>User perception matters:</strong> Perceived speed &gt; actual speed</li>
                        <li><strong>Avoid premature optimization:</strong> Write correct code first</li>
                        <li><strong>Document trade-offs:</strong> Optimization often reduces readability</li>
                        <li><strong>Test on real devices:</strong> Simulators lie about performance</li>
                        <li><strong>Test on low-end devices:</strong> Your phone is too fast</li>
                    </ol>
                </div>

                <h3>When to Optimize</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Situation</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Users complaining about slowness</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Measure, profile, optimize</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">FPS drops below 55</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Investigate immediately</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">App start time &gt; 3 seconds</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Optimize startup</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Memory growing over time</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Find and fix leaks</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">"I think it might be slow"</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Measure first, then decide</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Code looks inefficient</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Only optimize if measured slow</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Performance Checklist</h3>

                <pre><code>/**
 * Pre-Release Performance Checklist
 * 
 * ‚ñ° App starts in under 3 seconds on target devices
 * ‚ñ° List scrolling maintains 60 FPS
 * ‚ñ° No memory leaks detected over 30 min usage
 * ‚ñ° JS bundle size under budget
 * ‚ñ° Images optimized and cached
 * ‚ñ° No console.log in production
 * ‚ñ° Animations use native driver where possible
 * ‚ñ° FlatList used for lists (not ScrollView)
 * ‚ñ° Heavy computations memoized
 * ‚ñ° No unnecessary re-renders in profiler
 * ‚ñ° Network requests are parallel, not waterfall
 * ‚ñ° Offline functionality works smoothly
 * ‚ñ° Tested on low-end device
 */</code></pre>

                <h3>Common Optimization Strategies</h3>

                <pre><code>// Strategy 1: Perceived Performance
// Make it FEEL fast even if it isn't

// Show skeleton/placeholder immediately
function UserProfile({ userId }) {
  const { data, isLoading } = useUser(userId);

  if (isLoading) {
    return &lt;ProfileSkeleton /&gt;; // Instant feedback
  }

  return &lt;Profile data={data} /&gt;;
}


// Strategy 2: Optimistic Updates
// Update UI before server confirms

async function likePost(postId) {
  // Update UI immediately
  setLiked(true);
  setLikeCount(c => c + 1);

  try {
    await api.likePost(postId);
  } catch {
    // Revert on failure
    setLiked(false);
    setLikeCount(c => c - 1);
  }
}


// Strategy 3: Lazy Loading
// Load only what's needed

const HeavyChart = lazy(() => import('./HeavyChart'));

function Dashboard() {
  return (
    &lt;Suspense fallback={&lt;ChartSkeleton /&gt;}&gt;
      &lt;HeavyChart /&gt;
    &lt;/Suspense&gt;
  );
}


// Strategy 4: Caching
// Don't fetch what you already have

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 30 * 60 * 1000, // 30 minutes
    },
  },
});</code></pre>
            </section>

            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: Identify Performance Issues</h3>
                    <p>Review this code and identify all performance problems.</p>
                    
                    <pre><code>function UserList({ users, onSelect }) {
  const [search, setSearch] = useState('');

  const filteredUsers = users.filter(user =>
    user.name.toLowerCase().includes(search.toLowerCase())
  );

  return (
    &lt;ScrollView&gt;
      &lt;TextInput
        value={search}
        onChangeText={setSearch}
        style={{ padding: 10, margin: 10, borderWidth: 1 }}
      /&gt;
      {filteredUsers.map(user => (
        &lt;Pressable
          key={user.id}
          onPress={() => onSelect(user)}
          style={{ padding: 15, borderBottomWidth: 1 }}
        &gt;
          &lt;Image
            source={{ uri: user.avatar }}
            style={{ width: 50, height: 50 }}
          /&gt;
          &lt;Text&gt;{user.name}&lt;/Text&gt;
          &lt;Text&gt;{user.email}&lt;/Text&gt;
        &lt;/Pressable&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}</code></pre>

                    <details>
                        <summary>Show Issues</summary>
                        <ol>
                            <li><strong>ScrollView for list:</strong> Should use FlatList for virtualization</li>
                            <li><strong>Inline styles:</strong> Creates new objects every render</li>
                            <li><strong>Inline onPress handler:</strong> Creates new function every render</li>
                            <li><strong>No memoization of filter:</strong> Filters on every keystroke</li>
                            <li><strong>No image caching:</strong> Images reload on re-render</li>
                            <li><strong>No item memoization:</strong> All items re-render on any change</li>
                        </ol>
                    </details>

                    <details>
                        <summary>Show Optimized Solution</summary>
                        <pre><code>const styles = StyleSheet.create({
  input: { padding: 10, margin: 10, borderWidth: 1 },
  item: { padding: 15, borderBottomWidth: 1, flexDirection: 'row' },
  avatar: { width: 50, height: 50 },
});

const UserItem = memo(function UserItem({ user, onSelect }) {
  const handlePress = useCallback(() => {
    onSelect(user);
  }, [user, onSelect]);

  return (
    &lt;Pressable onPress={handlePress} style={styles.item}&gt;
      &lt;Image
        source={{ uri: user.avatar }}
        style={styles.avatar}
        // Use a caching library like expo-image
      /&gt;
      &lt;View&gt;
        &lt;Text&gt;{user.name}&lt;/Text&gt;
        &lt;Text&gt;{user.email}&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/Pressable&gt;
  );
});

function UserList({ users, onSelect }) {
  const [search, setSearch] = useState('');

  const filteredUsers = useMemo(() =>
    users.filter(user =>
      user.name.toLowerCase().includes(search.toLowerCase())
    ),
    [users, search]
  );

  const renderItem = useCallback(({ item }) => (
    &lt;UserItem user={item} onSelect={onSelect} /&gt;
  ), [onSelect]);

  const keyExtractor = useCallback((item) => item.id, []);

  return (
    &lt;View style={{ flex: 1 }}&gt;
      &lt;TextInput
        value={search}
        onChangeText={setSearch}
        style={styles.input}
      /&gt;
      &lt;FlatList
        data={filteredUsers}
        renderItem={renderItem}
        keyExtractor={keyExtractor}
        initialNumToRender={10}
        maxToRenderPerBatch={10}
        windowSize={5}
      /&gt;
    &lt;/View&gt;
  );
}</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Create a Performance Monitor Hook</h3>
                    <p>Build a custom hook that tracks component render count and mount time.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Track number of renders</li>
                        <li>Track mount duration</li>
                        <li>Log in development only</li>
                        <li>Return metrics for display</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>// hooks/usePerformanceMonitor.ts
import { useEffect, useRef, useState } from 'react';

interface PerformanceMetrics {
  renderCount: number;
  mountTime: number | null;
  lastRenderTime: number | null;
}

export function usePerformanceMonitor(componentName: string) {
  const renderCount = useRef(0);
  const mountStart = useRef&lt;number | null&gt;(null);
  const lastRenderStart = useRef&lt;number&gt;(performance.now());
  
  const [metrics, setMetrics] = useState&lt;PerformanceMetrics&gt;({
    renderCount: 0,
    mountTime: null,
    lastRenderTime: null,
  });

  // Track mount time
  useEffect(() => {
    if (mountStart.current !== null) {
      const mountTime = performance.now() - mountStart.current;
      
      if (__DEV__) {
        console.log(`üìä ${componentName} mounted in ${mountTime.toFixed(2)}ms`);
      }
      
      setMetrics(m => ({ ...m, mountTime }));
    }
  }, [componentName]);

  // Track renders
  useEffect(() => {
    const renderTime = performance.now() - lastRenderStart.current;
    
    if (__DEV__ && renderCount.current > 0) {
      console.log(
        `üîÑ ${componentName} render #${renderCount.current} took ${renderTime.toFixed(2)}ms`
      );
    }
    
    setMetrics(m => ({
      ...m,
      renderCount: renderCount.current,
      lastRenderTime: renderTime,
    }));
  });

  // Called at start of render
  if (renderCount.current === 0) {
    mountStart.current = performance.now();
  }
  renderCount.current += 1;
  lastRenderStart.current = performance.now();

  return metrics;
}

// Usage
function MyComponent() {
  const perfMetrics = usePerformanceMonitor('MyComponent');

  // Optional: Display metrics in dev
  if (__DEV__) {
    console.log('Renders:', perfMetrics.renderCount);
  }

  return (
    &lt;View&gt;
      {/* Component content */}
      {__DEV__ && (
        &lt;Text style={{ fontSize: 10, color: '#999' }}&gt;
          Renders: {perfMetrics.renderCount}
        &lt;/Text&gt;
      )}
    &lt;/View&gt;
  );
}</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Optimize App Startup</h3>
                    <p>Given this app entry point, suggest optimizations to improve startup time.</p>
                    
                    <pre><code>// App.tsx
import { allRoutes } from './routes';
import { AnalyticsProvider } from './analytics';
import { ThemeProvider } from './theme';
import { AuthProvider } from './auth';
import { NotificationHandler } from './notifications';
import { DeepLinkHandler } from './deeplinks';
import { CrashReporter } from './crashReporting';
import { FeatureFlagsProvider } from './featureFlags';
import { LocalizationProvider } from './i18n';
import HeavyChartLibrary from 'heavy-chart-library';

export default function App() {
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    async function initialize() {
      await CrashReporter.init();
      await AnalyticsProvider.init();
      await FeatureFlagsProvider.fetch();
      await LocalizationProvider.loadTranslations();
      await NotificationHandler.requestPermissions();
      setIsReady(true);
    }
    initialize();
  }, []);

  if (!isReady) {
    return &lt;SplashScreen /&gt;;
  }

  return (
    &lt;AllProviders&gt;
      &lt;RootNavigator /&gt;
    &lt;/AllProviders&gt;
  );
}</code></pre>

                    <details>
                        <summary>Show Optimized Solution</summary>
                        <pre><code>// App.tsx - Optimized
import { useCallback, useState, useEffect, lazy, Suspense } from 'react';

// Lazy load heavy libraries
const HeavyChartLibrary = lazy(() => import('heavy-chart-library'));

// Split providers into critical and non-critical
import { ThemeProvider } from './theme'; // Critical - affects first render
import { AuthProvider } from './auth';   // Critical - affects routing

// Defer non-critical
const AnalyticsProvider = lazy(() => import('./analytics'));
const FeatureFlagsProvider = lazy(() => import('./featureFlags'));

export default function App() {
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    async function initialize() {
      // Run critical init in parallel
      await Promise.all([
        CrashReporter.init(), // Fast, critical
        LocalizationProvider.loadTranslations(), // Needed for UI
      ]);
      
      setIsReady(true);
      
      // Defer non-critical initialization
      InteractionManager.runAfterInteractions(async () => {
        // These can happen after app is interactive
        AnalyticsProvider.init();
        FeatureFlagsProvider.fetch();
        
        // Request permissions later, not blocking startup
        setTimeout(() => {
          NotificationHandler.requestPermissions();
        }, 3000);
      });
    }
    
    initialize();
  }, []);

  if (!isReady) {
    return &lt;SplashScreen /&gt;;
  }

  return (
    &lt;ThemeProvider&gt;
      &lt;AuthProvider&gt;
        &lt;Suspense fallback={null}&gt;
          &lt;AnalyticsProvider&gt;
            &lt;RootNavigator /&gt;
          &lt;/AnalyticsProvider&gt;
        &lt;/Suspense&gt;
      &lt;/AuthProvider&gt;
    &lt;/ThemeProvider&gt;
  );
}

// Key optimizations:
// 1. Parallel initialization with Promise.all
// 2. Defer non-critical work with InteractionManager
// 3. Lazy load heavy libraries
// 4. Request permissions after app is usable
// 5. Reduce provider nesting
// 6. Only block on truly critical initialization</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>Performance optimization starts with understanding React Native's architecture and knowing what to measure. With the right mindset and tools, you can build apps that feel instant and responsive.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>60 FPS target:</strong> 16ms budget per frame for both JS and UI threads</li>
                        <li><strong>Architecture matters:</strong> New Architecture (JSI/Fabric) eliminates bridge overhead</li>
                        <li><strong>Key metrics:</strong> FPS, TTI, bundle size, memory usage</li>
                        <li><strong>Common bottlenecks:</strong> Re-renders, inline functions, large lists, unoptimized images</li>
                        <li><strong>Two threads:</strong> JS thread for logic, UI thread for rendering</li>
                        <li><strong>Measure first:</strong> Use Profiler, Flipper, and custom tracking</li>
                        <li><strong>Optimize wisely:</strong> Focus on user-perceived performance</li>
                        <li><strong>Test on real devices:</strong> Especially low-end devices</li>
                    </ul>
                </div>

                <p>In the next lesson, we'll dive deep into rendering optimization‚Äîlearning how to prevent unnecessary re-renders and make your components lightning fast.</p>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m09_l05_e2e_testing.html" class="prev-link">‚Üê Previous: E2E Testing</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m10_l02_rendering_optimization.html" class="next-link">Next: Rendering Optimization ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
