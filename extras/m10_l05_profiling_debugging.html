<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master profiling and debugging techniques for React Native performance optimization">
    <meta name="author" content="React Native & Expo Course">
    <title>Profiling and Debugging | Module 10: Performance Optimization | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m10_l01_app_performance.html">Module 10</a> &gt;
            <span>Lesson 10.5</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 10: Performance Optimization</p>
                <h1>Profiling and Debugging</h1>
                <p class="lesson-subtitle">Systematic approaches to finding and fixing performance issues</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Use React DevTools Profiler effectively</li>
                    <li>Profile with Flipper and native tools</li>
                    <li>Analyze JavaScript bundle size</li>
                    <li>Debug performance on real devices</li>
                    <li>Implement systematic performance audits</li>
                    <li>Set up performance monitoring in production</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#debugging-workflow">Performance Debugging Workflow</a></li>
                        <li><a href="#react-devtools">React DevTools Profiler</a></li>
                        <li><a href="#flipper">Flipper</a></li>
                        <li><a href="#native-profiling">Native Profiling Tools</a></li>
                        <li><a href="#bundle-analysis">Bundle Analysis</a></li>
                        <li><a href="#production-monitoring">Production Monitoring</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- Performance Debugging Workflow -->
            <section id="debugging-workflow">
                <h2>Performance Debugging Workflow</h2>

                <p>Effective performance debugging follows a systematic approach. Don't guess‚Äîmeasure, analyze, fix, and verify.</p>

                <h3>The Performance Debugging Process</h3>

                <pre class="mermaid">
flowchart TD
    A[Identify Symptom] --> B[Reproduce Consistently]
    B --> C[Measure Baseline]
    C --> D[Profile to Find Cause]
    D --> E[Form Hypothesis]
    E --> F[Implement Fix]
    F --> G[Measure Again]
    G --> H{Improved?}
    H -->|No| D
    H -->|Yes| I{Good Enough?}
    I -->|No| D
    I -->|Yes| J[Document & Deploy]
    
    style A fill:#f44336,color:#fff
    style J fill:#4CAF50,color:#fff
</pre>

                <h3>Common Performance Symptoms</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Symptom</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Likely Cause</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Tool to Use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Janky scrolling</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Heavy renders, large images</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">React Profiler, Perf Monitor</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Slow app start</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Large bundle, sync init</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Bundle analyzer, Hermes</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Frozen UI</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Blocking JS thread</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Perf Monitor, Systrace</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Memory warnings</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Leaks, large images</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Flipper, Xcode Instruments</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Laggy animations</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">JS-driven animations</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Perf Monitor (UI FPS)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Slow screen transitions</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Heavy initial render</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">React Profiler</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Setting Up for Profiling</h3>

                <pre><code>// 1. Use a production-like build for accurate profiling
// Development mode adds overhead

// For Expo:
npx expo start --no-dev

// 2. Test on real devices, not simulators
// Simulators use your computer's CPU/RAM

// 3. Use Hermes for accurate JS profiling
// app.json
{
  "expo": {
    "jsEngine": "hermes"
  }
}

// 4. Enable profiling in development builds
// For React Profiler to work in production builds:
// Add to metro.config.js
module.exports = {
  transformer: {
    minifierConfig: {
      keep_fnames: true, // Preserve function names
    },
  },
};</code></pre>
            </section>

            <!-- React DevTools Profiler -->
            <section id="react-devtools">
                <h2>React DevTools Profiler</h2>

                <p>The React Profiler is your primary tool for understanding component render performance.</p>

                <h3>Setting Up React DevTools</h3>

                <pre><code># Install globally
npm install -g react-devtools

# Run in separate terminal
react-devtools

# Connect your app
# - Shake device ‚Üí Debug
# - Or: Expo Dev Menu ‚Üí Debug Remote JS</code></pre>

                <h3>Using the Profiler</h3>

                <!-- SVG: Profiler Interface -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 350" style="max-width: 700px; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="350" fill="#1e1e1e"/>
                        
                        <!-- Title bar -->
                        <rect width="700" height="30" fill="#333"/>
                        <text x="20" y="20" font-size="12" fill="#fff">React DevTools - Profiler</text>
                        <circle cx="660" cy="15" r="6" fill="#4CAF50"/>
                        <circle cx="640" cy="15" r="6" fill="#FFC107"/>
                        <circle cx="620" cy="15" r="6" fill="#f44336"/>
                        
                        <!-- Toolbar -->
                        <rect y="30" width="700" height="35" fill="#2d2d2d"/>
                        <rect x="10" y="40" width="60" height="18" fill="#61dafb" rx="3"/>
                        <text x="40" y="53" text-anchor="middle" font-size="10" fill="#000">‚è∫ Record</text>
                        
                        <rect x="80" y="40" width="50" height="18" fill="#444" rx="3"/>
                        <text x="105" y="53" text-anchor="middle" font-size="10" fill="#fff">Reload</text>
                        
                        <text x="200" y="53" font-size="10" fill="#888">Commit 3 of 15</text>
                        
                        <!-- Flame graph -->
                        <rect x="10" y="75" width="480" height="200" fill="#252525" rx="5"/>
                        <text x="20" y="95" font-size="11" fill="#888">Flamegraph</text>
                        
                        <!-- Components -->
                        <rect x="20" y="110" width="460" height="25" fill="#8b5cf6" rx="2"/>
                        <text x="30" y="127" font-size="10" fill="#fff">App (12.3ms)</text>
                        
                        <rect x="30" y="140" width="200" height="25" fill="#3b82f6" rx="2"/>
                        <text x="40" y="157" font-size="10" fill="#fff">Header (0.8ms)</text>
                        
                        <rect x="240" y="140" width="230" height="25" fill="#f59e0b" rx="2"/>
                        <text x="250" y="157" font-size="10" fill="#fff">ProductList (8.2ms) ‚ö†Ô∏è</text>
                        
                        <rect x="250" y="170" width="100" height="20" fill="#ef4444" rx="2"/>
                        <text x="260" y="184" font-size="9" fill="#fff">ProductCard</text>
                        
                        <rect x="360" y="170" width="100" height="20" fill="#ef4444" rx="2"/>
                        <text x="370" y="184" font-size="9" fill="#fff">ProductCard</text>
                        
                        <rect x="30" y="200" width="440" height="25" fill="#22c55e" rx="2"/>
                        <text x="40" y="217" font-size="10" fill="#fff">Footer (0.3ms)</text>
                        
                        <!-- Sidebar -->
                        <rect x="500" y="75" width="190" height="265" fill="#252525" rx="5"/>
                        <text x="510" y="95" font-size="11" fill="#888">Selected: ProductList</text>
                        
                        <text x="510" y="120" font-size="10" fill="#fff">Render time: 8.2ms</text>
                        <text x="510" y="140" font-size="10" fill="#fff">Re-rendered: 15 times</text>
                        <text x="510" y="165" font-size="10" fill="#888">Why did this render?</text>
                        <text x="520" y="185" font-size="9" fill="#f59e0b">‚Ä¢ Props changed: items</text>
                        <text x="520" y="200" font-size="9" fill="#f59e0b">‚Ä¢ Parent re-rendered</text>
                        
                        <rect x="510" y="220" width="170" height="30" fill="#333" rx="3"/>
                        <text x="595" y="240" text-anchor="middle" font-size="10" fill="#61dafb">View source ‚Üí</text>
                        
                        <!-- Legend -->
                        <rect x="10" y="285" width="480" height="55" fill="#252525" rx="5"/>
                        <text x="20" y="305" font-size="10" fill="#888">Render time:</text>
                        <rect x="100" y="295" width="40" height="15" fill="#22c55e" rx="2"/>
                        <text x="145" y="306" font-size="9" fill="#888">&lt;1ms</text>
                        <rect x="180" y="295" width="40" height="15" fill="#3b82f6" rx="2"/>
                        <text x="225" y="306" font-size="9" fill="#888">1-5ms</text>
                        <rect x="260" y="295" width="40" height="15" fill="#f59e0b" rx="2"/>
                        <text x="305" y="306" font-size="9" fill="#888">5-10ms</text>
                        <rect x="350" y="295" width="40" height="15" fill="#ef4444" rx="2"/>
                        <text x="395" y="306" font-size="9" fill="#888">&gt;10ms</text>
                        
                        <text x="20" y="330" font-size="9" fill="#666">Gray = did not render | Wider bars = longer render time</text>
                    </svg>
                </div>

                <h3>Interpreting Profiler Results</h3>

                <pre><code>// What to look for in the Profiler:

// 1. Commit frequency
// - Many commits = many re-renders
// - Look for commits that shouldn't happen

// 2. Render times
// - Green (&lt;1ms): Good
// - Blue (1-5ms): OK
// - Yellow (5-10ms): Worth investigating
// - Red (&gt;10ms): Needs optimization

// 3. "Why did this render?"
// - Props changed: Check if prop is actually different
// - Parent re-rendered: Consider memo()
// - State changed: Expected, but check frequency

// 4. Wasted renders
// - Components that render but produce same output
// - Gray in ranked chart = didn't render (good!)

// 5. Render cascades
// - One component triggers many children
// - Look for opportunities to memo or restructure</code></pre>

                <h3>Profiler API for Programmatic Tracking</h3>

                <pre><code>import { Profiler } from 'react';

function onRenderCallback(
  id: string,                // Component name
  phase: 'mount' | 'update', // Mount or re-render
  actualDuration: number,    // Time spent rendering
  baseDuration: number,      // Estimated time without memoization
  startTime: number,         // When React started rendering
  commitTime: number,        // When React committed
) {
  // Log slow renders
  if (actualDuration > 16) {
    console.warn(`Slow render: ${id} took ${actualDuration.toFixed(2)}ms`);
  }

  // Send to analytics
  analytics.track('render', {
    component: id,
    phase,
    duration: actualDuration,
  });
}

// Wrap components to profile
function App() {
  return (
    &lt;Profiler id="App" onRender={onRenderCallback}&gt;
      &lt;Profiler id="ProductList" onRender={onRenderCallback}&gt;
        &lt;ProductList /&gt;
      &lt;/Profiler&gt;
    &lt;/Profiler&gt;
  );
}</code></pre>

                <h3>Highlight Updates</h3>

                <pre><code>// Enable "Highlight updates when components render"
// in React DevTools settings

// Visual indicators:
// - Blue border: Fast render
// - Green border: Medium render
// - Yellow/Red border: Slow render

// This helps identify:
// - Components re-rendering too often
// - Cascade effects
// - Animations triggering renders</code></pre>
            </section>

            <!-- Flipper -->
            <section id="flipper">
                <h2>Flipper</h2>

                <p>Flipper is Meta's extensible mobile debugging platform with powerful React Native plugins.</p>

                <h3>Setting Up Flipper</h3>

                <pre><code># Download Flipper from https://fbflipper.com/

# For Expo development builds:
npx expo install expo-dev-client react-native-flipper

# Flipper auto-connects when your app runs</code></pre>

                <h3>Key Flipper Plugins</h3>

                <div class="card">
                    <h4>üîß Essential Flipper Plugins</h4>
                    
                    <p><strong>React DevTools</strong> - Same as standalone, integrated in Flipper</p>
                    
                    <p><strong>Network</strong> - Inspect all HTTP/HTTPS requests:</p>
                    <ul>
                        <li>Request/response headers and bodies</li>
                        <li>Timing breakdown</li>
                        <li>Mock responses for testing</li>
                    </ul>
                    
                    <p><strong>Databases</strong> - View SQLite/AsyncStorage:</p>
                    <ul>
                        <li>Browse tables and data</li>
                        <li>Execute queries</li>
                        <li>Edit data for testing</li>
                    </ul>
                    
                    <p><strong>Layout</strong> - Inspect view hierarchy:</p>
                    <ul>
                        <li>View tree with properties</li>
                        <li>Highlight elements</li>
                        <li>Edit styles live</li>
                    </ul>
                    
                    <p><strong>Crash Reporter</strong> - Debug crashes:</p>
                    <ul>
                        <li>Stack traces</li>
                        <li>Device info</li>
                        <li>Breadcrumbs</li>
                    </ul>
                </div>

                <h3>Performance Plugin</h3>

                <pre><code>// Flipper's Performance plugin provides:

// 1. CPU Usage
// - Track CPU over time
// - Identify spikes during actions

// 2. Memory Usage
// - Heap size tracking
// - Detect memory leaks
// - Compare snapshots

// 3. FPS Monitoring
// - Frame rate graph
// - Dropped frame detection
// - JS vs UI thread breakdown

// Usage:
// 1. Open Flipper ‚Üí Performance plugin
// 2. Start recording
// 3. Perform the action to profile
// 4. Stop recording
// 5. Analyze timeline</code></pre>

                <h3>Custom Flipper Plugin</h3>

                <pre><code>// Create custom plugins for app-specific debugging
// client plugin (in your app)
import { addPlugin } from 'react-native-flipper';

if (__DEV__) {
  addPlugin({
    getId() {
      return 'MyAppState';
    },
    onConnect(connection) {
      // Send state updates to Flipper
      const unsubscribe = store.subscribe(() => {
        connection.send('stateUpdate', store.getState());
      });

      connection.receive('getState', (data, responder) => {
        responder.success(store.getState());
      });

      return () => unsubscribe();
    },
    onDisconnect() {},
  });
}</code></pre>
            </section>

            <!-- Native Profiling Tools -->
            <section id="native-profiling">
                <h2>Native Profiling Tools</h2>

                <p>For deep native performance issues, use platform-specific profiling tools.</p>

                <h3>iOS: Xcode Instruments</h3>

                <pre><code>// Xcode Instruments provides detailed profiling

// Time Profiler
// - CPU usage by function
// - Call tree analysis
// - Find hotspots

// Allocations
// - Memory allocation tracking
// - Find leaks and zombies
// - Heap snapshots

// Core Animation
// - GPU rendering issues
// - Offscreen rendering
// - Blending issues

// To profile:
// 1. Build release version in Xcode
// 2. Product ‚Üí Profile (‚åòI)
// 3. Choose instrument
// 4. Record while using app
// 5. Analyze results</code></pre>

                <h3>Android: Android Studio Profiler</h3>

                <pre><code>// Android Studio Profiler

// CPU Profiler
// - Method tracing
// - System trace
// - Sample vs instrumented

// Memory Profiler
// - Real-time heap
// - Allocation tracking
// - Heap dumps
// - Leak detection

// Network Profiler
// - Request timeline
// - Payload inspection

// Energy Profiler
// - Battery usage
// - Wake locks
// - CPU/Network impact

// To profile:
// 1. Run app in Android Studio
// 2. View ‚Üí Tool Windows ‚Üí Profiler
// 3. Select CPU/Memory/Network
// 4. Record session
// 5. Analyze</code></pre>

                <h3>Systrace for Frame Analysis</h3>

                <pre><code>// Systrace captures detailed timing info

// Enable in Dev Menu:
// Settings ‚Üí Start Systrace

// Or programmatically:
import { Systrace } from 'react-native';

Systrace.beginEvent('myExpensiveOperation');
// ... do work
Systrace.endEvent();

// Analyze trace:
// 1. Capture trace file
// 2. Open in chrome://tracing
// 3. Look for:
//    - Long frames (>16ms)
//    - JS thread blocking
//    - Bridge congestion</code></pre>

                <h3>Hermes Profiler</h3>

                <pre><code>// Hermes (React Native's JS engine) has built-in profiling

// Enable sampling profiler in Dev Menu:
// Settings ‚Üí Start/Stop Sampling Profiler

// Or programmatically:
if (__DEV__) {
  const Hermes = global.HermesInternal;
  
  // Start profiling
  Hermes?.enableSamplingProfiler?.();
  
  // ... run code to profile
  
  // Stop and get profile
  const profile = Hermes?.disableSamplingProfiler?.();
  
  // Save to file or send to analytics
}

// Analyze with:
// - Chrome DevTools (import profile)
// - hermes-profile-transformer
// - Flipper Hermes plugin</code></pre>
            </section>

            <!-- Bundle Analysis -->
            <section id="bundle-analysis">
                <h2>Bundle Analysis</h2>

                <p>Large JavaScript bundles slow down app startup. Analyze and optimize your bundle size.</p>

                <h3>Analyzing Bundle Size</h3>

                <pre><code># Generate bundle stats
npx react-native bundle \
  --platform ios \
  --dev false \
  --entry-file index.js \
  --bundle-output bundle.js \
  --sourcemap-output bundle.js.map

# Analyze with source-map-explorer
npx source-map-explorer bundle.js bundle.js.map

# Or use bundle-visualizer for Expo
npx expo export --dump-sourcemap
npx source-map-explorer dist/bundles/ios-*.js</code></pre>

                <h3>What to Look For</h3>

                <!-- SVG: Bundle Analysis -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 600 300" style="max-width: 600px; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="600" height="300" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="300" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Bundle Composition (Typical App)</text>
                        
                        <!-- Treemap visualization -->
                        <rect x="20" y="45" width="280" height="120" fill="#2196F3" rx="3"/>
                        <text x="160" y="100" text-anchor="middle" font-size="14" fill="white" font-weight="bold">node_modules</text>
                        <text x="160" y="120" text-anchor="middle" font-size="11" fill="white">~60-70%</text>
                        
                        <rect x="310" y="45" width="140" height="120" fill="#4CAF50" rx="3"/>
                        <text x="380" y="100" text-anchor="middle" font-size="12" fill="white" font-weight="bold">Your Code</text>
                        <text x="380" y="118" text-anchor="middle" font-size="10" fill="white">~20-30%</text>
                        
                        <rect x="460" y="45" width="120" height="60" fill="#FF9800" rx="3"/>
                        <text x="520" y="75" text-anchor="middle" font-size="10" fill="white">Assets</text>
                        <text x="520" y="90" text-anchor="middle" font-size="9" fill="white">~5%</text>
                        
                        <rect x="460" y="110" width="120" height="55" fill="#9C27B0" rx="3"/>
                        <text x="520" y="138" text-anchor="middle" font-size="10" fill="white">Polyfills</text>
                        <text x="520" y="152" text-anchor="middle" font-size="9" fill="white">~5%</text>
                        
                        <!-- Common culprits -->
                        <rect x="20" y="175" width="560" height="110" fill="#fff" stroke="#ddd" rx="5"/>
                        <text x="300" y="195" text-anchor="middle" font-size="12" font-weight="bold" fill="#333">Common Bundle Bloaters</text>
                        
                        <text x="40" y="220" font-size="10" fill="#666">‚Ä¢ moment.js (300KB) ‚Üí Use date-fns or dayjs (20KB)</text>
                        <text x="40" y="238" font-size="10" fill="#666">‚Ä¢ lodash (70KB) ‚Üí Import specific functions or use native</text>
                        <text x="40" y="256" font-size="10" fill="#666">‚Ä¢ Large icon libraries ‚Üí Import only used icons</text>
                        <text x="40" y="274" font-size="10" fill="#666">‚Ä¢ Unused exports ‚Üí Enable tree shaking</text>
                    </svg>
                </div>

                <h3>Reducing Bundle Size</h3>

                <pre><code>// 1. Import specific functions, not entire libraries
// ‚ùå Bad
import _ from 'lodash';
_.debounce(fn, 300);

// ‚úÖ Good
import debounce from 'lodash/debounce';
debounce(fn, 300);

// 2. Use lighter alternatives
// moment.js ‚Üí date-fns or dayjs
// lodash ‚Üí native methods or lodash-es
// axios ‚Üí ky or native fetch

// 3. Lazy load heavy features
const HeavyEditor = lazy(() => import('./HeavyEditor'));

// 4. Remove unused code
// Check for dead imports
// Remove development-only code in production

// 5. Optimize images in bundle
// Use WebP format
// Resize to needed dimensions
// Consider loading from CDN instead</code></pre>

                <h3>Monitoring Bundle Size</h3>

                <pre><code>// Add bundle size check to CI
// package.json
{
  "scripts": {
    "bundle:analyze": "npx react-native bundle --platform ios --dev false --entry-file index.js --bundle-output /tmp/bundle.js && stat -f%z /tmp/bundle.js",
    "bundle:check": "node scripts/check-bundle-size.js"
  }
}

// scripts/check-bundle-size.js
const { execSync } = require('child_process');
const MAX_BUNDLE_SIZE = 2 * 1024 * 1024; // 2MB

const output = execSync('npm run bundle:analyze', { encoding: 'utf8' });
const size = parseInt(output.trim());

if (size > MAX_BUNDLE_SIZE) {
  console.error(`Bundle size ${size} exceeds limit ${MAX_BUNDLE_SIZE}`);
  process.exit(1);
}

console.log(`Bundle size OK: ${(size / 1024 / 1024).toFixed(2)}MB`);</code></pre>
            </section>
            <!-- Production Monitoring -->
            <section id="production-monitoring">
                <h2>Production Monitoring</h2>

                <p>Performance issues in production need real user data. Set up monitoring to catch problems before users complain.</p>

                <h3>Key Metrics to Track</h3>

                <pre class="mermaid">
mindmap
  root((Production<br/>Metrics))
    User Experience
      App start time
      Screen load time
      Interaction latency
      Frame rate
    Technical
      JS errors
      Native crashes
      Memory usage
      Network failures
    Business Impact
      Session duration
      Conversion rates
      User retention
      App ratings
</pre>

                <h3>Setting Up Sentry</h3>

                <pre><code>// Install Sentry
npx expo install @sentry/react-native

// Initialize in app entry
import * as Sentry from '@sentry/react-native';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN',
  
  // Performance monitoring
  tracesSampleRate: 0.2, // 20% of transactions
  enableAutoPerformanceTracing: true,
  
  // Release tracking
  release: `${appName}@${version}`,
  dist: buildNumber,
  
  // Environment
  environment: __DEV__ ? 'development' : 'production',
  
  // Filtering
  beforeSend(event) {
    // Don't send events in development
    if (__DEV__) return null;
    return event;
  },
});

// Wrap app with Sentry
export default Sentry.wrap(App);</code></pre>

                <h3>Custom Performance Tracking</h3>

                <pre><code>import * as Sentry from '@sentry/react-native';

// Track screen load time
function useScreenPerformance(screenName: string) {
  useEffect(() => {
    const transaction = Sentry.startTransaction({
      name: screenName,
      op: 'navigation',
    });

    Sentry.getCurrentHub().configureScope(scope => {
      scope.setSpan(transaction);
    });

    // Mark when screen is interactive
    const timeToInteractive = transaction.startChild({
      op: 'tti',
      description: 'Time to Interactive',
    });

    // Call when data is loaded and screen is ready
    const markInteractive = () => {
      timeToInteractive.finish();
      transaction.finish();
    };

    return () => {
      if (!transaction.endTimestamp) {
        transaction.finish();
      }
    };
  }, [screenName]);
}

// Track specific operations
async function trackOperation&lt;T&gt;(
  name: string,
  operation: () => Promise&lt;T&gt;
): Promise&lt;T&gt; {
  const transaction = Sentry.getCurrentHub().getScope()?.getTransaction();
  
  const span = transaction?.startChild({
    op: 'function',
    description: name,
  });

  try {
    const result = await operation();
    span?.setStatus('ok');
    return result;
  } catch (error) {
    span?.setStatus('error');
    throw error;
  } finally {
    span?.finish();
  }
}

// Usage
const data = await trackOperation('fetchUserData', () => api.getUser(id));</code></pre>

                <h3>Firebase Performance Monitoring</h3>

                <pre><code>// Alternative: Firebase Performance
import perf from '@react-native-firebase/perf';

// Automatic traces for:
// - App start time
// - HTTP/S network requests
// - Screen rendering

// Custom traces
async function loadProducts() {
  const trace = await perf().startTrace('load_products');
  
  try {
    const products = await api.getProducts();
    
    // Add metrics
    trace.putMetric('product_count', products.length);
    trace.putAttribute('category', 'all');
    
    return products;
  } finally {
    await trace.stop();
  }
}

// HTTP metrics (automatic with config)
// firebase.json
{
  "react-native": {
    "perf_auto_collection_enabled": true
  }
}</code></pre>

                <h3>Custom Analytics Dashboard</h3>

                <pre><code>// Track and aggregate performance metrics
class PerformanceAnalytics {
  private static metrics: Map&lt;string, number[]&gt; = new Map();

  static track(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);

    // Periodically send to backend
    this.flushIfNeeded();
  }

  static getStats(name: string) {
    const values = this.metrics.get(name) || [];
    if (values.length === 0) return null;

    const sorted = [...values].sort((a, b) => a - b);
    return {
      count: values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    };
  }

  private static async flushIfNeeded() {
    // Send metrics every 100 samples or 60 seconds
    // Implementation depends on your backend
  }
}

// Usage
const startTime = performance.now();
await loadData();
PerformanceAnalytics.track('data_load_time', performance.now() - startTime);

// Later, view stats
console.log(PerformanceAnalytics.getStats('data_load_time'));
// { count: 150, min: 45, max: 2300, avg: 234, p50: 180, p95: 890, p99: 1500 }</code></pre>

                <h3>Alerting on Performance Regressions</h3>

                <pre><code>// Set up alerts in your monitoring platform

// Sentry Performance Alerts:
// 1. Go to Alerts ‚Üí Create Alert
// 2. Choose "Performance" metric
// 3. Set conditions:
//    - p95 latency > 3 seconds
//    - Error rate > 5%
//    - Throughput drops > 50%

// Custom alerting logic
class PerformanceAlerts {
  static thresholds = {
    screenLoadTime: { p95: 3000, p99: 5000 },
    apiLatency: { p95: 1000, p99: 2000 },
    errorRate: { max: 0.05 },
  };

  static check(metric: string, stats: any) {
    const threshold = this.thresholds[metric];
    if (!threshold) return;

    const violations = [];

    if (stats.p95 > threshold.p95) {
      violations.push(`${metric} p95 (${stats.p95}ms) exceeds ${threshold.p95}ms`);
    }

    if (stats.p99 > threshold.p99) {
      violations.push(`${metric} p99 (${stats.p99}ms) exceeds ${threshold.p99}ms`);
    }

    if (violations.length > 0) {
      this.sendAlert(violations);
    }
  }

  static sendAlert(violations: string[]) {
    // Send to Slack, PagerDuty, email, etc.
    console.error('Performance Alert:', violations);
  }
}</code></pre>
            </section>

            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: Profile and Fix a Slow List</h3>
                    <p>Use the React Profiler to identify why this list is slow, then fix it.</p>
                    
                    <pre><code>function SlowProductList({ products, onSelect, filters }) {
  const [sortOrder, setSortOrder] = useState('name');

  const sortedProducts = products
    .filter(p => filters.categories.includes(p.category))
    .filter(p => p.price >= filters.minPrice && p.price <= filters.maxPrice)
    .sort((a, b) => {
      if (sortOrder === 'name') return a.name.localeCompare(b.name);
      if (sortOrder === 'price') return a.price - b.price;
      return 0;
    });

  return (
    &lt;ScrollView&gt;
      &lt;SortPicker value={sortOrder} onChange={setSortOrder} /&gt;
      {sortedProducts.map(product => (
        &lt;View key={product.id} style={{ padding: 16, borderBottomWidth: 1 }}&gt;
          &lt;Image source={{ uri: product.image }} style={{ width: 100, height: 100 }} /&gt;
          &lt;Text style={{ fontSize: 18, fontWeight: 'bold' }}&gt;{product.name}&lt;/Text&gt;
          &lt;Text style={{ color: 'green' }}&gt;${product.price}&lt;/Text&gt;
          &lt;Pressable onPress={() => onSelect(product)}&gt;
            &lt;Text style={{ color: 'blue' }}&gt;View Details&lt;/Text&gt;
          &lt;/Pressable&gt;
        &lt;/View&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}</code></pre>

                    <details>
                        <summary>Show Profiling Steps</summary>
                        <pre><code>// Profiling Steps:
// 1. Open React DevTools Profiler
// 2. Start recording
// 3. Scroll the list / change sort order
// 4. Stop recording
// 5. Analyze flame graph

// What you'll find:
// - ScrollView renders ALL items (no virtualization)
// - Every scroll triggers filter/sort
// - Inline styles create new objects
// - Inline onPress creates new functions
// - Images reload on every render</code></pre>
                    </details>

                    <details>
                        <summary>Show Optimized Solution</summary>
                        <pre><code>import { memo, useMemo, useCallback } from 'react';
import { FlatList, StyleSheet } from 'react-native';
import { Image } from 'expo-image';

const styles = StyleSheet.create({
  item: { padding: 16, borderBottomWidth: 1, borderBottomColor: '#eee' },
  image: { width: 100, height: 100 },
  name: { fontSize: 18, fontWeight: 'bold' },
  price: { color: 'green' },
  link: { color: 'blue' },
});

// Memoized item component
const ProductItem = memo(function ProductItem({ product, onSelect }) {
  const handlePress = useCallback(() => {
    onSelect(product);
  }, [product, onSelect]);

  return (
    &lt;View style={styles.item}&gt;
      &lt;Image
        source={{ uri: product.image }}
        style={styles.image}
        contentFit="cover"
        recyclingKey={product.id}
      /&gt;
      &lt;Text style={styles.name}&gt;{product.name}&lt;/Text&gt;
      &lt;Text style={styles.price}&gt;${product.price}&lt;/Text&gt;
      &lt;Pressable onPress={handlePress}&gt;
        &lt;Text style={styles.link}&gt;View Details&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
});

function OptimizedProductList({ products, onSelect, filters }) {
  const [sortOrder, setSortOrder] = useState('name');

  // Memoize expensive filtering/sorting
  const sortedProducts = useMemo(() => {
    return products
      .filter(p => filters.categories.includes(p.category))
      .filter(p => p.price >= filters.minPrice && p.price <= filters.maxPrice)
      .sort((a, b) => {
        if (sortOrder === 'name') return a.name.localeCompare(b.name);
        if (sortOrder === 'price') return a.price - b.price;
        return 0;
      });
  }, [products, filters, sortOrder]);

  // Stable renderItem
  const renderItem = useCallback(({ item }) => (
    &lt;ProductItem product={item} onSelect={onSelect} /&gt;
  ), [onSelect]);

  // Stable keyExtractor
  const keyExtractor = useCallback((item) => item.id, []);

  return (
    &lt;View style={{ flex: 1 }}&gt;
      &lt;SortPicker value={sortOrder} onChange={setSortOrder} /&gt;
      &lt;FlatList
        data={sortedProducts}
        renderItem={renderItem}
        keyExtractor={keyExtractor}
        removeClippedSubviews={true}
        maxToRenderPerBatch={10}
        windowSize={5}
        initialNumToRender={10}
      /&gt;
    &lt;/View&gt;
  );
}

// Improvements:
// 1. FlatList for virtualization
// 2. useMemo for filter/sort
// 3. memo for ProductItem
// 4. useCallback for handlers
// 5. StyleSheet for styles
// 6. expo-image with recyclingKey</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Create a Performance Audit Checklist</h3>
                    <p>Build a comprehensive checklist component that audits an app's performance.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Check for common performance issues</li>
                        <li>Measure actual metrics where possible</li>
                        <li>Provide pass/fail status for each check</li>
                        <li>Suggest fixes for failures</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect } from 'react';
import { View, Text, ScrollView, StyleSheet } from 'react-native';

interface AuditResult {
  name: string;
  category: string;
  passed: boolean;
  value?: string;
  suggestion?: string;
}

async function runPerformanceAudit(): Promise&lt;AuditResult[]&gt; {
  const results: AuditResult[] = [];

  // Check 1: Hermes enabled
  results.push({
    name: 'Hermes Engine',
    category: 'Configuration',
    passed: typeof HermesInternal !== 'undefined',
    value: typeof HermesInternal !== 'undefined' ? 'Enabled' : 'Disabled',
    suggestion: 'Enable Hermes in app.json for better performance',
  });

  // Check 2: Development mode
  results.push({
    name: 'Production Build',
    category: 'Configuration',
    passed: !__DEV__,
    value: __DEV__ ? 'Development' : 'Production',
    suggestion: 'Use production builds for accurate profiling',
  });

  // Check 3: Console statements (check for console usage)
  const hasConsole = typeof console.log === 'function';
  results.push({
    name: 'Console Statements',
    category: 'Code Quality',
    passed: !__DEV__, // Assume removed in production
    value: __DEV__ ? 'Present' : 'Stripped',
    suggestion: 'Remove console.log in production builds',
  });

  // Check 4: Memory usage (if available)
  if (typeof performance !== 'undefined' && 'memory' in performance) {
    const memory = (performance as any).memory;
    const usedMB = memory.usedJSHeapSize / (1024 * 1024);
    results.push({
      name: 'JS Heap Size',
      category: 'Memory',
      passed: usedMB < 150,
      value: `${usedMB.toFixed(1)} MB`,
      suggestion: usedMB >= 150 ? 'Investigate memory usage' : undefined,
    });
  }

  // Check 5: Image optimization check
  results.push({
    name: 'Image Library',
    category: 'Assets',
    passed: true, // Would need to check actual usage
    value: 'Check expo-image usage',
    suggestion: 'Use expo-image for better caching and performance',
  });

  // Check 6: List virtualization
  results.push({
    name: 'List Virtualization',
    category: 'Components',
    passed: true, // Would need static analysis
    value: 'Check FlatList usage',
    suggestion: 'Use FlatList/FlashList instead of ScrollView for lists',
  });

  return results;
}

function PerformanceAudit() {
  const [results, setResults] = useState&lt;AuditResult[]&gt;([]);
  const [isRunning, setIsRunning] = useState(false);

  const runAudit = async () => {
    setIsRunning(true);
    const auditResults = await runPerformanceAudit();
    setResults(auditResults);
    setIsRunning(false);
  };

  useEffect(() => {
    runAudit();
  }, []);

  const passedCount = results.filter(r => r.passed).length;
  const totalCount = results.length;

  const groupedResults = results.reduce((acc, result) => {
    if (!acc[result.category]) {
      acc[result.category] = [];
    }
    acc[result.category].push(result);
    return acc;
  }, {} as Record&lt;string, AuditResult[]&gt;);

  return (
    &lt;ScrollView style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Performance Audit&lt;/Text&gt;
      
      &lt;View style={styles.summary}&gt;
        &lt;Text style={styles.summaryText}&gt;
          Score: {passedCount}/{totalCount} checks passed
        &lt;/Text&gt;
        &lt;View style={[
          styles.scoreBar,
          { backgroundColor: passedCount === totalCount ? '#4CAF50' : '#FF9800' }
        ]} /&gt;
      &lt;/View&gt;

      {Object.entries(groupedResults).map(([category, items]) => (
        &lt;View key={category} style={styles.category}&gt;
          &lt;Text style={styles.categoryTitle}&gt;{category}&lt;/Text&gt;
          {items.map((item, index) => (
            &lt;View key={index} style={styles.item}&gt;
              &lt;View style={styles.itemHeader}&gt;
                &lt;Text style={styles.itemName}&gt;
                  {item.passed ? '‚úÖ' : '‚ùå'} {item.name}
                &lt;/Text&gt;
                &lt;Text style={styles.itemValue}&gt;{item.value}&lt;/Text&gt;
              &lt;/View&gt;
              {!item.passed && item.suggestion && (
                &lt;Text style={styles.suggestion}&gt;üí° {item.suggestion}&lt;/Text&gt;
              )}
            &lt;/View&gt;
          ))}
        &lt;/View&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16 },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 16 },
  summary: { marginBottom: 24 },
  summaryText: { fontSize: 18, marginBottom: 8 },
  scoreBar: { height: 8, borderRadius: 4 },
  category: { marginBottom: 20 },
  categoryTitle: { fontSize: 16, fontWeight: '600', marginBottom: 8, color: '#666' },
  item: { backgroundColor: '#f5f5f5', padding: 12, borderRadius: 8, marginBottom: 8 },
  itemHeader: { flexDirection: 'row', justifyContent: 'space-between' },
  itemName: { fontSize: 14, fontWeight: '500' },
  itemValue: { fontSize: 14, color: '#666' },
  suggestion: { fontSize: 12, color: '#FF9800', marginTop: 4 },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Set Up Performance Monitoring</h3>
                    <p>Implement a complete performance monitoring solution for a production app.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Track screen load times</li>
                        <li>Track API call durations</li>
                        <li>Track errors and crashes</li>
                        <li>Calculate and display P50/P95/P99</li>
                        <li>Set up alert thresholds</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>// performance/PerformanceMonitor.ts
type MetricType = 'screen_load' | 'api_call' | 'render' | 'custom';

interface Metric {
  type: MetricType;
  name: string;
  value: number;
  timestamp: number;
  metadata?: Record&lt;string, any&gt;;
}

class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  private metrics: Metric[] = [];
  private flushInterval: NodeJS.Timeout | null = null;
  private readonly MAX_METRICS = 1000;
  private readonly FLUSH_INTERVAL = 30000; // 30 seconds

  private constructor() {
    this.startAutoFlush();
  }

  static getInstance(): PerformanceMonitor {
    if (!this.instance) {
      this.instance = new PerformanceMonitor();
    }
    return this.instance;
  }

  track(type: MetricType, name: string, value: number, metadata?: Record&lt;string, any&gt;) {
    this.metrics.push({
      type,
      name,
      value,
      timestamp: Date.now(),
      metadata,
    });

    // Prevent memory issues
    if (this.metrics.length > this.MAX_METRICS) {
      this.metrics = this.metrics.slice(-this.MAX_METRICS / 2);
    }

    // Check thresholds
    this.checkThresholds(type, name, value);
  }

  // Convenience methods
  trackScreenLoad(screenName: string, durationMs: number) {
    this.track('screen_load', screenName, durationMs);
  }

  trackApiCall(endpoint: string, durationMs: number, status: number) {
    this.track('api_call', endpoint, durationMs, { status });
  }

  // Calculate percentiles
  getStats(type: MetricType, name?: string): {
    count: number;
    p50: number;
    p95: number;
    p99: number;
    avg: number;
  } | null {
    let filtered = this.metrics.filter(m => m.type === type);
    if (name) {
      filtered = filtered.filter(m => m.name === name);
    }

    if (filtered.length === 0) return null;

    const values = filtered.map(m => m.value).sort((a, b) => a - b);
    
    return {
      count: values.length,
      p50: this.percentile(values, 50),
      p95: this.percentile(values, 95),
      p99: this.percentile(values, 99),
      avg: values.reduce((a, b) => a + b, 0) / values.length,
    };
  }

  private percentile(sorted: number[], p: number): number {
    const index = Math.ceil((p / 100) * sorted.length) - 1;
    return sorted[Math.max(0, index)];
  }

  // Threshold checking
  private thresholds: Record&lt;string, number&gt; = {
    'screen_load:*': 3000,
    'api_call:*': 2000,
  };

  setThreshold(pattern: string, maxMs: number) {
    this.thresholds[pattern] = maxMs;
  }

  private checkThresholds(type: MetricType, name: string, value: number) {
    const specificKey = `${type}:${name}`;
    const genericKey = `${type}:*`;
    
    const threshold = this.thresholds[specificKey] || this.thresholds[genericKey];
    
    if (threshold && value > threshold) {
      this.onThresholdExceeded(type, name, value, threshold);
    }
  }

  private onThresholdExceeded(
    type: MetricType,
    name: string,
    value: number,
    threshold: number
  ) {
    console.warn(
      `Performance threshold exceeded: ${type}/${name} = ${value}ms (threshold: ${threshold}ms)`
    );
    
    // In production, send to alerting service
    if (!__DEV__) {
      // Sentry.captureMessage(...) or custom alerting
    }
  }

  // Flush to backend
  private startAutoFlush() {
    this.flushInterval = setInterval(() => {
      this.flush();
    }, this.FLUSH_INTERVAL);
  }

  async flush() {
    if (this.metrics.length === 0) return;

    const metricsToSend = [...this.metrics];
    this.metrics = [];

    try {
      // Send to your analytics backend
      await fetch('https://analytics.example.com/metrics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          metrics: metricsToSend,
          device: getDeviceInfo(),
          session: getSessionId(),
        }),
      });
    } catch (error) {
      // Put metrics back on failure
      this.metrics = [...metricsToSend, ...this.metrics];
      console.error('Failed to flush metrics:', error);
    }
  }

  // Debug view
  getSummary(): string {
    const screenStats = this.getStats('screen_load');
    const apiStats = this.getStats('api_call');

    return `
Performance Summary:
====================
Screen Loads: ${screenStats?.count || 0} tracked
  P50: ${screenStats?.p50?.toFixed(0) || '-'}ms
  P95: ${screenStats?.p95?.toFixed(0) || '-'}ms
  P99: ${screenStats?.p99?.toFixed(0) || '-'}ms

API Calls: ${apiStats?.count || 0} tracked
  P50: ${apiStats?.p50?.toFixed(0) || '-'}ms
  P95: ${apiStats?.p95?.toFixed(0) || '-'}ms
  P99: ${apiStats?.p99?.toFixed(0) || '-'}ms
    `.trim();
  }
}

export const perfMonitor = PerformanceMonitor.getInstance();

// Hooks for easy usage
export function useScreenPerformance(screenName: string) {
  useEffect(() => {
    const startTime = performance.now();

    return () => {
      const duration = performance.now() - startTime;
      perfMonitor.trackScreenLoad(screenName, duration);
    };
  }, [screenName]);
}

// HOC for API calls
export async function trackedFetch(
  url: string,
  options?: RequestInit
): Promise&lt;Response&gt; {
  const startTime = performance.now();
  
  try {
    const response = await fetch(url, options);
    const duration = performance.now() - startTime;
    
    perfMonitor.trackApiCall(
      new URL(url).pathname,
      duration,
      response.status
    );
    
    return response;
  } catch (error) {
    const duration = performance.now() - startTime;
    perfMonitor.trackApiCall(new URL(url).pathname, duration, 0);
    throw error;
  }
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>Profiling and debugging are essential skills for building performant apps. Use the right tools systematically, and always verify your optimizations with measurements.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>Systematic approach:</strong> Identify ‚Üí Measure ‚Üí Profile ‚Üí Fix ‚Üí Verify</li>
                        <li><strong>React Profiler:</strong> Primary tool for component render analysis</li>
                        <li><strong>Flipper:</strong> All-in-one debugging with network, database, and layout tools</li>
                        <li><strong>Native tools:</strong> Xcode Instruments and Android Studio for deep profiling</li>
                        <li><strong>Bundle analysis:</strong> Monitor and reduce bundle size</li>
                        <li><strong>Production monitoring:</strong> Track real user performance with Sentry/Firebase</li>
                        <li><strong>Percentiles matter:</strong> P95/P99 often reveal issues hidden by averages</li>
                        <li><strong>Set thresholds:</strong> Alert on regressions before users complain</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                    <h4>üéâ Module 10 Complete!</h4>
                    <p>You've mastered performance optimization in React Native. You now understand how to measure, profile, and fix performance issues across rendering, memory, network, and JavaScript execution.</p>
                    <p>In the next module, we'll cover deployment and publishing‚Äîgetting your optimized app into users' hands!</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m10_l04_network_optimization.html" class="prev-link">‚Üê Previous: Network Optimization</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m11_l01_app_store_publishing.html" class="next-link">Next: App Store Publishing ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
