<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn animation fundamentals in React Native - understanding the Animated API, timing, springs, and performance">
    <meta name="author" content="React Native & Expo Course">
    <title>Animation Fundamentals | Module 9: Animations and Gestures | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m09_l01_animation_fundamentals.html">Module 9</a> &gt;
            <span>Lesson 9.1</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 9: Animations and Gestures</p>
                <h1>Animation Fundamentals</h1>
                <p class="lesson-subtitle">Create fluid, performant animations that make your app feel alive and native</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Understand why animation matters for mobile UX</li>
                    <li>Learn the difference between JS thread and UI thread animations</li>
                    <li>Master the React Native Animated API basics</li>
                    <li>Implement timing, spring, and decay animations</li>
                    <li>Compose and sequence multiple animations</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#why-animation">Why Animation Matters</a></li>
                        <li><a href="#performance">Animation Performance</a></li>
                        <li><a href="#animated-api">The Animated API</a></li>
                        <li><a href="#animated-values">Animated Values</a></li>
                        <li><a href="#timing-animations">Timing Animations</a></li>
                        <li><a href="#spring-animations">Spring Animations</a></li>
                        <li><a href="#decay-animations">Decay Animations</a></li>
                        <li><a href="#composing">Composing Animations</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- Why Animation Matters -->
            <section id="why-animation">
                <h2>Why Animation Matters</h2>

                <p>Animation isn't just decoration‚Äîit's a fundamental part of how users understand and interact with mobile interfaces. Well-crafted animations provide feedback, guide attention, and create a sense of direct manipulation that makes apps feel responsive and intuitive.</p>

                <h3>The Role of Animation in Mobile UX</h3>

                <pre class="mermaid">
flowchart TD
    subgraph Purpose["Animation Purposes"]
        A[üéØ Feedback]
        B[üëÅÔ∏è Focus Attention]
        C[üîó Show Relationships]
        D[‚è≥ Indicate Progress]
        E[‚ú® Delight Users]
    end
    
    subgraph Examples["Examples"]
        A --> A1[Button press response]
        B --> B1[New item highlighting]
        C --> C1[Screen transitions]
        D --> D1[Loading spinners]
        E --> E1[Success celebrations]
    end
    
    style Purpose fill:#e3f2fd
    style Examples fill:#e8f5e9
</pre>

                <h3>Animation Guidelines</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Principle</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Good Practice</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Avoid</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Duration</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">200-500ms for most UI animations</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Animations longer than 1 second</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Purpose</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Every animation serves a function</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Animation for decoration only</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Easing</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Natural curves (ease-out, spring)</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Linear motion for UI elements</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Consistency</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Same timing for similar actions</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Random durations throughout app</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Performance</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">60fps smooth animations</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Janky, stuttering motion</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The 60fps Goal</h4>
                    <p>Mobile screens typically refresh at 60 frames per second (60fps), giving you approximately 16.67ms per frame. To achieve smooth animations, each frame must be calculated and rendered within this time budget. When frames take longer, users perceive stuttering or "jank."</p>
                </div>
            </section>

            <!-- Animation Performance -->
            <section id="performance">
                <h2>Animation Performance</h2>

                <p>Understanding how React Native handles animations is crucial for building performant apps. The key concept is the separation between the JavaScript thread and the UI (native) thread.</p>

                <h3>The Two-Thread Architecture</h3>

                <pre class="mermaid">
flowchart LR
    subgraph JS["JavaScript Thread"]
        A[React Logic]
        B[State Updates]
        C[Animation Calculations]
    end
    
    subgraph Bridge["Bridge"]
        D[Serialization]
        E[Async Messages]
    end
    
    subgraph UI["UI Thread (Native)"]
        F[Layout]
        G[Rendering]
        H[Touch Handling]
    end
    
    JS --> Bridge --> UI
    
    style JS fill:#fff3e0
    style Bridge fill:#ffebee
    style UI fill:#e8f5e9
</pre>

                <h3>Why This Matters for Animation</h3>

                <pre><code>// ‚ùå Problem: Animation calculated on JS thread
// Every frame requires crossing the bridge
function BadAnimation() {
  const [position, setPosition] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      // This runs on JS thread
      // Then sends update across bridge
      // Then native re-renders
      setPosition(p => p + 1);
    }, 16);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    &lt;View style={{ transform: [{ translateX: position }] }}&gt;
      &lt;Text&gt;Moving...&lt;/Text&gt;
    &lt;/View&gt;
  );
}

// ‚úÖ Solution: Use Animated API
// Animation runs entirely on native thread
import { Animated } from 'react-native';

function GoodAnimation() {
  const position = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(position, {
      toValue: 100,
      duration: 1000,
      useNativeDriver: true, // Key for performance!
    }).start();
  }, []);
  
  return (
    &lt;Animated.View style={{ transform: [{ translateX: position }] }}&gt;
      &lt;Text&gt;Moving smoothly!&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Native Driver</h3>

                <p>The <code>useNativeDriver</code> option is critical for performance. When enabled, the animation configuration is sent to the native side once at the start, and all subsequent frame calculations happen on the UI thread without crossing the bridge.</p>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Property</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Native Driver Support</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>transform</code> (translateX, translateY, scale, rotate)</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>opacity</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>width</code>, <code>height</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">‚ùå No (causes layout)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>backgroundColor</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">‚ùå No</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>margin</code>, <code>padding</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">‚ùå No (causes layout)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Native Driver Limitations</h4>
                    <p>When you need to animate properties that don't support native driver (like width, height, or colors), you have two options:</p>
                    <ul>
                        <li>Use <code>useNativeDriver: false</code> and accept potential performance issues</li>
                        <li>Use React Native Reanimated (covered in the next lesson) which supports more properties natively</li>
                    </ul>
                </div>
            </section>

            <!-- The Animated API -->
            <section id="animated-api">
                <h2>The Animated API</h2>

                <p>React Native's built-in <code>Animated</code> API provides everything you need for basic animations. It's declarative, composable, and when used correctly, highly performant.</p>

                <h3>Core Concepts</h3>

                <pre class="mermaid">
flowchart TD
    subgraph Values["Animated Values"]
        A[Animated.Value]
        B[Animated.ValueXY]
    end
    
    subgraph Drivers["Animation Drivers"]
        C[Animated.timing]
        D[Animated.spring]
        E[Animated.decay]
    end
    
    subgraph Components["Animated Components"]
        F[Animated.View]
        G[Animated.Text]
        H[Animated.Image]
        I[Animated.ScrollView]
    end
    
    subgraph Composition["Composition"]
        J[Animated.parallel]
        K[Animated.sequence]
        L[Animated.stagger]
    end
    
    Values --> Drivers
    Drivers --> Components
    Drivers --> Composition
    
    style Values fill:#e3f2fd
    style Drivers fill:#fff3e0
    style Components fill:#e8f5e9
    style Composition fill:#fce4ec
</pre>

                <h3>Basic Setup Pattern</h3>

                <pre><code>import React, { useRef, useEffect } from 'react';
import { Animated, View, StyleSheet } from 'react-native';

function BasicAnimation() {
  // 1. Create an animated value
  const fadeAnim = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    // 2. Define and start the animation
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 1000,
      useNativeDriver: true,
    }).start();
  }, [fadeAnim]);
  
  // 3. Use the animated value in an Animated component
  return (
    &lt;Animated.View style={[styles.box, { opacity: fadeAnim }]}&gt;
      &lt;Text&gt;I fade in!&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}

const styles = StyleSheet.create({
  box: {
    width: 100,
    height: 100,
    backgroundColor: '#007AFF',
    justifyContent: 'center',
    alignItems: 'center',
  },
});</code></pre>

                <h3>Animated Components</h3>

                <pre><code>import { Animated } from 'react-native';

// Built-in animated components
&lt;Animated.View /&gt;      // Most common
&lt;Animated.Text /&gt;      // For text animations
&lt;Animated.Image /&gt;     // For image animations
&lt;Animated.ScrollView /&gt; // For scroll-linked animations
&lt;Animated.FlatList /&gt;  // For list animations

// Creating custom animated components
const AnimatedPressable = Animated.createAnimatedComponent(Pressable);
const AnimatedLinearGradient = Animated.createAnimatedComponent(LinearGradient);

// Usage
function CustomAnimatedComponent() {
  const scale = useRef(new Animated.Value(1)).current;
  
  return (
    &lt;AnimatedPressable
      style={{ transform: [{ scale }] }}
      onPressIn={() => {
        Animated.spring(scale, {
          toValue: 0.95,
          useNativeDriver: true,
        }).start();
      }}
      onPressOut={() => {
        Animated.spring(scale, {
          toValue: 1,
          useNativeDriver: true,
        }).start();
      }}
    &gt;
      &lt;Text&gt;Press me!&lt;/Text&gt;
    &lt;/AnimatedPressable&gt;
  );
}</code></pre>
            </section>
            <!-- Animated Values -->
            <section id="animated-values">
                <h2>Animated Values</h2>

                <p>Animated values are the foundation of the Animated API. They hold the current state of an animation and can be interpolated, combined, and connected to component styles.</p>

                <h3>Animated.Value</h3>

                <pre><code>import React, { useRef } from 'react';
import { Animated } from 'react-native';

function AnimatedValueExample() {
  // Create a single animated value
  const opacity = useRef(new Animated.Value(0)).current;
  const scale = useRef(new Animated.Value(0.5)).current;
  const rotation = useRef(new Animated.Value(0)).current;
  
  // Values can be set directly (no animation)
  const resetValues = () => {
    opacity.setValue(0);
    scale.setValue(0.5);
    rotation.setValue(0);
  };
  
  // Get the current value (for debugging/logic)
  const logCurrentOpacity = () => {
    // Note: This is async and may not reflect the exact current value
    opacity.addListener(({ value }) => {
      console.log('Current opacity:', value);
    });
  };
  
  return (
    &lt;Animated.View
      style={{
        opacity: opacity,
        transform: [
          { scale: scale },
          { rotate: rotation.interpolate({
              inputRange: [0, 1],
              outputRange: ['0deg', '360deg'],
            })
          },
        ],
      }}
    /&gt;
  );
}</code></pre>

                <h3>Animated.ValueXY</h3>

                <pre><code>import React, { useRef } from 'react';
import { Animated, PanResponder } from 'react-native';

function DraggableBox() {
  // Create a 2D animated value for position
  const position = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
  
  // ValueXY provides helpful methods
  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onPanResponderMove: Animated.event(
        [null, { dx: position.x, dy: position.y }],
        { useNativeDriver: false }
      ),
      onPanResponderRelease: () => {
        // Spring back to origin
        Animated.spring(position, {
          toValue: { x: 0, y: 0 },
          useNativeDriver: true,
        }).start();
      },
    })
  ).current;
  
  return (
    &lt;Animated.View
      {...panResponder.panHandlers}
      style={[
        styles.box,
        // getLayout() returns { left, top } style object
        position.getLayout(),
        // Or use getTranslateTransform() for transforms
        // { transform: position.getTranslateTransform() }
      ]}
    /&gt;
  );
}

// ValueXY methods
const position = new Animated.ValueXY({ x: 0, y: 0 });

// Get as layout style (left, top)
position.getLayout(); // { left: x, top: y }

// Get as transform style
position.getTranslateTransform(); // [{ translateX: x }, { translateY: y }]

// Set both values at once
position.setValue({ x: 100, y: 200 });

// Reset to initial value
position.setOffset({ x: 0, y: 0 });

// Extract individual values
const { x, y } = position;
// x and y are Animated.Value instances</code></pre>

                <h3>Interpolation</h3>

                <p>Interpolation is one of the most powerful features of the Animated API. It allows you to map an animated value to different output ranges and types.</p>

                <pre><code>import React, { useRef, useEffect } from 'react';
import { Animated, StyleSheet, View } from 'react-native';

function InterpolationExample() {
  const progress = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(progress, {
      toValue: 1,
      duration: 2000,
      useNativeDriver: true,
    }).start();
  }, []);
  
  // Basic interpolation: map 0-1 to 0-100
  const translateX = progress.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 100],
  });
  
  // Non-linear interpolation with multiple stops
  const scale = progress.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: [1, 1.5, 1],  // Scale up then back down
  });
  
  // String interpolation (for rotation, colors)
  const rotate = progress.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  
  // Color interpolation (note: requires useNativeDriver: false)
  const backgroundColor = progress.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: ['#FF0000', '#00FF00', '#0000FF'],
  });
  
  // Clamping behavior
  const clampedValue = progress.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 100],
    extrapolate: 'clamp',        // Clamp both ends
    // extrapolateLeft: 'clamp', // Clamp only left
    // extrapolateRight: 'extend', // Extend only right
  });
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;Animated.View
        style={[
          styles.box,
          {
            transform: [
              { translateX },
              { scale },
              { rotate },
            ],
          },
        ]}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  box: {
    width: 100,
    height: 100,
    backgroundColor: '#007AFF',
  },
});</code></pre>

                <h3>Common Interpolation Patterns</h3>

                <pre><code>// Fade in while sliding up
const opacity = animation.interpolate({
  inputRange: [0, 1],
  outputRange: [0, 1],
});
const translateY = animation.interpolate({
  inputRange: [0, 1],
  outputRange: [50, 0],
});

// Bounce effect (overshoot)
const scale = animation.interpolate({
  inputRange: [0, 0.5, 0.75, 1],
  outputRange: [0, 1.2, 0.9, 1],
});

// Shake animation
const shake = animation.interpolate({
  inputRange: [0, 0.25, 0.5, 0.75, 1],
  outputRange: ['0deg', '-5deg', '5deg', '-5deg', '0deg'],
});

// Progress bar fill
const width = progress.interpolate({
  inputRange: [0, 1],
  outputRange: ['0%', '100%'],
});

// Scroll-linked parallax
const parallaxTranslate = scrollY.interpolate({
  inputRange: [-100, 0, 100],
  outputRange: [50, 0, -50],
  extrapolate: 'clamp',
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Interpolation Tips</h4>
                    <ul>
                        <li><code>inputRange</code> values must be monotonically increasing</li>
                        <li>Use <code>extrapolate: 'clamp'</code> to prevent values outside the range</li>
                        <li>String outputs (degrees, colors, percentages) require <code>useNativeDriver: false</code> except for rotation</li>
                        <li>Chain interpolations for complex mappings</li>
                    </ul>
                </div>
            </section>

            <!-- Timing Animations -->
            <section id="timing-animations">
                <h2>Timing Animations</h2>

                <p><code>Animated.timing()</code> creates animations that progress from one value to another over a specified duration, optionally with an easing function.</p>

                <h3>Basic Timing Animation</h3>

                <pre><code>import React, { useRef } from 'react';
import { Animated, Pressable, Text, StyleSheet } from 'react-native';

function TimingExample() {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  
  const fadeIn = () => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start();
  };
  
  const fadeOut = () => {
    Animated.timing(fadeAnim, {
      toValue: 0,
      duration: 500,
      useNativeDriver: true,
    }).start();
  };
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;Animated.View style={[styles.box, { opacity: fadeAnim }]} /&gt;
      
      &lt;Pressable style={styles.button} onPress={fadeIn}&gt;
        &lt;Text style={styles.buttonText}&gt;Fade In&lt;/Text&gt;
      &lt;/Pressable&gt;
      
      &lt;Pressable style={styles.button} onPress={fadeOut}&gt;
        &lt;Text style={styles.buttonText}&gt;Fade Out&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Easing Functions</h3>

                <p>Easing functions control the rate of change over time, making animations feel more natural.</p>

                <pre><code>import { Animated, Easing } from 'react-native';

// Linear (constant speed - usually feels unnatural)
Animated.timing(value, {
  toValue: 1,
  duration: 500,
  easing: Easing.linear,
  useNativeDriver: true,
}).start();

// Ease in (starts slow, ends fast)
Animated.timing(value, {
  toValue: 1,
  duration: 500,
  easing: Easing.in(Easing.ease),
  useNativeDriver: true,
}).start();

// Ease out (starts fast, ends slow) - Most common for UI
Animated.timing(value, {
  toValue: 1,
  duration: 500,
  easing: Easing.out(Easing.ease),
  useNativeDriver: true,
}).start();

// Ease in-out (slow start and end)
Animated.timing(value, {
  toValue: 1,
  duration: 500,
  easing: Easing.inOut(Easing.ease),
  useNativeDriver: true,
}).start();

// Bounce effect
Animated.timing(value, {
  toValue: 1,
  duration: 800,
  easing: Easing.bounce,
  useNativeDriver: true,
}).start();

// Elastic effect
Animated.timing(value, {
  toValue: 1,
  duration: 1000,
  easing: Easing.elastic(2),
  useNativeDriver: true,
}).start();

// Back (overshoots then returns)
Animated.timing(value, {
  toValue: 1,
  duration: 500,
  easing: Easing.back(1.5),
  useNativeDriver: true,
}).start();

// Bezier curve (custom easing)
Animated.timing(value, {
  toValue: 1,
  duration: 500,
  easing: Easing.bezier(0.25, 0.1, 0.25, 1),
  useNativeDriver: true,
}).start();</code></pre>

                <h3>Easing Visualization</h3>

                <svg viewBox="0 0 600 300" style="width: 100%; max-width: 600px; margin: 1rem auto; display: block;">
                    <!-- Grid -->
                    <defs>
                        <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                            <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#e0e0e0" stroke-width="1"/>
                        </pattern>
                    </defs>
                    <rect width="600" height="300" fill="url(#grid)"/>
                    
                    <!-- Axes -->
                    <line x1="50" y1="250" x2="550" y2="250" stroke="#333" stroke-width="2"/>
                    <line x1="50" y1="250" x2="50" y2="50" stroke="#333" stroke-width="2"/>
                    <text x="300" y="290" text-anchor="middle" font-size="14">Time</text>
                    <text x="20" y="150" text-anchor="middle" font-size="14" transform="rotate(-90, 20, 150)">Value</text>
                    
                    <!-- Linear -->
                    <path d="M 50 250 L 200 50" stroke="#999" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                    <text x="125" y="130" font-size="12" fill="#999">Linear</text>
                    
                    <!-- Ease Out -->
                    <path d="M 50 250 Q 150 50 200 50" stroke="#007AFF" stroke-width="3" fill="none"/>
                    <text x="160" y="100" font-size="12" fill="#007AFF">Ease Out</text>
                    
                    <!-- Ease In -->
                    <path d="M 250 250 Q 350 250 400 50" stroke="#FF9500" stroke-width="3" fill="none"/>
                    <text x="350" y="180" font-size="12" fill="#FF9500">Ease In</text>
                    
                    <!-- Bounce -->
                    <path d="M 450 250 Q 480 100 500 50 Q 510 80 515 50 Q 520 65 525 50 L 550 50" stroke="#34C759" stroke-width="3" fill="none"/>
                    <text x="520" y="100" font-size="12" fill="#34C759">Bounce</text>
                </svg>

                <h3>Animation Callbacks</h3>

                <pre><code>import { Animated } from 'react-native';

function AnimationCallbacks() {
  const value = useRef(new Animated.Value(0)).current;
  
  const runAnimation = () => {
    Animated.timing(value, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start(({ finished }) => {
      // Callback when animation completes
      if (finished) {
        console.log('Animation completed successfully');
        // Chain another animation
        Animated.timing(value, {
          toValue: 0,
          duration: 500,
          useNativeDriver: true,
        }).start();
      } else {
        console.log('Animation was interrupted');
      }
    });
  };
  
  // Stop animation programmatically
  const stopAnimation = () => {
    value.stopAnimation((currentValue) => {
      console.log('Stopped at value:', currentValue);
    });
  };
  
  // Reset to initial value
  const resetAnimation = () => {
    value.setValue(0);
  };
  
  return (/* ... */);
}</code></pre>

                <h3>Looping Animations</h3>

                <pre><code>import { Animated, Easing } from 'react-native';

function LoopingAnimation() {
  const rotation = useRef(new Animated.Value(0)).current;
  const pulse = useRef(new Animated.Value(1)).current;
  
  useEffect(() => {
    // Infinite rotation
    Animated.loop(
      Animated.timing(rotation, {
        toValue: 1,
        duration: 2000,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    ).start();
    
    // Pulsing animation (loop with reverse)
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulse, {
          toValue: 1.2,
          duration: 500,
          useNativeDriver: true,
        }),
        Animated.timing(pulse, {
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }),
      ])
    ).start();
  }, []);
  
  const rotate = rotation.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  
  return (
    &lt;View style={styles.container}&gt;
      {/* Spinning loader */}
      &lt;Animated.View
        style={[
          styles.spinner,
          { transform: [{ rotate }] },
        ]}
      /&gt;
      
      {/* Pulsing dot */}
      &lt;Animated.View
        style={[
          styles.dot,
          { transform: [{ scale: pulse }] },
        ]}
      /&gt;
    &lt;/View&gt;
  );
}

// Loop with iteration count
Animated.loop(
  Animated.timing(value, { /* ... */ }),
  { iterations: 3 }  // Run 3 times then stop
).start();</code></pre>
            </section>
            <!-- Spring Animations -->
            <section id="spring-animations">
                <h2>Spring Animations</h2>

                <p><code>Animated.spring()</code> creates physics-based animations that feel natural and responsive. Springs are ideal for interactions like dragging, releasing, and button presses because they respond dynamically to their target value.</p>

                <h3>Basic Spring Animation</h3>

                <pre><code>import React, { useRef } from 'react';
import { Animated, Pressable, StyleSheet, View } from 'react-native';

function SpringExample() {
  const scale = useRef(new Animated.Value(1)).current;
  
  const onPressIn = () => {
    Animated.spring(scale, {
      toValue: 0.9,
      useNativeDriver: true,
    }).start();
  };
  
  const onPressOut = () => {
    Animated.spring(scale, {
      toValue: 1,
      useNativeDriver: true,
    }).start();
  };
  
  return (
    &lt;Pressable onPressIn={onPressIn} onPressOut={onPressOut}&gt;
      &lt;Animated.View
        style={[
          styles.button,
          { transform: [{ scale }] },
        ]}
      &gt;
        &lt;Text style={styles.buttonText}&gt;Press Me&lt;/Text&gt;
      &lt;/Animated.View&gt;
    &lt;/Pressable&gt;
  );
}</code></pre>

                <h3>Spring Configuration</h3>

                <p>Springs can be configured using either the bounciness/speed model or the tension/friction model.</p>

                <pre><code>import { Animated } from 'react-native';

// Bounciness and Speed model (simpler)
Animated.spring(value, {
  toValue: 1,
  speed: 12,       // Controls animation speed (default: 12)
  bounciness: 8,   // Controls bounciness (default: 8)
  useNativeDriver: true,
}).start();

// Tension and Friction model (more control)
Animated.spring(value, {
  toValue: 1,
  tension: 40,     // Controls the spring's stiffness (default: 40)
  friction: 7,     // Controls the damping/resistance (default: 7)
  useNativeDriver: true,
}).start();

// Stiffness, Damping, Mass model (physics-based)
Animated.spring(value, {
  toValue: 1,
  stiffness: 100,  // Spring stiffness coefficient
  damping: 10,     // Damping coefficient
  mass: 1,         // Mass of the object (default: 1)
  useNativeDriver: true,
}).start();

// Additional options
Animated.spring(value, {
  toValue: 1,
  velocity: 0.5,           // Initial velocity
  restDisplacementThreshold: 0.001, // When to consider at rest
  restSpeedThreshold: 0.001,        // Speed to consider stopped
  useNativeDriver: true,
}).start();</code></pre>

                <h3>Spring Presets</h3>

                <pre><code>// Common spring configurations
const SpringPresets = {
  // Gentle, slow spring (for large movements)
  gentle: {
    tension: 20,
    friction: 7,
  },
  
  // Default feel
  default: {
    tension: 40,
    friction: 7,
  },
  
  // Snappy response (for button presses)
  snappy: {
    tension: 100,
    friction: 10,
  },
  
  // Very bouncy (for playful UI)
  bouncy: {
    tension: 80,
    friction: 3,
  },
  
  // Stiff, minimal bounce (for precise control)
  stiff: {
    tension: 200,
    friction: 20,
  },
  
  // Slow and smooth (for page transitions)
  smooth: {
    tension: 50,
    friction: 12,
  },
};

// Usage
function AnimatedButton() {
  const scale = useRef(new Animated.Value(1)).current;
  
  const onPress = () => {
    Animated.spring(scale, {
      toValue: 0.95,
      ...SpringPresets.snappy,
      useNativeDriver: true,
    }).start(() => {
      Animated.spring(scale, {
        toValue: 1,
        ...SpringPresets.snappy,
        useNativeDriver: true,
      }).start();
    });
  };
  
  return (
    &lt;Pressable onPress={onPress}&gt;
      &lt;Animated.View style={{ transform: [{ scale }] }}&gt;
        &lt;Text&gt;Tap&lt;/Text&gt;
      &lt;/Animated.View&gt;
    &lt;/Pressable&gt;
  );
}</code></pre>

                <h3>Spring vs Timing Comparison</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Aspect</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Timing</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Spring</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Duration</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Fixed, specified in ms</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Variable, depends on physics</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Best for</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Fades, progress bars, timed sequences</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Interactive UI, drag releases, buttons</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Interruptible</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Restarts from current position</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Continues naturally with velocity</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Feel</strong></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Mechanical, predictable</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Organic, responsive</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use Spring</h4>
                    <ul>
                        <li><strong>Interactive elements:</strong> Buttons, toggles, cards that respond to touch</li>
                        <li><strong>Drag and release:</strong> When something is thrown and needs to settle</li>
                        <li><strong>Target changes mid-animation:</strong> Spring naturally adjusts to new targets</li>
                        <li><strong>When duration doesn't matter:</strong> Let physics determine timing</li>
                    </ul>
                </div>
            </section>

            <!-- Decay Animations -->
            <section id="decay-animations">
                <h2>Decay Animations</h2>

                <p><code>Animated.decay()</code> creates animations that start with an initial velocity and gradually slow down based on a deceleration factor. This is perfect for momentum-based scrolling and flick gestures.</p>

                <h3>Basic Decay Animation</h3>

                <pre><code>import React, { useRef } from 'react';
import { Animated, PanResponder, StyleSheet, View } from 'react-native';

function DecayExample() {
  const position = useRef(new Animated.ValueXY()).current;
  
  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onPanResponderMove: Animated.event(
        [null, { dx: position.x, dy: position.y }],
        { useNativeDriver: false }
      ),
      onPanResponderRelease: (_, gestureState) => {
        // Decay animation based on release velocity
        Animated.decay(position, {
          velocity: { 
            x: gestureState.vx, 
            y: gestureState.vy 
          },
          deceleration: 0.997, // 0.998 is default, lower = faster stop
          useNativeDriver: true,
        }).start();
      },
    })
  ).current;
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;Animated.View
        {...panResponder.panHandlers}
        style={[
          styles.ball,
          { transform: position.getTranslateTransform() },
        ]}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
  },
  ball: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#007AFF',
  },
});</code></pre>

                <h3>Decay Configuration</h3>

                <pre><code>Animated.decay(value, {
  velocity: 0.5,         // Initial velocity (required)
  deceleration: 0.997,   // Rate of deceleration (default: 0.997)
  useNativeDriver: true,
}).start();

// Deceleration values:
// 0.999 - Very slow deceleration (long coast)
// 0.997 - Default, moderate deceleration
// 0.990 - Fast deceleration (quick stop)

// For 2D decay
Animated.decay(positionXY, {
  velocity: { x: velocityX, y: velocityY },
  deceleration: 0.997,
  useNativeDriver: true,
}).start();</code></pre>

                <h3>Decay with Boundaries</h3>

                <pre><code>import React, { useRef } from 'react';
import { Animated, PanResponder, Dimensions } from 'react-native';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const BALL_SIZE = 80;

function BoundedDecay() {
  const position = useRef(new Animated.ValueXY()).current;
  
  const clampPosition = () => {
    // Get current values
    const currentX = position.x._value;
    const currentY = position.y._value;
    
    // Check boundaries
    const maxX = SCREEN_WIDTH - BALL_SIZE;
    const maxY = SCREEN_HEIGHT - BALL_SIZE;
    
    let needsCorrection = false;
    let targetX = currentX;
    let targetY = currentY;
    
    if (currentX < 0) { targetX = 0; needsCorrection = true; }
    if (currentX > maxX) { targetX = maxX; needsCorrection = true; }
    if (currentY < 0) { targetY = 0; needsCorrection = true; }
    if (currentY > maxY) { targetY = maxY; needsCorrection = true; }
    
    if (needsCorrection) {
      Animated.spring(position, {
        toValue: { x: targetX, y: targetY },
        useNativeDriver: true,
        tension: 100,
        friction: 10,
      }).start();
    }
  };
  
  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onPanResponderGrant: () => {
        // Stop any ongoing animation
        position.stopAnimation();
        position.setOffset({
          x: position.x._value,
          y: position.y._value,
        });
        position.setValue({ x: 0, y: 0 });
      },
      onPanResponderMove: Animated.event(
        [null, { dx: position.x, dy: position.y }],
        { useNativeDriver: false }
      ),
      onPanResponderRelease: (_, gestureState) => {
        position.flattenOffset();
        
        Animated.decay(position, {
          velocity: { x: gestureState.vx, y: gestureState.vy },
          deceleration: 0.997,
          useNativeDriver: true,
        }).start(() => {
          // Check boundaries after decay completes
          clampPosition();
        });
      },
    })
  ).current;
  
  return (
    &lt;Animated.View
      {...panResponder.panHandlers}
      style={[
        styles.ball,
        { transform: position.getTranslateTransform() },
      ]}
    /&gt;
  );
}</code></pre>

                <h3>When to Use Each Animation Type</h3>

                <pre class="mermaid">
flowchart TD
    A[Need Animation] --> B{What triggers it?}
    
    B -->|Time-based event| C{Fixed duration needed?}
    B -->|User interaction| D{Type of interaction?}
    
    C -->|Yes| E[Use Timing]
    C -->|No| F[Use Spring]
    
    D -->|Button press/tap| F
    D -->|Drag and release| G{With momentum?}
    D -->|Scroll-linked| H[Use Interpolation]
    
    G -->|Yes| I[Use Decay]
    G -->|No| F
    
    style E fill:#fff3e0
    style F fill:#e3f2fd
    style I fill:#e8f5e9
    style H fill:#fce4ec
</pre>
            </section>

            <!-- Composing Animations -->
            <section id="composing">
                <h2>Composing Animations</h2>

                <p>Complex animations often require multiple values animating together or in sequence. The Animated API provides several methods for composing animations.</p>

                <h3>Parallel Animations</h3>

                <p>Run multiple animations at the same time.</p>

                <pre><code>import { Animated } from 'react-native';

function ParallelExample() {
  const opacity = useRef(new Animated.Value(0)).current;
  const translateY = useRef(new Animated.Value(50)).current;
  const scale = useRef(new Animated.Value(0.8)).current;
  
  const animateIn = () => {
    // Reset values
    opacity.setValue(0);
    translateY.setValue(50);
    scale.setValue(0.8);
    
    // Run all animations simultaneously
    Animated.parallel([
      Animated.timing(opacity, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(translateY, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.spring(scale, {
        toValue: 1,
        tension: 50,
        friction: 7,
        useNativeDriver: true,
      }),
    ]).start();
  };
  
  return (
    &lt;Animated.View
      style={{
        opacity,
        transform: [
          { translateY },
          { scale },
        ],
      }}
    &gt;
      &lt;Text&gt;Animated Content&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}

// With stopTogether option
Animated.parallel(animations, {
  stopTogether: false, // If one stops, others continue (default: true)
}).start();</code></pre>

                <h3>Sequence Animations</h3>

                <p>Run animations one after another.</p>

                <pre><code>import { Animated } from 'react-native';

function SequenceExample() {
  const step1 = useRef(new Animated.Value(0)).current;
  const step2 = useRef(new Animated.Value(0)).current;
  const step3 = useRef(new Animated.Value(0)).current;
  
  const runSequence = () => {
    // Reset
    step1.setValue(0);
    step2.setValue(0);
    step3.setValue(0);
    
    // Run in order
    Animated.sequence([
      Animated.timing(step1, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(step2, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(step3, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start(() => {
      console.log('All steps complete!');
    });
  };
  
  return (/* ... */);
}</code></pre>

                <h3>Stagger Animations</h3>

                <p>Start multiple animations with a delay between each.</p>

                <pre><code>import { Animated } from 'react-native';

function StaggerExample() {
  // Array of animated values for list items
  const items = useRef(
    [0, 1, 2, 3, 4].map(() => new Animated.Value(0))
  ).current;
  
  const animateItems = () => {
    // Reset all
    items.forEach(item => item.setValue(0));
    
    // Stagger animations with 100ms delay between each
    Animated.stagger(100, 
      items.map(item =>
        Animated.spring(item, {
          toValue: 1,
          tension: 50,
          friction: 7,
          useNativeDriver: true,
        })
      )
    ).start();
  };
  
  return (
    &lt;View&gt;
      {items.map((animValue, index) => (
        &lt;Animated.View
          key={index}
          style={{
            opacity: animValue,
            transform: [{
              translateX: animValue.interpolate({
                inputRange: [0, 1],
                outputRange: [-100, 0],
              }),
            }],
          }}
        &gt;
          &lt;Text&gt;Item {index + 1}&lt;/Text&gt;
        &lt;/Animated.View&gt;
      ))}
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Delay</h3>

                <pre><code>import { Animated } from 'react-native';

// Add delay before an animation
Animated.sequence([
  Animated.delay(500), // Wait 500ms
  Animated.timing(value, {
    toValue: 1,
    duration: 300,
    useNativeDriver: true,
  }),
]).start();

// Delay between animations
Animated.sequence([
  Animated.timing(fadeIn, { /* ... */ }),
  Animated.delay(200),
  Animated.timing(slideUp, { /* ... */ }),
]).start();</code></pre>

                <h3>Complex Composition Example</h3>

                <pre><code>import React, { useRef } from 'react';
import { Animated, Easing, StyleSheet, View, Pressable, Text } from 'react-native';

function ComplexAnimation() {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(-100)).current;
  const scaleAnim = useRef(new Animated.Value(0)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  
  const playAnimation = () => {
    // Reset all values
    fadeAnim.setValue(0);
    slideAnim.setValue(-100);
    scaleAnim.setValue(0);
    rotateAnim.setValue(0);
    
    Animated.sequence([
      // First: Fade in and slide simultaneously
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 300,
          easing: Easing.out(Easing.back(1.5)),
          useNativeDriver: true,
        }),
      ]),
      
      // Then: Scale up with bounce
      Animated.spring(scaleAnim, {
        toValue: 1,
        tension: 80,
        friction: 4,
        useNativeDriver: true,
      }),
      
      // Small delay
      Animated.delay(100),
      
      // Finally: Spin
      Animated.timing(rotateAnim, {
        toValue: 1,
        duration: 500,
        easing: Easing.elastic(1),
        useNativeDriver: true,
      }),
    ]).start();
  };
  
  const rotate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;Animated.View
        style={[
          styles.box,
          {
            opacity: fadeAnim,
            transform: [
              { translateY: slideAnim },
              { scale: scaleAnim },
              { rotate },
            ],
          },
        ]}
      &gt;
        &lt;Text style={styles.boxText}&gt;‚ú®&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      &lt;Pressable style={styles.button} onPress={playAnimation}&gt;
        &lt;Text style={styles.buttonText}&gt;Play Animation&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  box: {
    width: 120,
    height: 120,
    backgroundColor: '#007AFF',
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 40,
  },
  boxText: {
    fontSize: 48,
  },
  button: {
    backgroundColor: '#34C759',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Animation Composition Tips</h4>
                    <ul>
                        <li>Always reset animated values before replaying an animation</li>
                        <li>Use <code>stopAnimation()</code> to prevent animation buildup</li>
                        <li>Consider extracting common animation patterns into reusable functions</li>
                        <li>Test on real devices‚Äîsimulators may not reveal performance issues</li>
                    </ul>
                </div>
            </section>
            <!-- Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: Animated Like Button</h3>
                    <p>Create a heart-shaped like button with satisfying animation feedback when pressed.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Scale down on press, bounce back on release</li>
                        <li>Color transition from gray to red when liked</li>
                        <li>Small hearts burst effect when liking</li>
                        <li>Toggle between liked and unliked states</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import React, { useRef, useState } from 'react';
import { Animated, Pressable, StyleSheet, View, Text } from 'react-native';

function AnimatedLikeButton() {
  const [isLiked, setIsLiked] = useState(false);
  
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const burstAnims = useRef(
    Array(6).fill(0).map(() => ({
      scale: new Animated.Value(0),
      opacity: new Animated.Value(1),
      translateX: new Animated.Value(0),
      translateY: new Animated.Value(0),
    }))
  ).current;
  
  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.8,
      tension: 100,
      friction: 5,
      useNativeDriver: true,
    }).start();
  };
  
  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      tension: 100,
      friction: 5,
      useNativeDriver: true,
    }).start();
  };
  
  const handlePress = () => {
    const newLikedState = !isLiked;
    setIsLiked(newLikedState);
    
    if (newLikedState) {
      // Burst animation when liking
      burstAnims.forEach((anim, index) => {
        anim.scale.setValue(0);
        anim.opacity.setValue(1);
        anim.translateX.setValue(0);
        anim.translateY.setValue(0);
        
        const angle = (index / 6) * 2 * Math.PI;
        const distance = 40;
        const targetX = Math.cos(angle) * distance;
        const targetY = Math.sin(angle) * distance;
        
        Animated.parallel([
          Animated.sequence([
            Animated.spring(anim.scale, {
              toValue: 1,
              tension: 200,
              friction: 5,
              useNativeDriver: true,
            }),
            Animated.timing(anim.scale, {
              toValue: 0,
              duration: 200,
              useNativeDriver: true,
            }),
          ]),
          Animated.timing(anim.translateX, {
            toValue: targetX,
            duration: 400,
            useNativeDriver: true,
          }),
          Animated.timing(anim.translateY, {
            toValue: targetY,
            duration: 400,
            useNativeDriver: true,
          }),
          Animated.timing(anim.opacity, {
            toValue: 0,
            duration: 400,
            useNativeDriver: true,
          }),
        ]).start();
      });
      
      // Main heart bounce
      Animated.sequence([
        Animated.spring(scaleAnim, {
          toValue: 1.3,
          tension: 200,
          friction: 3,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 100,
          friction: 5,
          useNativeDriver: true,
        }),
      ]).start();
    }
  };
  
  return (
    &lt;View style={styles.container}&gt;
      {/* Burst particles */}
      {burstAnims.map((anim, index) => (
        &lt;Animated.Text
          key={index}
          style={[
            styles.particle,
            {
              opacity: anim.opacity,
              transform: [
                { scale: anim.scale },
                { translateX: anim.translateX },
                { translateY: anim.translateY },
              ],
            },
          ]}
        &gt;
          ‚ù§Ô∏è
        &lt;/Animated.Text&gt;
      ))}
      
      {/* Main button */}
      &lt;Pressable
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        onPress={handlePress}
      &gt;
        &lt;Animated.View
          style={[
            styles.button,
            { transform: [{ scale: scaleAnim }] },
          ]}
        &gt;
          &lt;Text style={styles.heart}&gt;
            {isLiked ? '‚ù§Ô∏è' : 'ü§ç'}
          &lt;/Text&gt;
        &lt;/Animated.View&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
    height: 150,
  },
  button: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  heart: {
    fontSize: 36,
  },
  particle: {
    position: 'absolute',
    fontSize: 16,
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Staggered List Animation</h3>
                    <p>Create an animated list where items slide in one after another when the screen loads.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Items slide in from the right with fade</li>
                        <li>Each item starts 100ms after the previous</li>
                        <li>Use spring animation for natural feel</li>
                        <li>Add a "Refresh" button that replays the animation</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import React, { useRef, useEffect } from 'react';
import { 
  Animated, View, Text, Pressable, 
  StyleSheet, FlatList 
} from 'react-native';

const ITEMS = [
  { id: '1', title: 'First Item', subtitle: 'Welcome to the list' },
  { id: '2', title: 'Second Item', subtitle: 'This slides in after' },
  { id: '3', title: 'Third Item', subtitle: 'Staggered animation' },
  { id: '4', title: 'Fourth Item', subtitle: 'Looks pretty cool' },
  { id: '5', title: 'Fifth Item', subtitle: 'Spring physics' },
  { id: '6', title: 'Sixth Item', subtitle: 'Last one!' },
];

function StaggeredList() {
  const animatedValues = useRef(
    ITEMS.map(() => new Animated.Value(0))
  ).current;
  
  const animateIn = () => {
    // Reset all values
    animatedValues.forEach(anim => anim.setValue(0));
    
    // Stagger animations
    Animated.stagger(
      100,
      animatedValues.map(anim =>
        Animated.spring(anim, {
          toValue: 1,
          tension: 50,
          friction: 8,
          useNativeDriver: true,
        })
      )
    ).start();
  };
  
  useEffect(() => {
    // Animate on mount
    const timer = setTimeout(animateIn, 300);
    return () => clearTimeout(timer);
  }, []);
  
  const renderItem = ({ item, index }: { item: typeof ITEMS[0]; index: number }) => {
    const animValue = animatedValues[index];
    
    const translateX = animValue.interpolate({
      inputRange: [0, 1],
      outputRange: [100, 0],
    });
    
    const opacity = animValue.interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: [0, 0.5, 1],
    });
    
    return (
      &lt;Animated.View
        style={[
          styles.itemContainer,
          {
            opacity,
            transform: [{ translateX }],
          },
        ]}
      &gt;
        &lt;View style={styles.item}&gt;
          &lt;Text style={styles.itemTitle}&gt;{item.title}&lt;/Text&gt;
          &lt;Text style={styles.itemSubtitle}&gt;{item.subtitle}&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/Animated.View&gt;
    );
  };
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;Pressable style={styles.refreshButton} onPress={animateIn}&gt;
        &lt;Text style={styles.refreshText}&gt;üîÑ Refresh Animation&lt;/Text&gt;
      &lt;/Pressable&gt;
      
      &lt;FlatList
        data={ITEMS}
        renderItem={renderItem}
        keyExtractor={item => item.id}
        contentContainerStyle={styles.list}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  refreshButton: {
    backgroundColor: '#007AFF',
    padding: 16,
    margin: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  refreshText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  list: {
    padding: 16,
  },
  itemContainer: {
    marginBottom: 12,
  },
  item: {
    backgroundColor: 'white',
    padding: 16,
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  itemTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 4,
  },
  itemSubtitle: {
    fontSize: 14,
    color: '#666',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Animated Progress Ring</h3>
                    <p>Create a circular progress indicator that animates smoothly.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Circular progress ring using SVG or transforms</li>
                        <li>Animate from 0 to target percentage</li>
                        <li>Display percentage text in center</li>
                        <li>Smooth timing animation with ease-out</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import React, { useRef, useEffect, useState } from 'react';
import { Animated, View, Text, StyleSheet, Easing } from 'react-native';
import Svg, { Circle } from 'react-native-svg';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface ProgressRingProps {
  progress: number; // 0 to 100
  size?: number;
  strokeWidth?: number;
  color?: string;
}

function ProgressRing({
  progress,
  size = 120,
  strokeWidth = 10,
  color = '#007AFF',
}: ProgressRingProps) {
  const animatedProgress = useRef(new Animated.Value(0)).current;
  const [displayProgress, setDisplayProgress] = useState(0);
  
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  
  useEffect(() => {
    // Animate to new progress value
    Animated.timing(animatedProgress, {
      toValue: progress,
      duration: 1000,
      easing: Easing.out(Easing.ease),
      useNativeDriver: false, // Can't use native driver for strokeDashoffset
    }).start();
    
    // Update display value with listener
    const listenerId = animatedProgress.addListener(({ value }) => {
      setDisplayProgress(Math.round(value));
    });
    
    return () => {
      animatedProgress.removeListener(listenerId);
    };
  }, [progress]);
  
  const strokeDashoffset = animatedProgress.interpolate({
    inputRange: [0, 100],
    outputRange: [circumference, 0],
  });
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;Svg width={size} height={size}&gt;
        {/* Background circle */}
        &lt;Circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="#e0e0e0"
          strokeWidth={strokeWidth}
          fill="none"
        /&gt;
        
        {/* Animated progress circle */}
        &lt;AnimatedCircle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke={color}
          strokeWidth={strokeWidth}
          fill="none"
          strokeLinecap="round"
          strokeDasharray={circumference}
          strokeDashoffset={strokeDashoffset}
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        /&gt;
      &lt;/Svg&gt;
      
      {/* Center text */}
      &lt;View style={[styles.textContainer, { width: size, height: size }]}&gt;
        &lt;Text style={styles.progressText}&gt;{displayProgress}%&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

// Usage example
function ProgressDemo() {
  const [progress, setProgress] = useState(0);
  
  useEffect(() => {
    // Simulate progress
    const interval = setInterval(() => {
      setProgress(p => {
        if (p >= 100) {
          clearInterval(interval);
          return 100;
        }
        return p + 10;
      });
    }, 500);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    &lt;View style={styles.demo}&gt;
      &lt;ProgressRing progress={progress} size={150} /&gt;
      &lt;Text style={styles.label}&gt;Loading...&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'relative',
  },
  textContainer: {
    position: 'absolute',
    justifyContent: 'center',
    alignItems: 'center',
  },
  progressText: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  demo: {
    alignItems: 'center',
    padding: 40,
  },
  label: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
});</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>Animation is a powerful tool for creating engaging, intuitive mobile experiences. React Native's Animated API provides everything you need to build smooth, performant animations that run on the native thread.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>Performance matters:</strong> Use <code>useNativeDriver: true</code> whenever possible to keep animations on the UI thread</li>
                        <li><strong>Animated values:</strong> Use <code>Animated.Value</code> for single values, <code>Animated.ValueXY</code> for 2D positions</li>
                        <li><strong>Interpolation:</strong> Map animated values to different output ranges including strings for rotation and colors</li>
                        <li><strong>Animation types:</strong>
                            <ul>
                                <li><code>timing</code> ‚Äî Fixed duration, great for fades and timed sequences</li>
                                <li><code>spring</code> ‚Äî Physics-based, ideal for interactive UI</li>
                                <li><code>decay</code> ‚Äî Momentum-based, perfect for flick gestures</li>
                            </ul>
                        </li>
                        <li><strong>Composition:</strong> Use <code>parallel</code>, <code>sequence</code>, and <code>stagger</code> to combine animations</li>
                        <li><strong>Easing:</strong> Choose appropriate easing functions for natural-feeling motion</li>
                    </ul>
                </div>

                <h3>Animation Decision Flowchart</h3>

                <pre class="mermaid">
flowchart TD
    A[New Animation Needed] --> B{Property to animate?}
    
    B -->|transform, opacity| C[useNativeDriver: true ‚úÖ]
    B -->|width, height, color| D[useNativeDriver: false ‚ö†Ô∏è]
    
    C --> E{Type of animation?}
    D --> F[Consider Reanimated]
    
    E -->|Fixed duration| G[Animated.timing]
    E -->|Interactive/responsive| H[Animated.spring]
    E -->|Momentum-based| I[Animated.decay]
    
    G --> J[Choose easing function]
    H --> K[Tune tension/friction]
    I --> L[Set deceleration]
    
    style C fill:#e8f5e9
    style D fill:#fff3e0
    style F fill:#e3f2fd
</pre>

                <p>In the next lesson, we'll explore React Native Reanimated‚Äîa more powerful animation library that overcomes many limitations of the built-in Animated API and enables even more complex, performant animations.</p>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m08_l07_file_system.html" class="prev-link">‚Üê Previous: File System</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m09_l02_react_native_reanimated.html" class="next-link">Next: React Native Reanimated ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
