<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn TypeScript essentials for React Native - typing components, props, state, events, and common patterns">
    <meta name="author" content="React Native Course">
    <title>TypeScript Essentials - React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#e3f2fd',
                primaryTextColor: '#1565c0',
                primaryBorderColor: '#1976d2',
                lineColor: '#64b5f6'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN & Expo Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 2</a></li>
            <li aria-current="page">Lesson 2.5: TypeScript Essentials</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üî∑ TypeScript Essentials</h1>
                <p class="lead" style="text-align: center; font-size: 1.1rem; margin-bottom: 2rem;">
                    The TypeScript patterns you'll use every day in React Native
                </p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Type component props and children correctly</li>
                        <li>Use TypeScript with useState, useRef, and other hooks</li>
                        <li>Type event handlers and callbacks</li>
                        <li>Work with React Native's built-in types</li>
                        <li>Apply common TypeScript patterns in mobile development</li>
                    </ul>
                    <p><strong>‚è±Ô∏è Estimated Time:</strong> 35-45 minutes</p>
                </div>
            </header>

            <!-- Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--secondary-color); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    üìë In This Lesson
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#why-typescript">Why TypeScript in React Native</a></li>
                        <li><a href="#props">Typing Props</a></li>
                        <li><a href="#hooks">Typing Hooks</a></li>
                        <li><a href="#events">Typing Events</a></li>
                        <li><a href="#rn-types">React Native Built-in Types</a></li>
                        <li><a href="#patterns">Common Patterns</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Why TypeScript -->
            <section id="why-typescript" class="lesson-section">
                <h2>Why TypeScript in React Native</h2>
                
                <p>TypeScript isn't just a nice-to-have in React Native ‚Äî it's the recommended default. When you create an Expo project, it comes with TypeScript pre-configured. Here's why that matters:</p>

                <!-- SVG: TypeScript Benefits -->
                <svg viewBox="0 0 800 280" style="width: 100%; max-width: 800px; margin: 2rem auto; display: block;">
                    <!-- Background -->
                    <rect x="0" y="0" width="800" height="280" fill="#f8f9fa" rx="10"/>
                    
                    <!-- Title -->
                    <text x="400" y="35" text-anchor="middle" font-weight="bold" font-size="18" fill="#333">Why TypeScript Matters for Mobile</text>
                    
                    <!-- Benefit 1 -->
                    <rect x="30" y="60" width="230" height="100" rx="8" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
                    <text x="145" y="90" text-anchor="middle" font-size="24">üêõ</text>
                    <text x="145" y="115" text-anchor="middle" font-weight="bold" font-size="14" fill="#1565c0">Catch Bugs Early</text>
                    <text x="145" y="135" text-anchor="middle" font-size="11" fill="#666">Errors at compile time,</text>
                    <text x="145" y="150" text-anchor="middle" font-size="11" fill="#666">not runtime crashes</text>
                    
                    <!-- Benefit 2 -->
                    <rect x="285" y="60" width="230" height="100" rx="8" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                    <text x="400" y="90" text-anchor="middle" font-size="24">üí°</text>
                    <text x="400" y="115" text-anchor="middle" font-weight="bold" font-size="14" fill="#2e7d32">Better IntelliSense</text>
                    <text x="400" y="135" text-anchor="middle" font-size="11" fill="#666">Autocomplete props,</text>
                    <text x="400" y="150" text-anchor="middle" font-size="11" fill="#666">methods, and more</text>
                    
                    <!-- Benefit 3 -->
                    <rect x="540" y="60" width="230" height="100" rx="8" fill="#fff3e0" stroke="#ff9800" stroke-width="2"/>
                    <text x="655" y="90" text-anchor="middle" font-size="24">üìñ</text>
                    <text x="655" y="115" text-anchor="middle" font-weight="bold" font-size="14" fill="#e65100">Self-Documenting</text>
                    <text x="655" y="135" text-anchor="middle" font-size="11" fill="#666">Types explain what</text>
                    <text x="655" y="150" text-anchor="middle" font-size="11" fill="#666">your code expects</text>
                    
                    <!-- Bottom row -->
                    <rect x="155" y="175" width="230" height="90" rx="8" fill="#fce4ec" stroke="#e91e63" stroke-width="2"/>
                    <text x="270" y="205" text-anchor="middle" font-size="24">üîÑ</text>
                    <text x="270" y="230" text-anchor="middle" font-weight="bold" font-size="14" fill="#c2185b">Safer Refactoring</text>
                    <text x="270" y="250" text-anchor="middle" font-size="11" fill="#666">Change code confidently</text>
                    
                    <rect x="415" y="175" width="230" height="90" rx="8" fill="#f3e5f5" stroke="#9c27b0" stroke-width="2"/>
                    <text x="530" y="205" text-anchor="middle" font-size="24">ü§ù</text>
                    <text x="530" y="230" text-anchor="middle" font-weight="bold" font-size="14" fill="#7b1fa2">Team Collaboration</text>
                    <text x="530" y="250" text-anchor="middle" font-size="11" fill="#666">Clear contracts between code</text>
                </svg>
                <p class="caption"><em>TypeScript provides safety nets that are especially valuable in mobile development</em></p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üì± Mobile-Specific Benefit</h4>
                    <p style="color: white;">In mobile apps, runtime crashes are worse than on web ‚Äî users might uninstall your app! TypeScript catches many errors before they reach users' devices.</p>
                </div>

                <h3>TypeScript Refresher</h3>

                <p>If you're rusty on TypeScript basics, here's a quick refresher of the essentials:</p>

                <pre><code class="language-typescript">// Basic types
let name: string = "John";
let age: number = 30;
let isActive: boolean = true;
let items: string[] = ["a", "b", "c"];

// Object types
type User = {
  id: number;
  name: string;
  email?: string;  // Optional property
};

// Interface (similar to type, can be extended)
interface Product {
  id: number;
  title: string;
  price: number;
}

// Union types
type Status = "loading" | "success" | "error";

// Function types
function greet(name: string): string {
  return `Hello, ${name}!`;
}

// Arrow function with types
const add = (a: number, b: number): number => a + b;

// Generics
function getFirst&lt;T&gt;(items: T[]): T | undefined {
  return items[0];
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Type vs Interface</h4>
                    <p>In React Native, you can use either. The convention is:</p>
                    <ul>
                        <li><strong>type</strong> ‚Äî For props, unions, and simpler shapes</li>
                        <li><strong>interface</strong> ‚Äî When you need to extend or implement</li>
                    </ul>
                    <p>We'll use <code>type</code> for props in this course, as it's more common in the React community.</p>
                </div>

            </section>

            <!-- Section 2: Typing Props -->
            <section id="props" class="lesson-section">
                <h2>Typing Props</h2>

                <p>Props are the most common thing you'll type in React Native. Let's look at the patterns you'll use constantly.</p>

                <h3>Basic Props</h3>

                <pre><code class="language-typescript">import { Text, View } from 'react-native';

// Define the props type
type GreetingProps = {
  name: string;
  age: number;
};

// Use it in the component
function Greeting({ name, age }: GreetingProps) {
  return (
    &lt;View&gt;
      &lt;Text&gt;Hello, {name}!&lt;/Text&gt;
      &lt;Text&gt;You are {age} years old.&lt;/Text&gt;
    &lt;/View&gt;
  );
}

// Usage - TypeScript ensures correct props
&lt;Greeting name="Sarah" age={28} /&gt;  // ‚úÖ Works
&lt;Greeting name="Sarah" /&gt;           // ‚ùå Error: age is required
&lt;Greeting name={123} age={28} /&gt;    // ‚ùå Error: name must be string</code></pre>

                <h3>Optional Props</h3>

                <pre><code class="language-typescript">type ButtonProps = {
  title: string;
  onPress: () => void;
  variant?: "primary" | "secondary";  // Optional with union type
  disabled?: boolean;                  // Optional boolean
};

function Button({ 
  title, 
  onPress, 
  variant = "primary",  // Default value
  disabled = false 
}: ButtonProps) {
  return (
    &lt;Pressable onPress={onPress} disabled={disabled}&gt;
      &lt;Text&gt;{title}&lt;/Text&gt;
    &lt;/Pressable&gt;
  );
}

// All valid:
&lt;Button title="Submit" onPress={() =&gt; {}} /&gt;
&lt;Button title="Cancel" onPress={() =&gt; {}} variant="secondary" /&gt;
&lt;Button title="Save" onPress={() =&gt; {}} disabled /&gt;</code></pre>

                <h3>Children Props</h3>

                <pre><code class="language-typescript">import { ReactNode } from 'react';
import { View, ViewStyle } from 'react-native';

type CardProps = {
  children: ReactNode;  // Any valid React content
  style?: ViewStyle;
};

function Card({ children, style }: CardProps) {
  return (
    &lt;View style={[styles.card, style]}&gt;
      {children}
    &lt;/View&gt;
  );
}

// Usage
&lt;Card&gt;
  &lt;Text&gt;I'm inside a card!&lt;/Text&gt;
&lt;/Card&gt;

&lt;Card style={{ marginTop: 20 }}&gt;
  &lt;Text&gt;Title&lt;/Text&gt;
  &lt;Text&gt;Description&lt;/Text&gt;
&lt;/Card&gt;</code></pre>

                <h3>Props with Functions</h3>

                <pre><code class="language-typescript">type SearchInputProps = {
  value: string;
  onChangeText: (text: string) => void;
  onSubmit?: () => void;
  placeholder?: string;
};

function SearchInput({ 
  value, 
  onChangeText, 
  onSubmit,
  placeholder = "Search..." 
}: SearchInputProps) {
  return (
    &lt;TextInput
      value={value}
      onChangeText={onChangeText}
      onSubmitEditing={onSubmit}
      placeholder={placeholder}
    /&gt;
  );
}</code></pre>

                <h3>Extending Native Component Props</h3>

                <p>Often you want to create a wrapper that accepts all the props of a native component plus your own:</p>

                <pre><code class="language-typescript">import { Pressable, PressableProps, Text, StyleSheet } from 'react-native';

// Extend PressableProps and add our own
type CustomButtonProps = PressableProps & {
  title: string;
  variant?: 'primary' | 'secondary';
};

function CustomButton({ 
  title, 
  variant = 'primary', 
  style,
  ...rest  // All other Pressable props
}: CustomButtonProps) {
  return (
    &lt;Pressable 
      style={[
        styles.button, 
        variant === 'secondary' && styles.secondary,
        style
      ]}
      {...rest}
    &gt;
      &lt;Text style={styles.text}&gt;{title}&lt;/Text&gt;
    &lt;/Pressable&gt;
  );
}

// Now you get all Pressable props + title + variant
&lt;CustomButton 
  title="Press Me" 
  variant="secondary"
  onPress={() => console.log('Pressed!')}
  disabled={isLoading}
  accessibilityLabel="Custom button"
/&gt;</code></pre>

            </section>

            <!-- Section 3: Typing Hooks -->
            <section id="hooks" class="lesson-section">
                <h2>Typing Hooks</h2>

                <p>Hooks are already typed in React, but you often need to provide type parameters for full type safety.</p>

                <h3>useState</h3>

                <pre><code class="language-typescript">import { useState } from 'react';

// Inferred types (simple cases)
const [count, setCount] = useState(0);           // number
const [name, setName] = useState('');            // string
const [isOpen, setIsOpen] = useState(false);     // boolean

// Explicit types (when initial value doesn't tell the whole story)
const [user, setUser] = useState&lt;User | null&gt;(null);

type User = {
  id: string;
  name: string;
  email: string;
};

// Now user is typed as User | null
// setUser expects User | null

// Array state
const [items, setItems] = useState&lt;string[]&gt;([]);
const [todos, setTodos] = useState&lt;Todo[]&gt;([]);

// Union state
type Status = 'idle' | 'loading' | 'success' | 'error';
const [status, setStatus] = useState&lt;Status&gt;('idle');</code></pre>

                <h3>useRef</h3>

                <pre><code class="language-typescript">import { useRef } from 'react';
import { TextInput, View } from 'react-native';

// Ref to a React Native component
const inputRef = useRef&lt;TextInput&gt;(null);

// Usage
&lt;TextInput ref={inputRef} /&gt;

// Later: focus the input
inputRef.current?.focus();

// Ref for mutable values (not DOM elements)
const timerRef = useRef&lt;NodeJS.Timeout | null&gt;(null);

// Usage
timerRef.current = setTimeout(() =&gt; {
  console.log('Timer fired!');
}, 1000);

// Cleanup
if (timerRef.current) {
  clearTimeout(timerRef.current);
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Ref Types Tip</h4>
                    <p>For component refs, use the component type directly: <code>useRef&lt;TextInput&gt;(null)</code></p>
                    <p>For mutable values, use the value type: <code>useRef&lt;number&gt;(0)</code></p>
                </div>

                <h3>useEffect</h3>

                <pre><code class="language-typescript">import { useEffect, useState } from 'react';

type User = {
  id: string;
  name: string;
};

function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);

  useEffect(() => {
    // Async function inside useEffect
    async function fetchUser() {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        const data: User = await response.json();
        setUser(data);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Unknown error'));
      } finally {
        setLoading(false);
      }
    }

    fetchUser();

    // Cleanup function (optional)
    return () => {
      // Cancel requests, clear timers, etc.
    };
  }, [userId]);  // Dependency array

  // ...
}</code></pre>

                <h3>useCallback and useMemo</h3>

                <pre><code class="language-typescript">import { useCallback, useMemo } from 'react';

type Item = {
  id: string;
  name: string;
  price: number;
};

function ShoppingCart({ items }: { items: Item[] }) {
  // useMemo: memoize computed values
  const total = useMemo((): number => {
    return items.reduce((sum, item) => sum + item.price, 0);
  }, [items]);

  // useCallback: memoize functions
  const handleRemove = useCallback((id: string): void => {
    console.log('Remove item:', id);
    // Remove logic...
  }, []);

  // With event parameter
  const handlePress = useCallback((item: Item): void => {
    console.log('Pressed:', item.name);
  }, []);

  return (
    &lt;View&gt;
      {items.map(item =&gt; (
        &lt;Pressable key={item.id} onPress={() =&gt; handlePress(item)}&gt;
          &lt;Text&gt;{item.name}&lt;/Text&gt;
        &lt;/Pressable&gt;
      ))}
      &lt;Text&gt;Total: ${total}&lt;/Text&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>useReducer</h3>

                <pre><code class="language-typescript">import { useReducer } from 'react';

// State type
type CounterState = {
  count: number;
  step: number;
};

// Action types (discriminated union)
type CounterAction =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset' }
  | { type: 'setStep'; payload: number };

// Reducer function
function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + state.step };
    case 'decrement':
      return { ...state, count: state.count - state.step };
    case 'reset':
      return { ...state, count: 0 };
    case 'setStep':
      return { ...state, step: action.payload };
    default:
      return state;
  }
}

// Usage in component
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0, step: 1 });

  return (
    &lt;View&gt;
      &lt;Text&gt;Count: {state.count}&lt;/Text&gt;
      &lt;Button title="+" onPress={() =&gt; dispatch({ type: 'increment' })} /&gt;
      &lt;Button title="-" onPress={() =&gt; dispatch({ type: 'decrement' })} /&gt;
      &lt;Button title="Reset" onPress={() =&gt; dispatch({ type: 'reset' })} /&gt;
    &lt;/View&gt;
  );
}</code></pre>

            </section>

            <!-- Section 4: Typing Events -->
            <section id="events" class="lesson-section">
                <h2>Typing Events</h2>

                <p>React Native events have their own types. Here are the most common ones you'll encounter:</p>

                <h3>Common Event Types</h3>

                <pre><code class="language-typescript">import { 
  GestureResponderEvent,
  NativeSyntheticEvent,
  TextInputChangeEventData,
  TextInputSubmitEditingEventData,
  LayoutChangeEvent,
  NativeScrollEvent
} from 'react-native';

// Pressable / TouchableOpacity events
function handlePress(event: GestureResponderEvent) {
  console.log('Pressed at:', event.nativeEvent.locationX);
}

// TextInput change event
function handleChange(event: NativeSyntheticEvent&lt;TextInputChangeEventData&gt;) {
  console.log('Text:', event.nativeEvent.text);
}

// TextInput submit event
function handleSubmit(event: NativeSyntheticEvent&lt;TextInputSubmitEditingEventData&gt;) {
  console.log('Submitted:', event.nativeEvent.text);
}

// Layout event
function handleLayout(event: LayoutChangeEvent) {
  const { width, height, x, y } = event.nativeEvent.layout;
  console.log('Layout:', { width, height, x, y });
}

// Scroll event
function handleScroll(event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) {
  const { contentOffset, contentSize } = event.nativeEvent;
  console.log('Scroll position:', contentOffset.y);
}</code></pre>

                <h3>Practical Examples</h3>

                <pre><code class="language-typescript">import { 
  TextInput, 
  Pressable, 
  ScrollView, 
  View,
  Text,
  GestureResponderEvent,
  NativeSyntheticEvent,
  NativeScrollEvent,
  LayoutChangeEvent
} from 'react-native';

function EventExamples() {
  // Most common: onPress just needs the handler
  const handlePress = (event: GestureResponderEvent) =&gt; {
    // Access native event details if needed
    console.log('Press location:', event.nativeEvent.pageX);
  };

  // TextInput: onChangeText gives you the string directly!
  const handleChangeText = (text: string) =&gt; {
    console.log('Text changed:', text);
  };

  // Scroll handling
  const handleScroll = (event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) =&gt; {
    const offsetY = event.nativeEvent.contentOffset.y;
    console.log('Scrolled to:', offsetY);
  };

  // Layout measurement
  const handleLayout = (event: LayoutChangeEvent) =&gt; {
    const { width, height } = event.nativeEvent.layout;
    console.log('Component size:', width, height);
  };

  return (
    &lt;View onLayout={handleLayout}&gt;
      &lt;Pressable onPress={handlePress}&gt;
        &lt;Text&gt;Press me&lt;/Text&gt;
      &lt;/Pressable&gt;
      
      &lt;TextInput onChangeText={handleChangeText} /&gt;
      
      &lt;ScrollView onScroll={handleScroll}&gt;
        {/* Content */}
      &lt;/ScrollView&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Good News</h4>
                    <p>For the most common cases, you don't need to type events manually:</p>
                    <ul>
                        <li><code>onPress={() =&gt; doSomething()}</code> ‚Äî No typing needed</li>
                        <li><code>onChangeText={(text) =&gt; setText(text)}</code> ‚Äî text is inferred as string</li>
                    </ul>
                    <p>You only need explicit event types when you need access to the full event object.</p>
                </div>

            </section>

            <!-- Section 5: React Native Built-in Types -->
            <section id="rn-types" class="lesson-section">
                <h2>React Native Built-in Types</h2>

                <p>React Native exports many useful types. Here are the ones you'll use most often:</p>

                <h3>Style Types</h3>

                <pre><code class="language-typescript">import { 
  StyleSheet,
  ViewStyle, 
  TextStyle, 
  ImageStyle,
  StyleProp
} from 'react-native';

// Individual style types
const containerStyle: ViewStyle = {
  flex: 1,
  backgroundColor: '#fff',
  padding: 16,
};

const titleStyle: TextStyle = {
  fontSize: 24,
  fontWeight: 'bold',
  color: '#333',
};

const imageStyle: ImageStyle = {
  width: 100,
  height: 100,
  borderRadius: 50,
};

// For component props that accept styles
type CardProps = {
  style?: StyleProp&lt;ViewStyle&gt;;     // Accepts style prop
  titleStyle?: StyleProp&lt;TextStyle&gt;;
};

function Card({ style, titleStyle }: CardProps) {
  return (
    &lt;View style={[styles.card, style]}&gt;
      &lt;Text style={[styles.title, titleStyle]}&gt;Card&lt;/Text&gt;
    &lt;/View&gt;
  );
}

// StyleSheet.create returns typed styles
const styles = StyleSheet.create({
  card: {
    padding: 16,
    borderRadius: 8,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
  },
});</code></pre>

                <h3>Component Props Types</h3>

                <pre><code class="language-typescript">import {
  ViewProps,
  TextProps,
  ImageProps,
  PressableProps,
  TextInputProps,
  ScrollViewProps,
  FlatListProps,
} from 'react-native';

// Extend existing component props
type CustomViewProps = ViewProps & {
  variant?: 'card' | 'container';
};

// FlatList needs a type parameter for the data
type Todo = { id: string; title: string };

const todoListProps: FlatListProps&lt;Todo&gt; = {
  data: [],
  renderItem: ({ item }) =&gt; &lt;Text&gt;{item.title}&lt;/Text&gt;,
  keyExtractor: (item) =&gt; item.id,
};</code></pre>

                <h3>Dimension and Layout Types</h3>

                <pre><code class="language-typescript">import { 
  Dimensions,
  ScaledSize,
  LayoutRectangle,
  LayoutChangeEvent
} from 'react-native';

// Get screen dimensions
const { width, height }: ScaledSize = Dimensions.get('window');

// Layout from onLayout event
function handleLayout(event: LayoutChangeEvent) {
  const layout: LayoutRectangle = event.nativeEvent.layout;
  console.log(layout.width, layout.height, layout.x, layout.y);
}

// Listen to dimension changes
import { useWindowDimensions } from 'react-native';

function ResponsiveComponent() {
  const { width, height } = useWindowDimensions();
  
  const isLandscape = width > height;
  
  return (
    &lt;View style={{ flexDirection: isLandscape ? 'row' : 'column' }}&gt;
      {/* Content */}
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Platform Types</h3>

                <pre><code class="language-typescript">import { Platform } from 'react-native';

// Platform.OS is typed as 'ios' | 'android' | 'windows' | 'macos' | 'web'
const isIOS = Platform.OS === 'ios';
const isAndroid = Platform.OS === 'android';

// Platform.select is generic
const styles = StyleSheet.create({
  container: {
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 4,
      },
      default: {},
    }),
  },
});</code></pre>

            </section>

            <!-- Section 6: Common Patterns -->
            <section id="patterns" class="lesson-section">
                <h2>Common Patterns</h2>

                <p>Let's look at TypeScript patterns you'll use frequently in React Native development.</p>

                <h3>API Response Types</h3>

                <pre><code class="language-typescript">// Define your API response types
type ApiResponse&lt;T&gt; = {
  data: T;
  status: number;
  message: string;
};

type User = {
  id: string;
  name: string;
  email: string;
  avatar?: string;
};

type Post = {
  id: string;
  title: string;
  content: string;
  authorId: string;
  createdAt: string;
};

// Fetch with types
async function fetchUser(id: string): Promise&lt;User&gt; {
  const response = await fetch(`/api/users/${id}`);
  const json: ApiResponse&lt;User&gt; = await response.json();
  return json.data;
}

async function fetchPosts(): Promise&lt;Post[]&gt; {
  const response = await fetch('/api/posts');
  const json: ApiResponse&lt;Post[]&gt; = await response.json();
  return json.data;
}</code></pre>

                <h3>Navigation Types (Expo Router)</h3>

                <pre><code class="language-typescript">// With Expo Router's typed routes
import { Link, router } from 'expo-router';

// Navigation is type-safe when typedRoutes is enabled in app.json
&lt;Link href="/profile"&gt;Go to Profile&lt;/Link&gt;
&lt;Link href="/user/123"&gt;View User&lt;/Link&gt;

// Programmatic navigation
router.push('/settings');
router.replace('/login');

// With parameters
router.push({
  pathname: '/user/[id]',
  params: { id: '123' }
});</code></pre>

                <h3>Discriminated Unions for State</h3>

                <pre><code class="language-typescript">// Instead of multiple boolean flags, use discriminated unions
type LoadingState = { status: 'loading' };
type SuccessState&lt;T&gt; = { status: 'success'; data: T };
type ErrorState = { status: 'error'; error: Error };

type AsyncState&lt;T&gt; = LoadingState | SuccessState&lt;T&gt; | ErrorState;

function UserProfile() {
  const [state, setState] = useState&lt;AsyncState&lt;User&gt;&gt;({ 
    status: 'loading' 
  });

  // TypeScript knows the shape based on status
  if (state.status === 'loading') {
    return &lt;ActivityIndicator /&gt;;
  }

  if (state.status === 'error') {
    return &lt;Text&gt;Error: {state.error.message}&lt;/Text&gt;;
  }

  // TypeScript knows state.data exists here
  return &lt;Text&gt;{state.data.name}&lt;/Text&gt;;
}</code></pre>

                <h3>Generic Components</h3>

                <pre><code class="language-typescript">import { FlatList, Text, Pressable } from 'react-native';

// Generic list component
type ListProps&lt;T&gt; = {
  items: T[];
  renderItem: (item: T) =&gt; React.ReactNode;
  keyExtractor: (item: T) =&gt; string;
  onItemPress?: (item: T) =&gt; void;
};

function GenericList&lt;T&gt;({ 
  items, 
  renderItem, 
  keyExtractor,
  onItemPress 
}: ListProps&lt;T&gt;) {
  return (
    &lt;FlatList
      data={items}
      keyExtractor={keyExtractor}
      renderItem={({ item }) =&gt; (
        &lt;Pressable onPress={() =&gt; onItemPress?.(item)}&gt;
          {renderItem(item)}
        &lt;/Pressable&gt;
      )}
    /&gt;
  );
}

// Usage - TypeScript infers T from items
&lt;GenericList
  items={users}
  renderItem={(user) =&gt; &lt;Text&gt;{user.name}&lt;/Text&gt;}
  keyExtractor={(user) =&gt; user.id}
  onItemPress={(user) =&gt; console.log(user.email)}
/&gt;</code></pre>

                <h3>Type Assertions (When Needed)</h3>

                <pre><code class="language-typescript">// Sometimes you know more than TypeScript
const data = JSON.parse(jsonString) as User;

// For event targets (rare in RN, common in web)
const target = event.target as TextInput;

// Non-null assertion (use sparingly!)
const value = maybeNull!;  // Tells TS "I know this isn't null"

// Better: use optional chaining and nullish coalescing
const value = maybeNull ?? defaultValue;
const result = obj?.property?.nested;</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Avoid Overusing Type Assertions</h4>
                    <p>Type assertions (<code>as</code>) and non-null assertions (<code>!</code>) bypass TypeScript's safety checks. Prefer proper typing, optional chaining (<code>?.</code>), and nullish coalescing (<code>??</code>) instead.</p>
                </div>

            </section>

            <!-- Section 7: Summary -->
            <section id="summary" class="lesson-section">
                <h2>Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Props:</strong> Use <code>type</code> to define prop shapes, use <code>?</code> for optional props</li>
                        <li><strong>Hooks:</strong> Provide type parameters when initial value doesn't tell the full story</li>
                        <li><strong>Events:</strong> Most events are auto-typed; explicit types only when accessing the full event</li>
                        <li><strong>Styles:</strong> Use <code>ViewStyle</code>, <code>TextStyle</code>, <code>ImageStyle</code> and <code>StyleProp</code></li>
                        <li><strong>Extending:</strong> Combine native props with your own using <code>&</code> intersection</li>
                        <li><strong>State:</strong> Use discriminated unions for complex state instead of multiple booleans</li>
                    </ul>
                </div>

                <h3>Quick Reference</h3>

                <pre><code class="language-typescript">// Props
type Props = { name: string; age?: number };

// State
const [user, setUser] = useState&lt;User | null&gt;(null);

// Ref
const inputRef = useRef&lt;TextInput&gt;(null);

// Style props
type CardProps = { style?: StyleProp&lt;ViewStyle&gt; };

// Extend native props
type ButtonProps = PressableProps & { title: string };

// Event handler
const handlePress = (event: GestureResponderEvent) =&gt; {};

// API types
type Response&lt;T&gt; = { data: T; status: number };</code></pre>

                <h3>üéâ Module 2 Complete!</h3>
                <p>You've finished the Development Environment module! You now have:</p>
                <ul>
                    <li>‚úÖ Your tools installed and configured</li>
                    <li>‚úÖ A project created and running</li>
                    <li>‚úÖ An understanding of the development workflow</li>
                    <li>‚úÖ TypeScript knowledge for React Native</li>
                </ul>

                <p>In Module 3, we dive into the Core Components ‚Äî the building blocks of every React Native UI.</p>

                <!-- Module Completion Card -->
                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üöÄ Ready to Build!</h3>
                    <p style="color: white;">Your environment is set up, your TypeScript is sharp, and you know the workflow. Time to learn the components that make up every React Native app!</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="m02_l04_development_workflow.html" class="prev-lesson">‚Üê Previous: Development Workflow</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="m03_l01_view_and_flexbox_fundamentals.html" class="next-lesson">Next: Module 3 - View & Flexbox ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-color); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2025 React Native & Expo Mastery Course. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Building the next generation of mobile developers.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
