<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn to use device sensors and haptic feedback in React Native with Expo">
    <meta name="author" content="React Native & Expo Course">
    <title>Sensors and Haptics | Module 8: Native Features and Device APIs | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m08_l01_permissions.html">Module 8</a> &gt;
            <span>Lesson 8.5</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 8: Native Features and Device APIs</p>
                <h1>Sensors and Haptics</h1>
                <p class="lesson-subtitle">Motion sensors, device orientation, and tactile feedback</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Read accelerometer data for motion detection</li>
                    <li>Use the gyroscope for rotation tracking</li>
                    <li>Detect device orientation changes</li>
                    <li>Implement shake detection</li>
                    <li>Use the pedometer for step counting</li>
                    <li>Add haptic feedback to enhance user experience</li>
                    <li>Build interactive experiences with sensor data</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#sensor-overview">Sensor Overview</a></li>
                        <li><a href="#accelerometer">Accelerometer</a></li>
                        <li><a href="#gyroscope">Gyroscope</a></li>
                        <li><a href="#device-motion">Device Motion</a></li>
                        <li><a href="#pedometer">Pedometer</a></li>
                        <li><a href="#shake-detection">Shake Detection</a></li>
                        <li><a href="#haptics">Haptic Feedback</a></li>
                        <li><a href="#practical-examples">Practical Examples</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- Sensor Overview -->
            <section id="sensor-overview">
                <h2>Sensor Overview</h2>

                <p>Modern smartphones contain numerous sensors that enable rich, interactive experiences. Expo provides access to these through the <code>expo-sensors</code> package.</p>

                <h3>Installation</h3>

                <pre><code># Install expo-sensors and expo-haptics
npx expo install expo-sensors expo-haptics</code></pre>

                <h3>Available Sensors</h3>

                <!-- SVG: Sensor Types -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 280" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="280" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="350" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Device Sensors</text>
                        
                        <!-- Accelerometer -->
                        <rect x="30" y="50" width="130" height="90" fill="#4CAF50" stroke="#388E3C" stroke-width="2" rx="8"/>
                        <text x="95" y="80" text-anchor="middle" font-size="24">üìê</text>
                        <text x="95" y="105" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Accelerometer</text>
                        <text x="95" y="125" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Linear acceleration</text>
                        
                        <!-- Gyroscope -->
                        <rect x="175" y="50" width="130" height="90" fill="#2196F3" stroke="#1976D2" stroke-width="2" rx="8"/>
                        <text x="240" y="80" text-anchor="middle" font-size="24">üîÑ</text>
                        <text x="240" y="105" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Gyroscope</text>
                        <text x="240" y="125" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Rotation rate</text>
                        
                        <!-- Magnetometer -->
                        <rect x="320" y="50" width="130" height="90" fill="#FF9800" stroke="#F57C00" stroke-width="2" rx="8"/>
                        <text x="385" y="80" text-anchor="middle" font-size="24">üß≠</text>
                        <text x="385" y="105" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Magnetometer</text>
                        <text x="385" y="125" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Compass heading</text>
                        
                        <!-- Barometer -->
                        <rect x="465" y="50" width="130" height="90" fill="#9C27B0" stroke="#7B1FA2" stroke-width="2" rx="8"/>
                        <text x="530" y="80" text-anchor="middle" font-size="24">üå°Ô∏è</text>
                        <text x="530" y="105" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Barometer</text>
                        <text x="530" y="125" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Air pressure</text>
                        
                        <!-- Device Motion -->
                        <rect x="100" y="160" width="150" height="90" fill="#667eea" stroke="#5a67d8" stroke-width="2" rx="8"/>
                        <text x="175" y="190" text-anchor="middle" font-size="24">üì±</text>
                        <text x="175" y="215" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Device Motion</text>
                        <text x="175" y="235" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Combined sensor data</text>
                        
                        <!-- Pedometer -->
                        <rect x="280" y="160" width="150" height="90" fill="#00BCD4" stroke="#0097A7" stroke-width="2" rx="8"/>
                        <text x="355" y="190" text-anchor="middle" font-size="24">üö∂</text>
                        <text x="355" y="215" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Pedometer</text>
                        <text x="355" y="235" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Step counting</text>
                        
                        <!-- Light Sensor -->
                        <rect x="460" y="160" width="150" height="90" fill="#FFC107" stroke="#FFA000" stroke-width="2" rx="8"/>
                        <text x="535" y="190" text-anchor="middle" font-size="24">üí°</text>
                        <text x="535" y="215" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Light Sensor</text>
                        <text x="535" y="235" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Ambient light (Android)</text>
                    </svg>
                </div>

                <div class="card">
                    <h4>üì± Sensor Availability</h4>
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f5f5f5;">
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Sensor</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">iOS</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Android</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Permission</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Accelerometer</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">iOS: Motion</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Gyroscope</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">iOS: Motion</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Magnetometer</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">None</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Barometer</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ (if available)</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">None</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Pedometer</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">iOS: Motion, Android: Activity</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Light Sensor</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚ùå</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ</td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">None</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Accelerometer -->
            <section id="accelerometer">
                <h2>Accelerometer</h2>

                <p>The accelerometer measures the device's acceleration in three dimensions (x, y, z), including the effect of gravity. It's useful for detecting motion, orientation, and gestures.</p>

                <h3>Understanding Accelerometer Data</h3>

                <!-- SVG: Accelerometer Axes -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 400 300" style="max-width: 400px; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="400" height="300" fill="#f8f9fa"/>
                        
                        <!-- Phone outline -->
                        <rect x="140" y="80" width="120" height="200" fill="#333" rx="15"/>
                        <rect x="148" y="95" width="104" height="170" fill="#e0e0e0" rx="5"/>
                        
                        <!-- Screen content -->
                        <text x="200" y="185" text-anchor="middle" font-size="40">üì±</text>
                        
                        <!-- X axis (right) -->
                        <path d="M260,180 L340,180" stroke="#f44336" stroke-width="3" marker-end="url(#arrowRed)"/>
                        <text x="350" y="185" font-size="14" font-weight="bold" fill="#f44336">X</text>
                        <text x="320" y="165" font-size="10" fill="#f44336">Right +</text>
                        
                        <!-- Y axis (up) -->
                        <path d="M200,80 L200,20" stroke="#4CAF50" stroke-width="3" marker-end="url(#arrowGreen)"/>
                        <text x="200" y="12" text-anchor="middle" font-size="14" font-weight="bold" fill="#4CAF50">Y</text>
                        <text x="220" y="40" font-size="10" fill="#4CAF50">Up +</text>
                        
                        <!-- Z axis (out of screen) -->
                        <ellipse cx="200" cy="180" rx="20" ry="10" fill="none" stroke="#2196F3" stroke-width="2"/>
                        <circle cx="200" cy="180" r="4" fill="#2196F3"/>
                        <text x="200" y="210" text-anchor="middle" font-size="14" font-weight="bold" fill="#2196F3">Z</text>
                        <text x="200" y="225" text-anchor="middle" font-size="10" fill="#2196F3">Out of screen +</text>
                        
                        <defs>
                            <marker id="arrowRed" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#f44336"/>
                            </marker>
                            <marker id="arrowGreen" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#4CAF50"/>
                            </marker>
                        </defs>
                    </svg>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Accelerometer Values</h4>
                    <ul>
                        <li><strong>Flat on table face up:</strong> x ‚âà 0, y ‚âà 0, z ‚âà 1 (gravity)</li>
                        <li><strong>Upright (portrait):</strong> x ‚âà 0, y ‚âà -1, z ‚âà 0</li>
                        <li><strong>Tilted left:</strong> x increases positive</li>
                        <li><strong>Values in g-force:</strong> 1g ‚âà 9.81 m/s¬≤</li>
                    </ul>
                </div>

                <h3>Basic Accelerometer Usage</h3>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Accelerometer } from 'expo-sensors';

export default function AccelerometerDemo() {
  const [data, setData] = useState({ x: 0, y: 0, z: 0 });

  useEffect(() => {
    // Set update interval (in milliseconds)
    Accelerometer.setUpdateInterval(100);

    // Subscribe to accelerometer updates
    const subscription = Accelerometer.addListener(accelerometerData => {
      setData(accelerometerData);
    });

    // Cleanup on unmount
    return () => subscription.remove();
  }, []);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Accelerometer Data&lt;/Text&gt;
      &lt;Text style={styles.data}&gt;X: {data.x.toFixed(3)}&lt;/Text&gt;
      &lt;Text style={styles.data}&gt;Y: {data.y.toFixed(3)}&lt;/Text&gt;
      &lt;Text style={styles.data}&gt;Z: {data.z.toFixed(3)}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20 },
  data: { fontSize: 18, marginVertical: 5, fontFamily: 'monospace' },
});</code></pre>

                <h3>Accelerometer with Start/Stop</h3>

                <pre><code>import { useState, useEffect, useRef } from 'react';
import { View, Text, Pressable, StyleSheet } from 'react-native';
import { Accelerometer, AccelerometerMeasurement } from 'expo-sensors';

export default function ControllableAccelerometer() {
  const [data, setData] = useState&lt;AccelerometerMeasurement&gt;({ x: 0, y: 0, z: 0 });
  const [isActive, setIsActive] = useState(false);
  const subscriptionRef = useRef&lt;ReturnType&lt;typeof Accelerometer.addListener&gt; | null&gt;(null);

  const startListening = () => {
    Accelerometer.setUpdateInterval(100);
    subscriptionRef.current = Accelerometer.addListener(setData);
    setIsActive(true);
  };

  const stopListening = () => {
    subscriptionRef.current?.remove();
    subscriptionRef.current = null;
    setIsActive(false);
  };

  useEffect(() => {
    return () => {
      subscriptionRef.current?.remove();
    };
  }, []);

  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.dataContainer}&gt;
        &lt;Text style={styles.label}&gt;X&lt;/Text&gt;
        &lt;View style={[styles.bar, { width: Math.abs(data.x) * 100, backgroundColor: '#f44336' }]} /&gt;
        &lt;Text style={styles.value}&gt;{data.x.toFixed(2)}&lt;/Text&gt;
      &lt;/View&gt;
      
      &lt;View style={styles.dataContainer}&gt;
        &lt;Text style={styles.label}&gt;Y&lt;/Text&gt;
        &lt;View style={[styles.bar, { width: Math.abs(data.y) * 100, backgroundColor: '#4CAF50' }]} /&gt;
        &lt;Text style={styles.value}&gt;{data.y.toFixed(2)}&lt;/Text&gt;
      &lt;/View&gt;
      
      &lt;View style={styles.dataContainer}&gt;
        &lt;Text style={styles.label}&gt;Z&lt;/Text&gt;
        &lt;View style={[styles.bar, { width: Math.abs(data.z) * 100, backgroundColor: '#2196F3' }]} /&gt;
        &lt;Text style={styles.value}&gt;{data.z.toFixed(2)}&lt;/Text&gt;
      &lt;/View&gt;

      &lt;Pressable
        style={[styles.button, isActive ? styles.stopButton : styles.startButton]}
        onPress={isActive ? stopListening : startListening}
      &gt;
        &lt;Text style={styles.buttonText}&gt;
          {isActive ? 'Stop' : 'Start'}
        &lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', padding: 20 },
  dataContainer: { flexDirection: 'row', alignItems: 'center', marginVertical: 10 },
  label: { width: 30, fontSize: 18, fontWeight: 'bold' },
  bar: { height: 20, borderRadius: 4, marginRight: 10 },
  value: { fontSize: 16, fontFamily: 'monospace' },
  button: { marginTop: 30, padding: 16, borderRadius: 8, alignItems: 'center' },
  startButton: { backgroundColor: '#4CAF50' },
  stopButton: { backgroundColor: '#f44336' },
  buttonText: { color: 'white', fontSize: 18, fontWeight: '600' },
});</code></pre>

                <h3>Check Sensor Availability</h3>

                <pre><code>import { Accelerometer } from 'expo-sensors';

async function checkAccelerometer() {
  const isAvailable = await Accelerometer.isAvailableAsync();
  
  if (!isAvailable) {
    console.log('Accelerometer is not available on this device');
    return false;
  }
  
  // Request permission on iOS
  const { status } = await Accelerometer.requestPermissionsAsync();
  
  if (status !== 'granted') {
    console.log('Motion permission denied');
    return false;
  }
  
  return true;
}</code></pre>
            </section>

            <!-- Gyroscope -->
            <section id="gyroscope">
                <h2>Gyroscope</h2>

                <p>The gyroscope measures the device's rotation rate around three axes. Unlike the accelerometer, it measures angular velocity (how fast the device is rotating) rather than linear motion.</p>

                <h3>Basic Gyroscope Usage</h3>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Gyroscope } from 'expo-sensors';

export default function GyroscopeDemo() {
  const [rotation, setRotation] = useState({ x: 0, y: 0, z: 0 });

  useEffect(() => {
    Gyroscope.setUpdateInterval(100);

    const subscription = Gyroscope.addListener(data => {
      setRotation(data);
    });

    return () => subscription.remove();
  }, []);

  // Values are in radians per second
  const toDegrees = (rad: number) => (rad * 180 / Math.PI).toFixed(1);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Gyroscope (¬∞/sec)&lt;/Text&gt;
      &lt;Text style={styles.data}&gt;Pitch (X): {toDegrees(rotation.x)}¬∞/s&lt;/Text&gt;
      &lt;Text style={styles.data}&gt;Roll (Y): {toDegrees(rotation.y)}¬∞/s&lt;/Text&gt;
      &lt;Text style={styles.data}&gt;Yaw (Z): {toDegrees(rotation.z)}¬∞/s&lt;/Text&gt;
      
      &lt;View style={styles.visualization}&gt;
        &lt;View style={[
          styles.indicator,
          {
            transform: [
              { rotateX: `${rotation.x * 20}deg` },
              { rotateY: `${rotation.y * 20}deg` },
              { rotateZ: `${rotation.z * 20}deg` },
            ]
          }
        ]}&gt;
          &lt;Text style={styles.indicatorText}&gt;üì±&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20 },
  data: { fontSize: 16, marginVertical: 5 },
  visualization: { marginTop: 40, width: 150, height: 150, justifyContent: 'center', alignItems: 'center' },
  indicator: { width: 100, height: 100, justifyContent: 'center', alignItems: 'center', backgroundColor: '#e0e0e0', borderRadius: 10 },
  indicatorText: { fontSize: 48 },
});</code></pre>

                <div class="card" style="background: #fff3e0; border-left: 4px solid #FF9800;">
                    <h4>üîÑ Gyroscope vs Accelerometer</h4>
                    <ul>
                        <li><strong>Accelerometer:</strong> Measures how fast the device is moving (linear)</li>
                        <li><strong>Gyroscope:</strong> Measures how fast the device is rotating (angular)</li>
                        <li><strong>Combined:</strong> Use both for accurate motion tracking</li>
                    </ul>
                </div>
            </section>

            <!-- Device Motion -->
            <section id="device-motion">
                <h2>Device Motion</h2>

                <p>Device Motion combines data from multiple sensors (accelerometer, gyroscope, magnetometer) to provide processed, filtered motion data. It's more accurate and easier to use than raw sensor data.</p>

                <h3>Using Device Motion</h3>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { DeviceMotion } from 'expo-sensors';

export default function DeviceMotionDemo() {
  const [motion, setMotion] = useState&lt;any&gt;(null);

  useEffect(() => {
    DeviceMotion.setUpdateInterval(100);

    const subscription = DeviceMotion.addListener(data => {
      setMotion(data);
    });

    return () => subscription.remove();
  }, []);

  if (!motion) {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text&gt;Waiting for motion data...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Device Motion&lt;/Text&gt;
      
      &lt;View style={styles.section}&gt;
        &lt;Text style={styles.sectionTitle}&gt;Acceleration (with gravity)&lt;/Text&gt;
        &lt;Text&gt;X: {motion.accelerationIncludingGravity?.x?.toFixed(2)}&lt;/Text&gt;
        &lt;Text&gt;Y: {motion.accelerationIncludingGravity?.y?.toFixed(2)}&lt;/Text&gt;
        &lt;Text&gt;Z: {motion.accelerationIncludingGravity?.z?.toFixed(2)}&lt;/Text&gt;
      &lt;/View&gt;

      &lt;View style={styles.section}&gt;
        &lt;Text style={styles.sectionTitle}&gt;Acceleration (without gravity)&lt;/Text&gt;
        &lt;Text&gt;X: {motion.acceleration?.x?.toFixed(2)}&lt;/Text&gt;
        &lt;Text&gt;Y: {motion.acceleration?.y?.toFixed(2)}&lt;/Text&gt;
        &lt;Text&gt;Z: {motion.acceleration?.z?.toFixed(2)}&lt;/Text&gt;
      &lt;/View&gt;

      &lt;View style={styles.section}&gt;
        &lt;Text style={styles.sectionTitle}&gt;Rotation (degrees)&lt;/Text&gt;
        &lt;Text&gt;Alpha: {((motion.rotation?.alpha ?? 0) * 180 / Math.PI).toFixed(1)}¬∞&lt;/Text&gt;
        &lt;Text&gt;Beta: {((motion.rotation?.beta ?? 0) * 180 / Math.PI).toFixed(1)}¬∞&lt;/Text&gt;
        &lt;Text&gt;Gamma: {((motion.rotation?.gamma ?? 0) * 180 / Math.PI).toFixed(1)}¬∞&lt;/Text&gt;
      &lt;/View&gt;

      &lt;View style={styles.section}&gt;
        &lt;Text style={styles.sectionTitle}&gt;Orientation&lt;/Text&gt;
        &lt;Text&gt;{motion.orientation}¬∞&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20 },
  section: { marginBottom: 20, padding: 15, backgroundColor: '#f5f5f5', borderRadius: 8 },
  sectionTitle: { fontWeight: '600', marginBottom: 8 },
});</code></pre>

                <h3>Device Motion Data Structure</h3>

                <div class="card">
                    <h4>üìä DeviceMotion Data</h4>
                    <pre><code>{
  // Acceleration including gravity (raw accelerometer)
  accelerationIncludingGravity: { x, y, z },
  
  // Acceleration without gravity (user movement only)
  acceleration: { x, y, z },
  
  // Rotation rate (gyroscope)
  rotationRate: { alpha, beta, gamma },
  
  // Device orientation in 3D space
  rotation: { alpha, beta, gamma },
  
  // Screen orientation in degrees (0, 90, 180, 270)
  orientation: number,
}</code></pre>
                </div>
            </section>

            <!-- Pedometer -->
            <section id="pedometer">
                <h2>Pedometer</h2>

                <p>The pedometer counts steps using the device's motion co-processor. It's energy-efficient and works even when the app is in the background.</p>

                <h3>Step Counting</h3>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { Pedometer } from 'expo-sensors';

export default function PedometerDemo() {
  const [isPedometerAvailable, setIsPedometerAvailable] = useState(false);
  const [currentSteps, setCurrentSteps] = useState(0);
  const [pastSteps, setPastSteps] = useState(0);

  useEffect(() => {
    checkAvailability();
    subscribeToPedometer();
    getPastSteps();
  }, []);

  const checkAvailability = async () => {
    const available = await Pedometer.isAvailableAsync();
    setIsPedometerAvailable(available);
  };

  const subscribeToPedometer = async () => {
    const available = await Pedometer.isAvailableAsync();
    if (!available) return;

    // Request permission on iOS
    if (Platform.OS === 'ios') {
      const { status } = await Pedometer.requestPermissionsAsync();
      if (status !== 'granted') return;
    }

    // Listen for live step updates
    const subscription = Pedometer.watchStepCount(result => {
      setCurrentSteps(result.steps);
    });

    return () => subscription.remove();
  };

  const getPastSteps = async () => {
    const available = await Pedometer.isAvailableAsync();
    if (!available) return;

    // Get steps from the past 24 hours
    const end = new Date();
    const start = new Date();
    start.setDate(start.getDate() - 1);

    const result = await Pedometer.getStepCountAsync(start, end);
    setPastSteps(result.steps);
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;üö∂ Pedometer&lt;/Text&gt;
      
      &lt;Text style={styles.available}&gt;
        {isPedometerAvailable ? '‚úÖ Available' : '‚ùå Not available'}
      &lt;/Text&gt;

      &lt;View style={styles.card}&gt;
        &lt;Text style={styles.cardTitle}&gt;Steps Since App Open&lt;/Text&gt;
        &lt;Text style={styles.steps}&gt;{currentSteps}&lt;/Text&gt;
      &lt;/View&gt;

      &lt;View style={styles.card}&gt;
        &lt;Text style={styles.cardTitle}&gt;Steps (Past 24 Hours)&lt;/Text&gt;
        &lt;Text style={styles.steps}&gt;{pastSteps}&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 },
  title: { fontSize: 32, fontWeight: 'bold', marginBottom: 10 },
  available: { fontSize: 16, marginBottom: 30 },
  card: { backgroundColor: '#f5f5f5', padding: 30, borderRadius: 16, alignItems: 'center', marginBottom: 20, width: '100%' },
  cardTitle: { fontSize: 14, color: '#666', marginBottom: 10 },
  steps: { fontSize: 48, fontWeight: 'bold', color: '#667eea' },
});</code></pre>

                <h3>Historical Step Data</h3>

                <pre><code>import { Pedometer } from 'expo-sensors';

// Get steps for a specific date range
async function getStepsForRange(startDate: Date, endDate: Date) {
  const available = await Pedometer.isAvailableAsync();
  if (!available) return null;

  const result = await Pedometer.getStepCountAsync(startDate, endDate);
  return result.steps;
}

// Get today's steps
async function getTodaySteps() {
  const now = new Date();
  const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  return getStepsForRange(startOfDay, now);
}

// Get this week's steps
async function getWeekSteps() {
  const now = new Date();
  const startOfWeek = new Date(now);
  startOfWeek.setDate(now.getDate() - now.getDay()); // Start of week (Sunday)
  startOfWeek.setHours(0, 0, 0, 0);
  return getStepsForRange(startOfWeek, now);
}

// Get steps per day for the past week
async function getStepsPerDay(days: number = 7) {
  const stepsPerDay: { date: Date; steps: number }[] = [];
  
  for (let i = 0; i < days; i++) {
    const date = new Date();
    date.setDate(date.getDate() - i);
    
    const start = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const end = new Date(start);
    end.setDate(end.getDate() + 1);
    
    const steps = await getStepsForRange(start, end);
    stepsPerDay.push({ date: start, steps: steps ?? 0 });
  }
  
  return stepsPerDay.reverse();
}</code></pre>
            </section>

            <!-- Shake Detection -->
            <section id="shake-detection">
                <h2>Shake Detection</h2>

                <p>Detecting device shakes is a common use case for triggering actions like "undo" or refreshing content. We can implement this using the accelerometer.</p>

                <h3>Simple Shake Detector</h3>

                <pre><code>import { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Vibration } from 'react-native';
import { Accelerometer } from 'expo-sensors';

const SHAKE_THRESHOLD = 1.5; // Adjust sensitivity
const SHAKE_TIMEOUT = 500;   // Minimum time between shakes

export default function ShakeDetector() {
  const [shakeCount, setShakeCount] = useState(0);
  const lastShakeRef = useRef(0);

  useEffect(() => {
    Accelerometer.setUpdateInterval(100);

    const subscription = Accelerometer.addListener(data => {
      const { x, y, z } = data;
      
      // Calculate total acceleration magnitude
      const acceleration = Math.sqrt(x * x + y * y + z * z);
      
      // Check if it's a shake
      if (acceleration > SHAKE_THRESHOLD) {
        const now = Date.now();
        
        // Debounce: only count if enough time has passed
        if (now - lastShakeRef.current > SHAKE_TIMEOUT) {
          lastShakeRef.current = now;
          setShakeCount(prev => prev + 1);
          Vibration.vibrate(100); // Feedback
        }
      }
    });

    return () => subscription.remove();
  }, []);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;ü´® Shake Me!&lt;/Text&gt;
      &lt;Text style={styles.count}&gt;{shakeCount}&lt;/Text&gt;
      &lt;Text style={styles.label}&gt;shakes detected&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  title: { fontSize: 32, marginBottom: 40 },
  count: { fontSize: 80, fontWeight: 'bold', color: '#667eea' },
  label: { fontSize: 18, color: '#666' },
});</code></pre>

                <h3>Reusable Shake Hook</h3>

                <pre><code>import { useEffect, useRef, useCallback } from 'react';
import { Accelerometer } from 'expo-sensors';

interface ShakeOptions {
  threshold?: number;
  timeout?: number;
  updateInterval?: number;
}

export function useShake(
  onShake: () => void,
  options: ShakeOptions = {}
) {
  const {
    threshold = 1.5,
    timeout = 500,
    updateInterval = 100,
  } = options;

  const lastShakeRef = useRef(0);
  const callbackRef = useRef(onShake);

  // Keep callback ref updated
  useEffect(() => {
    callbackRef.current = onShake;
  }, [onShake]);

  useEffect(() => {
    Accelerometer.setUpdateInterval(updateInterval);

    const subscription = Accelerometer.addListener(({ x, y, z }) => {
      const acceleration = Math.sqrt(x * x + y * y + z * z);
      
      if (acceleration > threshold) {
        const now = Date.now();
        if (now - lastShakeRef.current > timeout) {
          lastShakeRef.current = now;
          callbackRef.current();
        }
      }
    });

    return () => subscription.remove();
  }, [threshold, timeout, updateInterval]);
}

// Usage
function MyComponent() {
  const handleShake = useCallback(() => {
    console.log('Device was shaken!');
    // Trigger undo, refresh, etc.
  }, []);

  useShake(handleShake, { threshold: 1.8 });

  return &lt;View&gt;{/* Your content */}&lt;/View&gt;;
}</code></pre>
            </section>
            <!-- Haptic Feedback -->
            <section id="haptics">
                <h2>Haptic Feedback</h2>

                <p>Haptic feedback provides tactile responses to user interactions, making your app feel more responsive and polished. Expo provides the <code>expo-haptics</code> package for this.</p>

                <h3>Haptic Types</h3>

                <pre><code>import * as Haptics from 'expo-haptics';

// Impact feedback - for button taps, collisions
await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);

// Notification feedback - for success/warning/error states
await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);

// Selection feedback - for picker/slider changes
await Haptics.selectionAsync();</code></pre>

                <div class="card">
                    <h4>üì≥ When to Use Each Type</h4>
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f5f5f5;">
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Type</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Use Cases</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Impact Light</strong></td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Subtle taps, toggle switches, light UI interactions</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Impact Medium</strong></td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Button presses, card selections</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Impact Heavy</strong></td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Significant actions, drag drop, collisions</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Notification Success</strong></td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Task completed, form submitted, save successful</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Notification Warning</strong></td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Approaching limit, potential issue</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Notification Error</strong></td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Validation error, action failed</td>
                            </tr>
                            <tr>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Selection</strong></td>
                                <td style="padding: 12px; border-bottom: 1px solid #eee;">Picker changes, slider ticks, segmented controls</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Haptic Demo Component</h3>

                <pre><code>import { View, Text, Pressable, StyleSheet } from 'react-native';
import * as Haptics from 'expo-haptics';

export default function HapticsDemo() {
  const hapticOptions = [
    { label: 'Light Impact', action: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light), color: '#81C784' },
    { label: 'Medium Impact', action: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium), color: '#4CAF50' },
    { label: 'Heavy Impact', action: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy), color: '#2E7D32' },
    { label: 'Success', action: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success), color: '#2196F3' },
    { label: 'Warning', action: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning), color: '#FF9800' },
    { label: 'Error', action: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error), color: '#f44336' },
    { label: 'Selection', action: () => Haptics.selectionAsync(), color: '#9C27B0' },
  ];

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;üì≥ Haptic Feedback&lt;/Text&gt;
      
      {hapticOptions.map((option, index) => (
        &lt;Pressable
          key={index}
          style={[styles.button, { backgroundColor: option.color }]}
          onPress={option.action}
        &gt;
          &lt;Text style={styles.buttonText}&gt;{option.label}&lt;/Text&gt;
        &lt;/Pressable&gt;
      ))}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', padding: 20 },
  title: { fontSize: 28, fontWeight: 'bold', textAlign: 'center', marginBottom: 30 },
  button: { padding: 16, borderRadius: 8, marginBottom: 12, alignItems: 'center' },
  buttonText: { color: 'white', fontSize: 16, fontWeight: '600' },
});</code></pre>

                <h3>Haptic Button Component</h3>

                <pre><code>import { Pressable, PressableProps, StyleSheet } from 'react-native';
import * as Haptics from 'expo-haptics';

interface HapticButtonProps extends PressableProps {
  hapticStyle?: 'light' | 'medium' | 'heavy' | 'selection';
  children: React.ReactNode;
}

export function HapticButton({ 
  hapticStyle = 'medium', 
  onPress, 
  children, 
  ...props 
}: HapticButtonProps) {
  
  const handlePress = async (event: any) => {
    // Trigger haptic
    switch (hapticStyle) {
      case 'light':
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        break;
      case 'medium':
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
        break;
      case 'heavy':
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
        break;
      case 'selection':
        await Haptics.selectionAsync();
        break;
    }
    
    // Call original onPress
    onPress?.(event);
  };

  return (
    &lt;Pressable onPress={handlePress} {...props}&gt;
      {children}
    &lt;/Pressable&gt;
  );
}

// Usage
&lt;HapticButton 
  hapticStyle="heavy" 
  onPress={() => console.log('Pressed!')}
  style={styles.button}
&gt;
  &lt;Text&gt;Press Me&lt;/Text&gt;
&lt;/HapticButton&gt;</code></pre>

                <h3>Haptic Slider</h3>

                <pre><code>import { useState, useRef } from 'react';
import { View, StyleSheet } from 'react-native';
import Slider from '@react-native-community/slider';
import * as Haptics from 'expo-haptics';

export function HapticSlider({ 
  step = 1, 
  onValueChange,
  ...props 
}) {
  const lastValueRef = useRef(0);

  const handleValueChange = (value: number) => {
    // Check if we crossed a step boundary
    const currentStep = Math.round(value / step);
    const lastStep = Math.round(lastValueRef.current / step);
    
    if (currentStep !== lastStep) {
      Haptics.selectionAsync();
    }
    
    lastValueRef.current = value;
    onValueChange?.(value);
  };

  return (
    &lt;Slider
      step={step}
      onValueChange={handleValueChange}
      {...props}
    /&gt;
  );
}

// Usage
&lt;HapticSlider
  minimumValue={0}
  maximumValue={100}
  step={10}
  onValueChange={(value) => console.log(value)}
/&gt;</code></pre>
            </section>

            <!-- Practical Examples -->
            <section id="practical-examples">
                <h2>Practical Examples</h2>

                <h3>Level/Bubble Tool</h3>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Accelerometer } from 'expo-sensors';
import * as Haptics from 'expo-haptics';

const { width } = Dimensions.get('window');
const LEVEL_THRESHOLD = 0.02; // How close to level counts as "level"

export default function LevelTool() {
  const [tilt, setTilt] = useState({ x: 0, y: 0 });
  const [isLevel, setIsLevel] = useState(false);

  useEffect(() => {
    Accelerometer.setUpdateInterval(50);

    const subscription = Accelerometer.addListener(data => {
      setTilt({ x: data.x, y: data.y });
      
      // Check if device is level
      const level = Math.abs(data.x) < LEVEL_THRESHOLD && Math.abs(data.y) < LEVEL_THRESHOLD;
      
      if (level && !isLevel) {
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      }
      
      setIsLevel(level);
    });

    return () => subscription.remove();
  }, [isLevel]);

  // Calculate bubble position
  const bubbleX = tilt.x * (width / 4);
  const bubbleY = tilt.y * (width / 4);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;üìê Level Tool&lt;/Text&gt;
      
      &lt;View style={[styles.levelContainer, isLevel && styles.levelContainerLevel]}&gt;
        {/* Cross hairs */}
        &lt;View style={styles.crossHairH} /&gt;
        &lt;View style={styles.crossHairV} /&gt;
        
        {/* Bubble */}
        &lt;View style={[
          styles.bubble,
          {
            transform: [
              { translateX: bubbleX },
              { translateY: bubbleY },
            ],
          },
          isLevel && styles.bubbleLevel,
        ]} /&gt;
        
        {/* Center circle */}
        &lt;View style={[styles.centerCircle, isLevel && styles.centerCircleLevel]} /&gt;
      &lt;/View&gt;
      
      &lt;Text style={[styles.status, isLevel && styles.statusLevel]}&gt;
        {isLevel ? '‚úì LEVEL' : 'Tilt to level'}
      &lt;/Text&gt;
      
      &lt;Text style={styles.degrees}&gt;
        X: {(tilt.x * 90).toFixed(1)}¬∞ | Y: {(tilt.y * 90).toFixed(1)}¬∞
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1a1a1a' },
  title: { fontSize: 24, fontWeight: 'bold', color: 'white', marginBottom: 40 },
  levelContainer: { width: width - 80, height: width - 80, borderRadius: (width - 80) / 2, backgroundColor: '#333', justifyContent: 'center', alignItems: 'center', borderWidth: 4, borderColor: '#555' },
  levelContainerLevel: { borderColor: '#4CAF50' },
  crossHairH: { position: 'absolute', width: '80%', height: 2, backgroundColor: '#555' },
  crossHairV: { position: 'absolute', width: 2, height: '80%', backgroundColor: '#555' },
  bubble: { width: 40, height: 40, borderRadius: 20, backgroundColor: '#f44336' },
  bubbleLevel: { backgroundColor: '#4CAF50' },
  centerCircle: { position: 'absolute', width: 60, height: 60, borderRadius: 30, borderWidth: 2, borderColor: '#555' },
  centerCircleLevel: { borderColor: '#4CAF50' },
  status: { marginTop: 40, fontSize: 20, fontWeight: '600', color: '#888' },
  statusLevel: { color: '#4CAF50' },
  degrees: { marginTop: 16, fontSize: 14, color: '#666' },
});</code></pre>

                <h3>Tilt-Controlled Ball</h3>

                <pre><code>import { useState, useEffect } from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import { Accelerometer } from 'expo-sensors';
import Animated, { useAnimatedStyle, withSpring } from 'react-native-reanimated';

const { width, height } = Dimensions.get('window');
const BALL_SIZE = 50;
const BOUNDS = {
  minX: BALL_SIZE / 2,
  maxX: width - BALL_SIZE / 2,
  minY: BALL_SIZE / 2,
  maxY: height - 200,
};

export default function TiltBall() {
  const [position, setPosition] = useState({ x: width / 2, y: height / 2 - 100 });
  const [velocity, setVelocity] = useState({ x: 0, y: 0 });

  useEffect(() => {
    Accelerometer.setUpdateInterval(16); // ~60fps

    const subscription = Accelerometer.addListener(data => {
      setVelocity(prev => ({
        x: prev.x + data.x * 2,
        y: prev.y - data.y * 2,
      }));
    });

    // Physics update loop
    const interval = setInterval(() => {
      setPosition(prev => {
        let newX = prev.x + velocity.x;
        let newY = prev.y + velocity.y;

        // Bounce off walls
        if (newX < BOUNDS.minX || newX > BOUNDS.maxX) {
          setVelocity(v => ({ ...v, x: -v.x * 0.8 }));
          newX = Math.max(BOUNDS.minX, Math.min(BOUNDS.maxX, newX));
        }
        if (newY < BOUNDS.minY || newY > BOUNDS.maxY) {
          setVelocity(v => ({ ...v, y: -v.y * 0.8 }));
          newY = Math.max(BOUNDS.minY, Math.min(BOUNDS.maxY, newY));
        }

        return { x: newX, y: newY };
      });

      // Apply friction
      setVelocity(v => ({ x: v.x * 0.98, y: v.y * 0.98 }));
    }, 16);

    return () => {
      subscription.remove();
      clearInterval(interval);
    };
  }, [velocity]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: withSpring(position.x - BALL_SIZE / 2) },
      { translateY: withSpring(position.y - BALL_SIZE / 2) },
    ],
  }));

  return (
    &lt;View style={styles.container}&gt;
      &lt;Animated.View style={[styles.ball, animatedStyle]} /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#1a1a1a' },
  ball: { width: BALL_SIZE, height: BALL_SIZE, borderRadius: BALL_SIZE / 2, backgroundColor: '#667eea', position: 'absolute' },
});</code></pre>

                <h3>Compass</h3>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Magnetometer } from 'expo-sensors';

const { width } = Dimensions.get('window');

export default function Compass() {
  const [heading, setHeading] = useState(0);

  useEffect(() => {
    Magnetometer.setUpdateInterval(100);

    const subscription = Magnetometer.addListener(data => {
      // Calculate heading from magnetometer data
      let angle = Math.atan2(data.y, data.x) * (180 / Math.PI);
      
      // Normalize to 0-360
      if (angle < 0) angle += 360;
      
      setHeading(angle);
    });

    return () => subscription.remove();
  }, []);

  const getDirection = (angle: number) => {
    if (angle >= 337.5 || angle < 22.5) return 'N';
    if (angle >= 22.5 && angle < 67.5) return 'NE';
    if (angle >= 67.5 && angle < 112.5) return 'E';
    if (angle >= 112.5 && angle < 157.5) return 'SE';
    if (angle >= 157.5 && angle < 202.5) return 'S';
    if (angle >= 202.5 && angle < 247.5) return 'SW';
    if (angle >= 247.5 && angle < 292.5) return 'W';
    return 'NW';
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.compassContainer}&gt;
        &lt;View style={[styles.compass, { transform: [{ rotate: `-${heading}deg` }] }]}&gt;
          &lt;View style={styles.needleContainer}&gt;
            &lt;View style={styles.needleNorth} /&gt;
            &lt;View style={styles.needleSouth} /&gt;
          &lt;/View&gt;
          
          {/* Cardinal directions */}
          &lt;Text style={[styles.cardinal, styles.north]}&gt;N&lt;/Text&gt;
          &lt;Text style={[styles.cardinal, styles.south]}&gt;S&lt;/Text&gt;
          &lt;Text style={[styles.cardinal, styles.east]}&gt;E&lt;/Text&gt;
          &lt;Text style={[styles.cardinal, styles.west]}&gt;W&lt;/Text&gt;
        &lt;/View&gt;
        
        {/* Fixed indicator */}
        &lt;View style={styles.indicator} /&gt;
      &lt;/View&gt;

      &lt;Text style={styles.heading}&gt;{Math.round(heading)}¬∞&lt;/Text&gt;
      &lt;Text style={styles.direction}&gt;{getDirection(heading)}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const COMPASS_SIZE = width - 80;

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1a1a1a' },
  compassContainer: { width: COMPASS_SIZE, height: COMPASS_SIZE, justifyContent: 'center', alignItems: 'center' },
  compass: { width: COMPASS_SIZE, height: COMPASS_SIZE, borderRadius: COMPASS_SIZE / 2, backgroundColor: '#333', borderWidth: 4, borderColor: '#555', justifyContent: 'center', alignItems: 'center' },
  needleContainer: { position: 'absolute', width: 10, height: COMPASS_SIZE * 0.7, alignItems: 'center' },
  needleNorth: { width: 10, height: '50%', backgroundColor: '#f44336', borderTopLeftRadius: 5, borderTopRightRadius: 5 },
  needleSouth: { width: 10, height: '50%', backgroundColor: '#ccc', borderBottomLeftRadius: 5, borderBottomRightRadius: 5 },
  cardinal: { position: 'absolute', fontSize: 20, fontWeight: 'bold', color: '#888' },
  north: { top: 20, color: '#f44336' },
  south: { bottom: 20 },
  east: { right: 20 },
  west: { left: 20 },
  indicator: { position: 'absolute', top: -10, width: 0, height: 0, borderLeftWidth: 10, borderRightWidth: 10, borderBottomWidth: 20, borderLeftColor: 'transparent', borderRightColor: 'transparent', borderBottomColor: '#667eea' },
  heading: { marginTop: 40, fontSize: 48, fontWeight: 'bold', color: 'white' },
  direction: { fontSize: 24, color: '#888' },
});</code></pre>
            </section>

            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: Step Counter Widget</h3>
                    <p>Build a step counter widget that shows daily progress toward a goal.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Display today's step count</li>
                        <li>Show a circular progress indicator</li>
                        <li>Allow setting a daily goal</li>
                        <li>Play haptic feedback when goal is reached</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use <code>Pedometer.getStepCountAsync()</code> with today's date range. Create a circular progress using SVG or a library. Store the goal in AsyncStorage. Use <code>Haptics.notificationAsync(Success)</code> when goal is reached.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect, useRef } from 'react';
import { View, Text, Pressable, StyleSheet, TextInput, Modal } from 'react-native';
import { Pedometer } from 'expo-sensors';
import * as Haptics from 'expo-haptics';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Svg, { Circle } from 'react-native-svg';

const GOAL_KEY = 'stepGoal';
const DEFAULT_GOAL = 10000;

export default function StepCounterWidget() {
  const [steps, setSteps] = useState(0);
  const [goal, setGoal] = useState(DEFAULT_GOAL);
  const [showGoalModal, setShowGoalModal] = useState(false);
  const [newGoal, setNewGoal] = useState('');
  const goalReachedRef = useRef(false);

  useEffect(() => {
    loadGoal();
    loadTodaySteps();
    
    const subscription = Pedometer.watchStepCount(result => {
      loadTodaySteps();
    });

    return () => subscription.remove();
  }, []);

  useEffect(() => {
    if (steps >= goal && !goalReachedRef.current) {
      goalReachedRef.current = true;
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } else if (steps < goal) {
      goalReachedRef.current = false;
    }
  }, [steps, goal]);

  const loadGoal = async () => {
    const saved = await AsyncStorage.getItem(GOAL_KEY);
    if (saved) setGoal(parseInt(saved));
  };

  const loadTodaySteps = async () => {
    const available = await Pedometer.isAvailableAsync();
    if (!available) return;

    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const result = await Pedometer.getStepCountAsync(start, now);
    setSteps(result.steps);
  };

  const saveGoal = async () => {
    const parsed = parseInt(newGoal);
    if (parsed > 0) {
      setGoal(parsed);
      await AsyncStorage.setItem(GOAL_KEY, parsed.toString());
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }
    setShowGoalModal(false);
    setNewGoal('');
  };

  const progress = Math.min(steps / goal, 1);
  const circumference = 2 * Math.PI * 90;
  const strokeDashoffset = circumference * (1 - progress);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Pressable onPress={() => setShowGoalModal(true)}&gt;
        &lt;Svg width={220} height={220} viewBox="0 0 200 200"&gt;
          &lt;Circle cx="100" cy="100" r="90" stroke="#333" strokeWidth="12" fill="none" /&gt;
          &lt;Circle
            cx="100" cy="100" r="90"
            stroke={progress >= 1 ? '#4CAF50' : '#667eea'}
            strokeWidth="12" fill="none"
            strokeDasharray={circumference}
            strokeDashoffset={strokeDashoffset}
            strokeLinecap="round"
            transform="rotate(-90 100 100)"
          /&gt;
        &lt;/Svg&gt;
        
        &lt;View style={styles.centerContent}&gt;
          &lt;Text style={styles.steps}&gt;{steps.toLocaleString()}&lt;/Text&gt;
          &lt;Text style={styles.label}&gt;steps&lt;/Text&gt;
          &lt;Text style={styles.goal}&gt;Goal: {goal.toLocaleString()}&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/Pressable&gt;

      &lt;Modal visible={showGoalModal} transparent animationType="fade"&gt;
        &lt;View style={styles.modalOverlay}&gt;
          &lt;View style={styles.modalContent}&gt;
            &lt;Text style={styles.modalTitle}&gt;Set Daily Goal&lt;/Text&gt;
            &lt;TextInput
              style={styles.input}
              keyboardType="number-pad"
              placeholder="Enter step goal"
              value={newGoal}
              onChangeText={setNewGoal}
            /&gt;
            &lt;View style={styles.modalButtons}&gt;
              &lt;Pressable style={styles.cancelButton} onPress={() => setShowGoalModal(false)}&gt;
                &lt;Text style={styles.cancelText}&gt;Cancel&lt;/Text&gt;
              &lt;/Pressable&gt;
              &lt;Pressable style={styles.saveButton} onPress={saveGoal}&gt;
                &lt;Text style={styles.saveText}&gt;Save&lt;/Text&gt;
              &lt;/Pressable&gt;
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/View&gt;
      &lt;/Modal&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1a1a1a' },
  centerContent: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, justifyContent: 'center', alignItems: 'center' },
  steps: { fontSize: 42, fontWeight: 'bold', color: 'white' },
  label: { fontSize: 16, color: '#888' },
  goal: { fontSize: 14, color: '#666', marginTop: 8 },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.7)', justifyContent: 'center', alignItems: 'center' },
  modalContent: { backgroundColor: 'white', padding: 24, borderRadius: 16, width: 280 },
  modalTitle: { fontSize: 20, fontWeight: '600', marginBottom: 16 },
  input: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 12, fontSize: 16, marginBottom: 16 },
  modalButtons: { flexDirection: 'row', justifyContent: 'flex-end' },
  cancelButton: { padding: 12 },
  cancelText: { color: '#666' },
  saveButton: { backgroundColor: '#667eea', padding: 12, borderRadius: 8, marginLeft: 8 },
  saveText: { color: 'white', fontWeight: '600' },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Dice Roller</h3>
                    <p>Build a dice roller that rolls when you shake the device.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Display a die face (1-6)</li>
                        <li>Roll on shake or button tap</li>
                        <li>Animate the roll with random values</li>
                        <li>Play haptic feedback during roll and when stopped</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use the shake detection pattern from earlier. Animate by rapidly changing the die value for a brief period before settling. Use <code>Haptics.selectionAsync()</code> during roll and <code>Haptics.impactAsync(Heavy)</code> when stopped.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect, useRef } from 'react';
import { View, Text, Pressable, StyleSheet, Animated } from 'react-native';
import { Accelerometer } from 'expo-sensors';
import * as Haptics from 'expo-haptics';

const DICE_FACES = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
const SHAKE_THRESHOLD = 1.8;

export default function DiceRoller() {
  const [dieValue, setDieValue] = useState(1);
  const [isRolling, setIsRolling] = useState(false);
  const shakeTimeRef = useRef(0);
  const scaleAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    Accelerometer.setUpdateInterval(100);

    const subscription = Accelerometer.addListener(({ x, y, z }) => {
      const acceleration = Math.sqrt(x * x + y * y + z * z);
      
      if (acceleration > SHAKE_THRESHOLD && !isRolling) {
        const now = Date.now();
        if (now - shakeTimeRef.current > 1000) {
          shakeTimeRef.current = now;
          rollDice();
        }
      }
    });

    return () => subscription.remove();
  }, [isRolling]);

  const rollDice = async () => {
    if (isRolling) return;
    
    setIsRolling(true);

    // Animate scale
    Animated.sequence([
      Animated.timing(scaleAnim, { toValue: 0.8, duration: 100, useNativeDriver: true }),
      Animated.timing(scaleAnim, { toValue: 1.1, duration: 100, useNativeDriver: true }),
      Animated.timing(scaleAnim, { toValue: 1, duration: 100, useNativeDriver: true }),
    ]).start();

    // Roll animation
    const rolls = 15;
    for (let i = 0; i < rolls; i++) {
      await new Promise(resolve => setTimeout(resolve, 50 + i * 10));
      setDieValue(Math.floor(Math.random() * 6) + 1);
      Haptics.selectionAsync();
    }

    // Final result
    const finalValue = Math.floor(Math.random() * 6) + 1;
    setDieValue(finalValue);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
    
    setIsRolling(false);
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;üé≤ Shake to Roll!&lt;/Text&gt;
      
      &lt;Pressable onPress={rollDice} disabled={isRolling}&gt;
        &lt;Animated.View style={[styles.dieContainer, { transform: [{ scale: scaleAnim }] }]}&gt;
          &lt;Text style={styles.die}&gt;{DICE_FACES[dieValue - 1]}&lt;/Text&gt;
        &lt;/Animated.View&gt;
      &lt;/Pressable&gt;

      &lt;Text style={styles.value}&gt;{dieValue}&lt;/Text&gt;
      
      &lt;Pressable style={styles.button} onPress={rollDice} disabled={isRolling}&gt;
        &lt;Text style={styles.buttonText}&gt;
          {isRolling ? 'Rolling...' : 'Tap to Roll'}
        &lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1a1a1a' },
  title: { fontSize: 24, fontWeight: 'bold', color: 'white', marginBottom: 40 },
  dieContainer: { width: 150, height: 150, backgroundColor: 'white', borderRadius: 20, justifyContent: 'center', alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.3, shadowRadius: 8, elevation: 8 },
  die: { fontSize: 100 },
  value: { fontSize: 48, fontWeight: 'bold', color: 'white', marginTop: 20 },
  button: { marginTop: 40, backgroundColor: '#667eea', paddingHorizontal: 40, paddingVertical: 16, borderRadius: 30 },
  buttonText: { color: 'white', fontSize: 18, fontWeight: '600' },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Motion-Controlled Game</h3>
                    <p>Create a simple game where you tilt the device to move a character to collect items.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Tilt device to move a character</li>
                        <li>Randomly spawn collectible items</li>
                        <li>Track score</li>
                        <li>Haptic feedback on collection</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use accelerometer x/y values to update character position. Use <code>setInterval</code> to spawn items at random positions. Check collision by comparing distances. Use <code>Haptics.impactAsync(Light)</code> on collection.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Accelerometer } from 'expo-sensors';
import * as Haptics from 'expo-haptics';

const { width, height } = Dimensions.get('window');
const PLAYER_SIZE = 40;
const ITEM_SIZE = 30;
const COLLECT_DISTANCE = 35;

interface Item {
  id: number;
  x: number;
  y: number;
}

export default function TiltGame() {
  const [playerPos, setPlayerPos] = useState({ x: width / 2, y: height / 2 });
  const [items, setItems] = useState&lt;Item[]&gt;([]);
  const [score, setScore] = useState(0);
  const itemIdRef = useRef(0);

  useEffect(() => {
    Accelerometer.setUpdateInterval(16);

    const subscription = Accelerometer.addListener(({ x, y }) => {
      setPlayerPos(prev => ({
        x: Math.max(PLAYER_SIZE/2, Math.min(width - PLAYER_SIZE/2, prev.x + x * 8)),
        y: Math.max(PLAYER_SIZE/2 + 100, Math.min(height - PLAYER_SIZE/2 - 100, prev.y - y * 8)),
      }));
    });

    // Spawn items
    const spawnInterval = setInterval(() => {
      const newItem: Item = {
        id: itemIdRef.current++,
        x: ITEM_SIZE + Math.random() * (width - ITEM_SIZE * 2),
        y: ITEM_SIZE + 100 + Math.random() * (height - ITEM_SIZE * 2 - 200),
      };
      setItems(prev => [...prev.slice(-9), newItem]);
    }, 1500);

    return () => {
      subscription.remove();
      clearInterval(spawnInterval);
    };
  }, []);

  // Check collisions
  useEffect(() => {
    items.forEach(item => {
      const distance = Math.sqrt(
        Math.pow(playerPos.x - item.x, 2) + 
        Math.pow(playerPos.y - item.y, 2)
      );

      if (distance < COLLECT_DISTANCE) {
        setItems(prev => prev.filter(i => i.id !== item.id));
        setScore(prev => prev + 1);
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      }
    });
  }, [playerPos, items]);

  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.header}&gt;
        &lt;Text style={styles.score}&gt;Score: {score}&lt;/Text&gt;
      &lt;/View&gt;

      {/* Items */}
      {items.map(item => (
        &lt;View
          key={item.id}
          style={[styles.item, { left: item.x - ITEM_SIZE/2, top: item.y - ITEM_SIZE/2 }]}
        &gt;
          &lt;Text style={styles.itemEmoji}&gt;‚≠ê&lt;/Text&gt;
        &lt;/View&gt;
      ))}

      {/* Player */}
      &lt;View
        style={[
          styles.player,
          { left: playerPos.x - PLAYER_SIZE/2, top: playerPos.y - PLAYER_SIZE/2 }
        ]}
      &gt;
        &lt;Text style={styles.playerEmoji}&gt;üöÄ&lt;/Text&gt;
      &lt;/View&gt;

      &lt;View style={styles.footer}&gt;
        &lt;Text style={styles.instructions}&gt;Tilt to move and collect stars!&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#1a1a2e' },
  header: { position: 'absolute', top: 60, left: 0, right: 0, alignItems: 'center', zIndex: 10 },
  score: { fontSize: 24, fontWeight: 'bold', color: 'white' },
  player: { position: 'absolute', width: PLAYER_SIZE, height: PLAYER_SIZE, justifyContent: 'center', alignItems: 'center' },
  playerEmoji: { fontSize: 32 },
  item: { position: 'absolute', width: ITEM_SIZE, height: ITEM_SIZE, justifyContent: 'center', alignItems: 'center' },
  itemEmoji: { fontSize: 24 },
  footer: { position: 'absolute', bottom: 60, left: 0, right: 0, alignItems: 'center' },
  instructions: { color: '#666', fontSize: 14 },
});</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>Sensors and haptics add a new dimension to mobile apps, enabling interactive and immersive experiences. Use them thoughtfully to enhance your app without draining the battery.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>Accelerometer:</strong> Measures linear acceleration including gravity (x, y, z)</li>
                        <li><strong>Gyroscope:</strong> Measures rotation rate (angular velocity)</li>
                        <li><strong>Device Motion:</strong> Combined, processed sensor data with gravity separated</li>
                        <li><strong>Pedometer:</strong> Energy-efficient step counting with historical data</li>
                        <li><strong>Magnetometer:</strong> Compass heading for direction apps</li>
                        <li><strong>Shake detection:</strong> Monitor acceleration magnitude with debouncing</li>
                        <li><strong>Haptic feedback:</strong> Impact, notification, and selection types</li>
                        <li><strong>Battery awareness:</strong> Higher update rates = more battery drain</li>
                        <li><strong>Always cleanup:</strong> Remove sensor subscriptions on unmount</li>
                        <li><strong>Check availability:</strong> Not all sensors exist on all devices</li>
                    </ul>
                </div>

                <p>This concludes Module 8 on Native Features and Device APIs. You now have the tools to build rich, interactive mobile experiences that take full advantage of device capabilities!</p>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m08_l04_notifications.html" class="prev-link">‚Üê Previous: Notifications</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m09_l01_testing_fundamentals.html" class="next-link">Next: Module 9 - Testing Fundamentals ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
