<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master layout animations in React Native using Reanimated for smooth entering, exiting, and layout transitions">
    <meta name="author" content="React Native & Expo Course">
    <title>Layout Animations | Module 9: Animations and Gestures | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m09_l01_animation_fundamentals.html">Module 9</a> &gt;
            <span>Lesson 9.5</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 9: Animations and Gestures</p>
                <h1>Layout Animations</h1>
                <p class="lesson-subtitle">Animate components as they enter, exit, and transition within your layouts</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Understand layout animations and when to use them</li>
                    <li>Implement entering animations for mounting components</li>
                    <li>Create exiting animations for unmounting components</li>
                    <li>Use layout transitions for smooth position changes</li>
                    <li>Build custom keyframe animations</li>
                    <li>Apply layout animations to lists and dynamic content</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#introduction">Introduction to Layout Animations</a></li>
                        <li><a href="#entering-animations">Entering Animations</a></li>
                        <li><a href="#exiting-animations">Exiting Animations</a></li>
                        <li><a href="#layout-transitions">Layout Transitions</a></li>
                        <li><a href="#keyframes">Keyframe Animations</a></li>
                        <li><a href="#list-animations">Animating Lists</a></li>
                        <li><a href="#shared-transitions">Shared Element Transitions</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- Introduction -->
            <section id="introduction">
                <h2>Introduction to Layout Animations</h2>

                <p>Layout animations bring your UI to life by animating components as they appear, disappear, or change position. Unlike imperative animations where you manually control values, layout animations are declarative‚Äîyou specify what should happen, and Reanimated handles the how.</p>

                <h3>Types of Layout Animations</h3>

                <pre class="mermaid">
flowchart LR
    subgraph Entering["Entering"]
        A[Component mounts]
        B[Animate in]
    end
    
    subgraph Layout["Layout"]
        C[Position changes]
        D[Animate to new position]
    end
    
    subgraph Exiting["Exiting"]
        E[Component unmounts]
        F[Animate out first]
    end
    
    Entering --> Layout --> Exiting
    
    style Entering fill:#e8f5e9
    style Layout fill:#e3f2fd
    style Exiting fill:#ffebee
</pre>

                <h3>When to Use Layout Animations</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Scenario</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Animation Type</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">New item appears</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Entering</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Toast notification slides in</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Item is removed</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Exiting</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Deleted list item fades out</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">List reorders</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Layout</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Items smoothly shift positions</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Size changes</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Layout</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Accordion expands/collapses</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Screen transition</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Entering + Exiting</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Page content fades between screens</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Basic Usage Pattern</h3>

                <pre><code>import Animated, {
  FadeIn,
  FadeOut,
  Layout,
} from 'react-native-reanimated';

function AnimatedComponent({ visible }: { visible: boolean }) {
  if (!visible) return null;
  
  return (
    &lt;Animated.View
      entering={FadeIn}          // Animation when mounting
      exiting={FadeOut}          // Animation when unmounting
      layout={Layout.springify()} // Animation when position changes
      style={styles.box}
    &gt;
      &lt;Text&gt;Hello!&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Concept</h4>
                    <p>Layout animations are applied as props to <code>Animated.View</code> components. They automatically trigger based on component lifecycle:</p>
                    <ul>
                        <li><strong>entering:</strong> Runs when component mounts</li>
                        <li><strong>exiting:</strong> Runs when component unmounts (delays removal)</li>
                        <li><strong>layout:</strong> Runs when layout position or size changes</li>
                    </ul>
                </div>
            </section>

            <!-- Entering Animations -->
            <section id="entering-animations">
                <h2>Entering Animations</h2>

                <p>Entering animations run when a component mounts. Reanimated provides many built-in presets that you can use directly or customize.</p>

                <h3>Built-in Entering Animations</h3>

                <pre><code>import Animated, {
  // Fade animations
  FadeIn,
  FadeInUp,
  FadeInDown,
  FadeInLeft,
  FadeInRight,
  
  // Slide animations
  SlideInUp,
  SlideInDown,
  SlideInLeft,
  SlideInRight,
  
  // Zoom animations
  ZoomIn,
  ZoomInUp,
  ZoomInDown,
  ZoomInLeft,
  ZoomInRight,
  ZoomInRotate,
  ZoomInEasyUp,
  ZoomInEasyDown,
  
  // Bounce animations
  BounceIn,
  BounceInUp,
  BounceInDown,
  BounceInLeft,
  BounceInRight,
  
  // Flip animations
  FlipInXUp,
  FlipInXDown,
  FlipInYLeft,
  FlipInYRight,
  FlipInEasyX,
  FlipInEasyY,
  
  // Stretch animations
  StretchInX,
  StretchInY,
  
  // LightSpeed animations
  LightSpeedInLeft,
  LightSpeedInRight,
  
  // Pinwheel
  PinwheelIn,
  
  // Roll
  RollInLeft,
  RollInRight,
  
  // Rotate
  RotateInUpLeft,
  RotateInUpRight,
  RotateInDownLeft,
  RotateInDownRight,
} from 'react-native-reanimated';

// Simple usage
function EnteringExample() {
  return (
    &lt;Animated.View entering={FadeInUp}&gt;
      &lt;Text&gt;I fade in from above!&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Customizing Entering Animations</h3>

                <pre><code>import Animated, {
  FadeIn,
  SlideInRight,
  ZoomIn,
  BounceIn,
} from 'react-native-reanimated';

function CustomEnteringExample() {
  return (
    &lt;View&gt;
      {/* Custom duration */}
      &lt;Animated.View entering={FadeIn.duration(800)}&gt;
        &lt;Text&gt;Slow fade in (800ms)&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Custom delay */}
      &lt;Animated.View entering={SlideInRight.delay(300)}&gt;
        &lt;Text&gt;Delayed slide in&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Spring physics */}
      &lt;Animated.View entering={ZoomIn.springify()}&gt;
        &lt;Text&gt;Bouncy zoom in&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Custom spring config */}
      &lt;Animated.View 
        entering={BounceIn.springify()
          .damping(12)
          .stiffness(100)
          .mass(0.5)}
      &gt;
        &lt;Text&gt;Custom spring bounce&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Chained customizations */}
      &lt;Animated.View 
        entering={FadeIn
          .delay(200)
          .duration(500)
          .withInitialValues({ opacity: 0.5 })}
      &gt;
        &lt;Text&gt;Start from 50% opacity&lt;/Text&gt;
      &lt;/Animated.View&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Staggered Entering</h3>

                <pre><code>import Animated, { FadeInUp } from 'react-native-reanimated';

function StaggeredList() {
  const items = ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'];
  
  return (
    &lt;View&gt;
      {items.map((item, index) => (
        &lt;Animated.View
          key={item}
          entering={FadeInUp.delay(index * 100).springify()}
          style={styles.listItem}
        &gt;
          &lt;Text&gt;{item}&lt;/Text&gt;
        &lt;/Animated.View&gt;
      ))}
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Callback on Animation Complete</h3>

                <pre><code>import Animated, { FadeIn, runOnJS } from 'react-native-reanimated';

function CallbackExample() {
  const [animationComplete, setAnimationComplete] = useState(false);
  
  const handleAnimationComplete = () => {
    setAnimationComplete(true);
    console.log('Entering animation finished!');
  };
  
  return (
    &lt;Animated.View
      entering={FadeIn.duration(500).withCallback((finished) => {
        'worklet';
        if (finished) {
          runOnJS(handleAnimationComplete)();
        }
      })}
    &gt;
      &lt;Text&gt;Watch for callback&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Custom Entering Animation</h3>

                <pre><code>import Animated, { withTiming, withSpring } from 'react-native-reanimated';

// Define a custom entering animation
const CustomEntering = (targetValues) => {
  'worklet';
  const animations = {
    opacity: withTiming(1, { duration: 500 }),
    transform: [
      { translateY: withSpring(0, { damping: 15 }) },
      { scale: withSpring(1, { damping: 12 }) },
      { rotate: withTiming('0deg', { duration: 400 }) },
    ],
  };
  
  const initialValues = {
    opacity: 0,
    transform: [
      { translateY: 100 },
      { scale: 0.5 },
      { rotate: '-45deg' },
    ],
  };
  
  return {
    initialValues,
    animations,
  };
};

// Use the custom animation
function CustomEnteringExample() {
  return (
    &lt;Animated.View entering={CustomEntering} style={styles.box}&gt;
      &lt;Text&gt;Custom animation!&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Entering Animation Reference</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Category</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Animations</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Best For</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Fade</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>FadeIn</code>, <code>FadeInUp/Down/Left/Right</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Subtle, elegant appearance</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Slide</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>SlideInUp/Down/Left/Right</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Drawers, sheets, menus</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Zoom</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>ZoomIn</code>, <code>ZoomInRotate</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Modals, popups, emphasis</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Bounce</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>BounceIn</code>, <code>BounceInUp/Down</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Playful UI, notifications</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Flip</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>FlipInX/Y</code>, <code>FlipInEasyX/Y</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Card reveals, transitions</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Exiting Animations -->
            <section id="exiting-animations">
                <h2>Exiting Animations</h2>

                <p>Exiting animations run when a component unmounts. They delay the actual removal until the animation completes, creating smooth transitions.</p>

                <h3>Built-in Exiting Animations</h3>

                <pre><code>import Animated, {
  // Fade animations
  FadeOut,
  FadeOutUp,
  FadeOutDown,
  FadeOutLeft,
  FadeOutRight,
  
  // Slide animations
  SlideOutUp,
  SlideOutDown,
  SlideOutLeft,
  SlideOutRight,
  
  // Zoom animations
  ZoomOut,
  ZoomOutUp,
  ZoomOutDown,
  ZoomOutLeft,
  ZoomOutRight,
  ZoomOutRotate,
  ZoomOutEasyUp,
  ZoomOutEasyDown,
  
  // Bounce animations
  BounceOut,
  BounceOutUp,
  BounceOutDown,
  BounceOutLeft,
  BounceOutRight,
  
  // Flip animations
  FlipOutXUp,
  FlipOutXDown,
  FlipOutYLeft,
  FlipOutYRight,
  FlipOutEasyX,
  FlipOutEasyY,
  
  // Other
  StretchOutX,
  StretchOutY,
  LightSpeedOutLeft,
  LightSpeedOutRight,
  PinwheelOut,
  RollOutLeft,
  RollOutRight,
  RotateOutUpLeft,
  RotateOutUpRight,
  RotateOutDownLeft,
  RotateOutDownRight,
} from 'react-native-reanimated';

function ExitingExample() {
  const [visible, setVisible] = useState(true);
  
  return (
    &lt;View&gt;
      &lt;Pressable onPress={() => setVisible(!visible)}&gt;
        &lt;Text&gt;Toggle&lt;/Text&gt;
      &lt;/Pressable&gt;
      
      {visible && (
        &lt;Animated.View
          entering={FadeIn}
          exiting={FadeOutDown.duration(300)}
          style={styles.box}
        &gt;
          &lt;Text&gt;I fade out downward!&lt;/Text&gt;
        &lt;/Animated.View&gt;
      )}
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Matching Entering and Exiting</h3>

                <pre><code>import Animated, {
  SlideInRight,
  SlideOutRight,
  ZoomIn,
  ZoomOut,
  FadeInUp,
  FadeOutDown,
} from 'react-native-reanimated';

function MatchedAnimations() {
  const [items, setItems] = useState(['a', 'b', 'c']);
  
  const addItem = () => {
    setItems([...items, Date.now().toString()]);
  };
  
  const removeItem = (id: string) => {
    setItems(items.filter(item => item !== id));
  };
  
  return (
    &lt;View&gt;
      {items.map((item) => (
        &lt;Animated.View
          key={item}
          entering={SlideInRight.springify()}
          exiting={SlideOutRight.duration(200)}
          style={styles.item}
        &gt;
          &lt;Text&gt;{item}&lt;/Text&gt;
          &lt;Pressable onPress={() => removeItem(item)}&gt;
            &lt;Text&gt;√ó&lt;/Text&gt;
          &lt;/Pressable&gt;
        &lt;/Animated.View&gt;
      ))}
      
      &lt;Pressable onPress={addItem}&gt;
        &lt;Text&gt;Add Item&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Custom Exiting Animation</h3>

                <pre><code>import Animated, { withTiming, withSpring } from 'react-native-reanimated';

const CustomExiting = (values) => {
  'worklet';
  const animations = {
    opacity: withTiming(0, { duration: 300 }),
    transform: [
      { translateX: withTiming(values.currentWidth, { duration: 300 }) },
      { scale: withTiming(0.8, { duration: 300 }) },
      { rotate: withTiming('15deg', { duration: 300 }) },
    ],
  };
  
  const initialValues = {
    opacity: 1,
    transform: [
      { translateX: 0 },
      { scale: 1 },
      { rotate: '0deg' },
    ],
  };
  
  return {
    initialValues,
    animations,
  };
};

function CustomExitExample() {
  const [visible, setVisible] = useState(true);
  
  return (
    &lt;View&gt;
      {visible && (
        &lt;Animated.View
          entering={FadeIn}
          exiting={CustomExiting}
          style={styles.box}
        &gt;
          &lt;Text&gt;Custom exit animation!&lt;/Text&gt;
        &lt;/Animated.View&gt;
      )}
    &lt;/View&gt;
  );
}</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Notes</h4>
                    <ul>
                        <li>Exiting animations only work when the component is conditionally rendered</li>
                        <li>The component must have a unique <code>key</code> prop for proper tracking</li>
                        <li>Parent components must be <code>Animated.View</code> or wrapped properly</li>
                        <li>Exiting delays actual unmount‚Äîdon't rely on immediate cleanup</li>
                    </ul>
                </div>
            </section>
            <!-- Layout Transitions -->
            <section id="layout-transitions">
                <h2>Layout Transitions</h2>

                <p>Layout transitions animate components when their position or size changes within the layout. This creates fluid, natural-feeling interfaces where elements smoothly shift to accommodate changes.</p>

                <h3>Basic Layout Transition</h3>

                <pre><code>import Animated, { Layout } from 'react-native-reanimated';

function LayoutTransitionExample() {
  const [expanded, setExpanded] = useState(false);
  
  return (
    &lt;View&gt;
      &lt;Pressable onPress={() => setExpanded(!expanded)}&gt;
        &lt;Animated.View
          layout={Layout.springify()}
          style={[
            styles.box,
            expanded && styles.expandedBox,
          ]}
        &gt;
          &lt;Text&gt;{expanded ? 'Expanded' : 'Tap to expand'}&lt;/Text&gt;
        &lt;/Animated.View&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  box: {
    width: 100,
    height: 100,
    backgroundColor: '#007AFF',
    justifyContent: 'center',
    alignItems: 'center',
  },
  expandedBox: {
    width: 200,
    height: 200,
  },
});</code></pre>

                <h3>Layout Animation Types</h3>

                <pre><code>import Animated, {
  Layout,
  LinearTransition,
  SequencedTransition,
  FadingTransition,
  JumpingTransition,
  CurvedTransition,
  EntryExitTransition,
  Easing,
} from 'react-native-reanimated';

function LayoutTypesExample() {
  return (
    &lt;View&gt;
      {/* Default spring-based layout */}
      &lt;Animated.View layout={Layout}&gt;
        &lt;Text&gt;Default Layout&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Spring with customization */}
      &lt;Animated.View 
        layout={Layout.springify().damping(15).stiffness(100)}
      &gt;
        &lt;Text&gt;Springy Layout&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Linear timing-based */}
      &lt;Animated.View layout={LinearTransition.duration(300)}&gt;
        &lt;Text&gt;Linear Transition&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* With easing */}
      &lt;Animated.View 
        layout={LinearTransition
          .duration(400)
          .easing(Easing.bezier(0.25, 0.1, 0.25, 1))}
      &gt;
        &lt;Text&gt;Eased Transition&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Sequenced (width then height) */}
      &lt;Animated.View layout={SequencedTransition}&gt;
        &lt;Text&gt;Sequenced Transition&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Fading transition */}
      &lt;Animated.View layout={FadingTransition}&gt;
        &lt;Text&gt;Fading Transition&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Jumping transition */}
      &lt;Animated.View layout={JumpingTransition}&gt;
        &lt;Text&gt;Jumping Transition&lt;/Text&gt;
      &lt;/Animated.View&gt;
      
      {/* Curved transition */}
      &lt;Animated.View layout={CurvedTransition}&gt;
        &lt;Text&gt;Curved Transition&lt;/Text&gt;
      &lt;/Animated.View&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Reordering Items</h3>

                <pre><code>import React, { useState } from 'react';
import { StyleSheet, View, Text, Pressable } from 'react-native';
import Animated, { Layout, FadeIn, FadeOut } from 'react-native-reanimated';

interface Item {
  id: string;
  title: string;
  color: string;
}

function ReorderingList() {
  const [items, setItems] = useState&lt;Item[]&gt;([
    { id: '1', title: 'Red', color: '#FF3B30' },
    { id: '2', title: 'Orange', color: '#FF9500' },
    { id: '3', title: 'Yellow', color: '#FFCC00' },
    { id: '4', title: 'Green', color: '#34C759' },
    { id: '5', title: 'Blue', color: '#007AFF' },
  ]);
  
  const shuffle = () => {
    setItems([...items].sort(() => Math.random() - 0.5));
  };
  
  const reverse = () => {
    setItems([...items].reverse());
  };
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.buttons}&gt;
        &lt;Pressable style={styles.button} onPress={shuffle}&gt;
          &lt;Text style={styles.buttonText}&gt;Shuffle&lt;/Text&gt;
        &lt;/Pressable&gt;
        &lt;Pressable style={styles.button} onPress={reverse}&gt;
          &lt;Text style={styles.buttonText}&gt;Reverse&lt;/Text&gt;
        &lt;/Pressable&gt;
      &lt;/View&gt;
      
      &lt;View style={styles.list}&gt;
        {items.map((item) => (
          &lt;Animated.View
            key={item.id}
            layout={Layout.springify().damping(15)}
            style={[styles.item, { backgroundColor: item.color }]}
          &gt;
            &lt;Text style={styles.itemText}&gt;{item.title}&lt;/Text&gt;
          &lt;/Animated.View&gt;
        ))}
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  buttons: {
    flexDirection: 'row',
    marginBottom: 20,
    gap: 10,
  },
  button: {
    backgroundColor: '#333',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  buttonText: {
    color: 'white',
    fontWeight: '600',
  },
  list: {
    gap: 10,
  },
  item: {
    padding: 20,
    borderRadius: 12,
    alignItems: 'center',
  },
  itemText: {
    color: 'white',
    fontSize: 18,
    fontWeight: '600',
  },
});</code></pre>

                <h3>Accordion with Layout Animation</h3>

                <pre><code>import React, { useState } from 'react';
import { StyleSheet, View, Text, Pressable } from 'react-native';
import Animated, { 
  Layout, 
  FadeIn, 
  FadeOut,
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} from 'react-native-reanimated';

interface AccordionProps {
  title: string;
  children: React.ReactNode;
}

function Accordion({ title, children }: AccordionProps) {
  const [expanded, setExpanded] = useState(false);
  const rotation = useSharedValue(0);
  
  const toggle = () => {
    setExpanded(!expanded);
    rotation.value = withTiming(expanded ? 0 : 90, { duration: 200 });
  };
  
  const chevronStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }],
  }));
  
  return (
    &lt;Animated.View layout={Layout.springify()} style={styles.accordion}&gt;
      &lt;Pressable onPress={toggle} style={styles.header}&gt;
        &lt;Text style={styles.title}&gt;{title}&lt;/Text&gt;
        &lt;Animated.Text style={[styles.chevron, chevronStyle]}&gt;
          ‚ñ∂
        &lt;/Animated.Text&gt;
      &lt;/Pressable&gt;
      
      {expanded && (
        &lt;Animated.View
          entering={FadeIn.duration(200)}
          exiting={FadeOut.duration(200)}
          style={styles.content}
        &gt;
          {children}
        &lt;/Animated.View&gt;
      )}
    &lt;/Animated.View&gt;
  );
}

function AccordionExample() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Accordion title="Section 1"&gt;
        &lt;Text&gt;Content for section 1. This can be any length.&lt;/Text&gt;
      &lt;/Accordion&gt;
      
      &lt;Accordion title="Section 2"&gt;
        &lt;Text&gt;Content for section 2. 
          Lorem ipsum dolor sit amet, consectetur adipiscing elit.
          Sed do eiusmod tempor incididunt ut labore.
        &lt;/Text&gt;
      &lt;/Accordion&gt;
      
      &lt;Accordion title="Section 3"&gt;
        &lt;Text&gt;Short content.&lt;/Text&gt;
      &lt;/Accordion&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    gap: 8,
  },
  accordion: {
    backgroundColor: 'white',
    borderRadius: 12,
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
  },
  chevron: {
    fontSize: 12,
    color: '#666',
  },
  content: {
    padding: 16,
    paddingTop: 0,
  },
});</code></pre>

                <h3>Grid Layout Animation</h3>

                <pre><code>import React, { useState } from 'react';
import { StyleSheet, View, Pressable, Text, Dimensions } from 'react-native';
import Animated, { Layout, FadeIn, FadeOut } from 'react-native-reanimated';

const { width } = Dimensions.get('window');
const COLUMNS = 3;
const GAP = 10;
const ITEM_SIZE = (width - 40 - (COLUMNS - 1) * GAP) / COLUMNS;

function AnimatedGrid() {
  const [items, setItems] = useState(
    Array.from({ length: 9 }, (_, i) => ({
      id: `item-${i}`,
      visible: true,
    }))
  );
  
  const toggleItem = (id: string) => {
    setItems(items.map(item =>
      item.id === id ? { ...item, visible: !item.visible } : item
    ));
  };
  
  const visibleItems = items.filter(item => item.visible);
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.grid}&gt;
        {visibleItems.map((item) => (
          &lt;Animated.View
            key={item.id}
            layout={Layout.springify().damping(15)}
            entering={FadeIn.springify()}
            exiting={FadeOut.duration(200)}
          &gt;
            &lt;Pressable
              style={styles.gridItem}
              onPress={() => toggleItem(item.id)}
            &gt;
              &lt;Text style={styles.itemText}&gt;√ó&lt;/Text&gt;
            &lt;/Pressable&gt;
          &lt;/Animated.View&gt;
        ))}
      &lt;/View&gt;
      
      &lt;Pressable
        style={styles.resetButton}
        onPress={() => setItems(items.map(item => ({ ...item, visible: true })))}
      &gt;
        &lt;Text style={styles.resetText}&gt;Reset All&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  grid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: GAP,
  },
  gridItem: {
    width: ITEM_SIZE,
    height: ITEM_SIZE,
    backgroundColor: '#007AFF',
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  itemText: {
    color: 'white',
    fontSize: 24,
  },
  resetButton: {
    marginTop: 20,
    backgroundColor: '#34C759',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  resetText: {
    color: 'white',
    fontWeight: '600',
  },
});</code></pre>
            </section>

            <!-- Keyframes -->
            <section id="keyframes">
                <h2>Keyframe Animations</h2>

                <p>Keyframe animations let you define multi-step animations with precise control over timing and values at each step.</p>

                <h3>Basic Keyframe Animation</h3>

                <pre><code>import Animated, { Keyframe } from 'react-native-reanimated';

// Define a keyframe animation
const bounceKeyframe = new Keyframe({
  0: {
    transform: [{ scale: 0 }],
    opacity: 0,
  },
  25: {
    transform: [{ scale: 1.2 }],
    opacity: 1,
  },
  50: {
    transform: [{ scale: 0.9 }],
  },
  75: {
    transform: [{ scale: 1.1 }],
  },
  100: {
    transform: [{ scale: 1 }],
  },
}).duration(800);

function KeyframeExample() {
  const [visible, setVisible] = useState(true);
  
  return (
    &lt;View&gt;
      &lt;Pressable onPress={() => setVisible(!visible)}&gt;
        &lt;Text&gt;Toggle&lt;/Text&gt;
      &lt;/Pressable&gt;
      
      {visible && (
        &lt;Animated.View
          entering={bounceKeyframe}
          style={styles.box}
        &gt;
          &lt;Text&gt;Bounce In!&lt;/Text&gt;
        &lt;/Animated.View&gt;
      )}
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Complex Keyframe Animations</h3>

                <pre><code>import Animated, { Keyframe, Easing } from 'react-native-reanimated';

// Shake animation
const shakeKeyframe = new Keyframe({
  0: { transform: [{ translateX: 0 }] },
  10: { transform: [{ translateX: -10 }] },
  20: { transform: [{ translateX: 10 }] },
  30: { transform: [{ translateX: -10 }] },
  40: { transform: [{ translateX: 10 }] },
  50: { transform: [{ translateX: -5 }] },
  60: { transform: [{ translateX: 5 }] },
  70: { transform: [{ translateX: -2 }] },
  80: { transform: [{ translateX: 2 }] },
  100: { transform: [{ translateX: 0 }] },
}).duration(500);

// Attention pulse
const pulseKeyframe = new Keyframe({
  0: { 
    transform: [{ scale: 1 }],
    opacity: 1,
  },
  50: { 
    transform: [{ scale: 1.05 }],
    opacity: 0.8,
  },
  100: { 
    transform: [{ scale: 1 }],
    opacity: 1,
  },
}).duration(1000);

// Swing animation
const swingKeyframe = new Keyframe({
  0: { transform: [{ rotate: '0deg' }] },
  20: { transform: [{ rotate: '15deg' }] },
  40: { transform: [{ rotate: '-10deg' }] },
  60: { transform: [{ rotate: '5deg' }] },
  80: { transform: [{ rotate: '-5deg' }] },
  100: { transform: [{ rotate: '0deg' }] },
}).duration(800);

// Flip animation
const flipKeyframe = new Keyframe({
  0: {
    transform: [{ perspective: 400 }, { rotateY: '0deg' }],
    opacity: 1,
  },
  40: {
    transform: [{ perspective: 400 }, { rotateY: '-180deg' }],
    opacity: 0,
  },
  60: {
    transform: [{ perspective: 400 }, { rotateY: '-180deg' }],
    opacity: 0,
  },
  100: {
    transform: [{ perspective: 400 }, { rotateY: '-360deg' }],
    opacity: 1,
  },
}).duration(1000);

// Heartbeat animation
const heartbeatKeyframe = new Keyframe({
  0: { transform: [{ scale: 1 }] },
  14: { transform: [{ scale: 1.3 }] },
  28: { transform: [{ scale: 1 }] },
  42: { transform: [{ scale: 1.3 }] },
  70: { transform: [{ scale: 1 }] },
  100: { transform: [{ scale: 1 }] },
}).duration(1300);</code></pre>

                <h3>Keyframe with Easing</h3>

                <pre><code>import Animated, { Keyframe, Easing } from 'react-native-reanimated';

// Keyframe with custom easing per segment
const elasticEnterKeyframe = new Keyframe({
  0: {
    transform: [{ translateY: -100 }, { scale: 0 }],
    opacity: 0,
    easing: Easing.out(Easing.exp),
  },
  60: {
    transform: [{ translateY: 20 }, { scale: 1.1 }],
    opacity: 1,
    easing: Easing.out(Easing.bounce),
  },
  100: {
    transform: [{ translateY: 0 }, { scale: 1 }],
    opacity: 1,
  },
}).duration(1000);

// Delayed keyframe
const delayedBounceKeyframe = new Keyframe({
  0: {
    transform: [{ translateY: 0 }],
  },
  50: {
    transform: [{ translateY: 0 }],
  },
  65: {
    transform: [{ translateY: -30 }],
  },
  80: {
    transform: [{ translateY: 0 }],
  },
  90: {
    transform: [{ translateY: -15 }],
  },
  100: {
    transform: [{ translateY: 0 }],
  },
}).duration(1500);</code></pre>

                <h3>Reusable Keyframe Components</h3>

                <pre><code>import React from 'react';
import Animated, { Keyframe } from 'react-native-reanimated';

// Define animation keyframes
const animations = {
  fadeInUp: new Keyframe({
    0: {
      opacity: 0,
      transform: [{ translateY: 30 }],
    },
    100: {
      opacity: 1,
      transform: [{ translateY: 0 }],
    },
  }).duration(400),
  
  fadeOutDown: new Keyframe({
    0: {
      opacity: 1,
      transform: [{ translateY: 0 }],
    },
    100: {
      opacity: 0,
      transform: [{ translateY: 30 }],
    },
  }).duration(300),
  
  popIn: new Keyframe({
    0: {
      transform: [{ scale: 0 }],
      opacity: 0,
    },
    70: {
      transform: [{ scale: 1.1 }],
      opacity: 1,
    },
    100: {
      transform: [{ scale: 1 }],
      opacity: 1,
    },
  }).duration(350),
};

// Reusable animated wrapper
interface AnimatedItemProps {
  animation?: keyof typeof animations;
  delay?: number;
  children: React.ReactNode;
}

function AnimatedItem({ 
  animation = 'fadeInUp', 
  delay = 0, 
  children 
}: AnimatedItemProps) {
  const keyframe = animations[animation].delay(delay);
  
  return (
    &lt;Animated.View entering={keyframe}&gt;
      {children}
    &lt;/Animated.View&gt;
  );
}

// Usage
function AnimatedList() {
  return (
    &lt;View&gt;
      &lt;AnimatedItem delay={0}&gt;
        &lt;Text&gt;First&lt;/Text&gt;
      &lt;/AnimatedItem&gt;
      &lt;AnimatedItem delay={100}&gt;
        &lt;Text&gt;Second&lt;/Text&gt;
      &lt;/AnimatedItem&gt;
      &lt;AnimatedItem animation="popIn" delay={200}&gt;
        &lt;Text&gt;Third (pop)&lt;/Text&gt;
      &lt;/AnimatedItem&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Keyframe Tips</h4>
                    <ul>
                        <li>Percentages (0-100) define timing within the total duration</li>
                        <li>You can skip percentages‚Äîintermediate values are interpolated</li>
                        <li>Add <code>easing</code> to individual keyframes for segment-specific easing</li>
                        <li>Use <code>.delay()</code> to add a delay before the animation starts</li>
                        <li>Chain multiple keyframes with <code>.withCallback()</code> for notifications</li>
                    </ul>
                </div>
            </section>
            <!-- List Animations -->
            <section id="list-animations">
                <h2>Animating Lists</h2>

                <p>Lists are one of the most common places to apply layout animations. Whether using FlatList, ScrollView, or simple maps, animations make list interactions feel polished and responsive.</p>

                <h3>Animated FlatList Items</h3>

                <pre><code>import React, { useState, useCallback } from 'react';
import { StyleSheet, View, Text, FlatList, Pressable } from 'react-native';
import Animated, {
  FadeInRight,
  FadeOutLeft,
  Layout,
} from 'react-native-reanimated';

interface ListItem {
  id: string;
  title: string;
}

function AnimatedFlatList() {
  const [items, setItems] = useState&lt;ListItem[]&gt;([
    { id: '1', title: 'First Item' },
    { id: '2', title: 'Second Item' },
    { id: '3', title: 'Third Item' },
  ]);
  
  const addItem = () => {
    const newItem = {
      id: Date.now().toString(),
      title: `Item ${items.length + 1}`,
    };
    setItems([newItem, ...items]);
  };
  
  const removeItem = (id: string) => {
    setItems(items.filter(item => item.id !== id));
  };
  
  const renderItem = useCallback(({ item, index }: { item: ListItem; index: number }) => (
    &lt;Animated.View
      entering={FadeInRight.delay(index * 50).springify()}
      exiting={FadeOutLeft.duration(200)}
      layout={Layout.springify()}
      style={styles.item}
    &gt;
      &lt;Text style={styles.itemText}&gt;{item.title}&lt;/Text&gt;
      &lt;Pressable
        style={styles.deleteButton}
        onPress={() => removeItem(item.id)}
      &gt;
        &lt;Text style={styles.deleteText}&gt;Delete&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/Animated.View&gt;
  ), []);
  
  return (
    &lt;View style={styles.container}&gt;
      &lt;Pressable style={styles.addButton} onPress={addItem}&gt;
        &lt;Text style={styles.addText}&gt;Add Item&lt;/Text&gt;
      &lt;/Pressable&gt;
      
      &lt;FlatList
        data={items}
        renderItem={renderItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.list}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  addButton: {
    backgroundColor: '#34C759',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginBottom: 16,
  },
  addText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 16,
  },
  list: {
    gap: 8,
  },
  item: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'white',
    padding: 16,
    borderRadius: 12,
  },
  itemText: {
    fontSize: 16,
  },
  deleteButton: {
    backgroundColor: '#FF3B30',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  deleteText: {
    color: 'white',
    fontWeight: '600',
  },
});</code></pre>

                <h3>Staggered List with Different Animations</h3>

                <pre><code>import React, { useState, useEffect } from 'react';
import { StyleSheet, View, Text, ScrollView } from 'react-native';
import Animated, {
  FadeInDown,
  FadeInLeft,
  FadeInRight,
  ZoomIn,
  BounceIn,
  SlideInRight,
} from 'react-native-reanimated';

// Different animations for variety
const animations = [
  FadeInDown,
  FadeInLeft,
  FadeInRight,
  ZoomIn,
  BounceIn,
  SlideInRight,
];

interface CardData {
  id: string;
  title: string;
  description: string;
}

function StaggeredCards() {
  const [cards, setCards] = useState&lt;CardData[]&gt;([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Simulate data fetch
    setTimeout(() => {
      setCards([
        { id: '1', title: 'Card 1', description: 'First card description' },
        { id: '2', title: 'Card 2', description: 'Second card description' },
        { id: '3', title: 'Card 3', description: 'Third card description' },
        { id: '4', title: 'Card 4', description: 'Fourth card description' },
        { id: '5', title: 'Card 5', description: 'Fifth card description' },
        { id: '6', title: 'Card 6', description: 'Sixth card description' },
      ]);
      setLoading(false);
    }, 500);
  }, []);
  
  if (loading) {
    return (
      &lt;View style={styles.loading}&gt;
        &lt;Text&gt;Loading...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
  
  return (
    &lt;ScrollView style={styles.container} contentContainerStyle={styles.content}&gt;
      {cards.map((card, index) => {
        const Animation = animations[index % animations.length];
        
        return (
          &lt;Animated.View
            key={card.id}
            entering={Animation.delay(index * 100).springify()}
            style={styles.card}
          &gt;
            &lt;Text style={styles.cardTitle}&gt;{card.title}&lt;/Text&gt;
            &lt;Text style={styles.cardDescription}&gt;{card.description}&lt;/Text&gt;
          &lt;/Animated.View&gt;
        );
      })}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    padding: 16,
    gap: 12,
  },
  loading: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  card: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 8,
  },
  cardDescription: {
    fontSize: 14,
    color: '#666',
  },
});</code></pre>

                <h3>Swipeable List Item</h3>

                <pre><code>import React, { useState } from 'react';
import { StyleSheet, View, Text, FlatList, Dimensions } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  FadeIn,
  FadeOut,
  Layout,
} from 'react-native-reanimated';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const SWIPE_THRESHOLD = -80;

interface Task {
  id: string;
  title: string;
  completed: boolean;
}

function SwipeableTask({ 
  task, 
  onDelete,
  onToggle,
}: { 
  task: Task; 
  onDelete: (id: string) => void;
  onToggle: (id: string) => void;
}) {
  const translateX = useSharedValue(0);
  
  const panGesture = Gesture.Pan()
    .activeOffsetX([-10, 10])
    .onUpdate((event) => {
      translateX.value = Math.min(0, Math.max(-120, event.translationX));
    })
    .onEnd((event) => {
      if (translateX.value < SWIPE_THRESHOLD || event.velocityX < -500) {
        translateX.value = withTiming(-120);
      } else {
        translateX.value = withSpring(0);
      }
    });
  
  const handleDelete = () => {
    translateX.value = withTiming(-SCREEN_WIDTH, { duration: 200 }, () => {
      runOnJS(onDelete)(task.id);
    });
  };
  
  const taskStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));
  
  return (
    &lt;Animated.View
      entering={FadeIn.springify()}
      exiting={FadeOut.duration(200)}
      layout={Layout.springify()}
      style={styles.taskContainer}
    &gt;
      {/* Delete button behind */}
      &lt;View style={styles.deleteAction}&gt;
        &lt;GestureDetector gesture={Gesture.Tap().onEnd(handleDelete)}&gt;
          &lt;View style={styles.deleteButton}&gt;
            &lt;Text style={styles.deleteText}&gt;üóëÔ∏è&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/GestureDetector&gt;
      &lt;/View&gt;
      
      {/* Swipeable task */}
      &lt;GestureDetector gesture={panGesture}&gt;
        &lt;Animated.View style={[styles.task, taskStyle]}&gt;
          &lt;GestureDetector 
            gesture={Gesture.Tap().onEnd(() => onToggle(task.id))}
          &gt;
            &lt;View style={styles.checkbox}&gt;
              {task.completed && &lt;Text&gt;‚úì&lt;/Text&gt;}
            &lt;/View&gt;
          &lt;/GestureDetector&gt;
          &lt;Text 
            style={[
              styles.taskTitle, 
              task.completed && styles.completedTask
            ]}
          &gt;
            {task.title}
          &lt;/Text&gt;
        &lt;/Animated.View&gt;
      &lt;/GestureDetector&gt;
    &lt;/Animated.View&gt;
  );
}

function TaskList() {
  const [tasks, setTasks] = useState&lt;Task[]&gt;([
    { id: '1', title: 'Buy groceries', completed: false },
    { id: '2', title: 'Call mom', completed: true },
    { id: '3', title: 'Finish project', completed: false },
    { id: '4', title: 'Go to gym', completed: false },
  ]);
  
  const deleteTask = (id: string) => {
    setTasks(tasks.filter(t => t.id !== id));
  };
  
  const toggleTask = (id: string) => {
    setTasks(tasks.map(t => 
      t.id === id ? { ...t, completed: !t.completed } : t
    ));
  };
  
  return (
    &lt;FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={({ item }) => (
        &lt;SwipeableTask 
          task={item} 
          onDelete={deleteTask}
          onToggle={toggleTask}
        /&gt;
      )}
      contentContainerStyle={styles.list}
    /&gt;
  );
}

const styles = StyleSheet.create({
  list: {
    padding: 16,
    gap: 8,
  },
  taskContainer: {
    position: 'relative',
    overflow: 'hidden',
    borderRadius: 12,
  },
  deleteAction: {
    position: 'absolute',
    right: 0,
    top: 0,
    bottom: 0,
    width: 120,
    backgroundColor: '#FF3B30',
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 12,
  },
  deleteButton: {
    padding: 20,
  },
  deleteText: {
    fontSize: 24,
  },
  task: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    padding: 16,
    borderRadius: 12,
  },
  checkbox: {
    width: 24,
    height: 24,
    borderWidth: 2,
    borderColor: '#007AFF',
    borderRadius: 6,
    marginRight: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  taskTitle: {
    fontSize: 16,
    flex: 1,
  },
  completedTask: {
    textDecorationLine: 'line-through',
    color: '#999',
  },
});</code></pre>

                <h3>Animated Section List</h3>

                <pre><code>import React, { useState } from 'react';
import { StyleSheet, View, Text, SectionList, Pressable } from 'react-native';
import Animated, {
  FadeInRight,
  FadeOutLeft,
  Layout,
  SlideInDown,
} from 'react-native-reanimated';

interface Section {
  title: string;
  data: { id: string; name: string }[];
}

function AnimatedSectionList() {
  const [sections, setSections] = useState&lt;Section[]&gt;([
    {
      title: 'Favorites',
      data: [
        { id: '1', name: 'Item A' },
        { id: '2', name: 'Item B' },
      ],
    },
    {
      title: 'Recent',
      data: [
        { id: '3', name: 'Item C' },
        { id: '4', name: 'Item D' },
        { id: '5', name: 'Item E' },
      ],
    },
    {
      title: 'All',
      data: [
        { id: '6', name: 'Item F' },
        { id: '7', name: 'Item G' },
      ],
    },
  ]);
  
  const removeItem = (sectionTitle: string, itemId: string) => {
    setSections(sections.map(section => 
      section.title === sectionTitle
        ? { ...section, data: section.data.filter(item => item.id !== itemId) }
        : section
    ).filter(section => section.data.length > 0));
  };
  
  return (
    &lt;SectionList
      sections={sections}
      keyExtractor={(item) => item.id}
      renderSectionHeader={({ section }) => (
        &lt;Animated.View
          entering={SlideInDown.springify()}
          style={styles.sectionHeader}
        &gt;
          &lt;Text style={styles.sectionTitle}&gt;{section.title}&lt;/Text&gt;
        &lt;/Animated.View&gt;
      )}
      renderItem={({ item, index, section }) => (
        &lt;Animated.View
          entering={FadeInRight.delay(index * 50).springify()}
          exiting={FadeOutLeft.duration(200)}
          layout={Layout.springify()}
          style={styles.item}
        &gt;
          &lt;Text style={styles.itemName}&gt;{item.name}&lt;/Text&gt;
          &lt;Pressable onPress={() => removeItem(section.title, item.id)}&gt;
            &lt;Text style={styles.removeButton}&gt;√ó&lt;/Text&gt;
          &lt;/Pressable&gt;
        &lt;/Animated.View&gt;
      )}
      contentContainerStyle={styles.container}
    /&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
  sectionHeader: {
    backgroundColor: '#f5f5f5',
    padding: 12,
    marginTop: 16,
    marginBottom: 8,
    borderRadius: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#666',
    textTransform: 'uppercase',
  },
  item: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'white',
    padding: 16,
    marginBottom: 8,
    borderRadius: 12,
  },
  itemName: {
    fontSize: 16,
  },
  removeButton: {
    fontSize: 24,
    color: '#999',
  },
});</code></pre>
            </section>

            <!-- Shared Transitions -->
            <section id="shared-transitions">
                <h2>Shared Element Transitions</h2>

                <p>Shared element transitions create visual continuity between screens by animating an element from one position/size to another. This is commonly used in photo galleries, product detail views, and card expansions.</p>

                <h3>Basic Shared Transition Concept</h3>

                <pre class="mermaid">
flowchart LR
    subgraph List["List Screen"]
        A["üñºÔ∏è Small thumbnail"]
        B[Title text]
    end
    
    subgraph Detail["Detail Screen"]
        C["üñºÔ∏è Large image"]
        D[Full content]
    end
    
    A -->|"Shared transition"| C
    B -.->|Fade| D
    
    style List fill:#e3f2fd
    style Detail fill:#e8f5e9
</pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Note on Shared Element Transitions</h4>
                    <p>True shared element transitions (like React Navigation's shared element) require additional setup and libraries. Here we'll demonstrate the concept using Reanimated's layout animations to achieve similar effects within a single screen.</p>
                </div>

                <h3>Expandable Card Pattern</h3>

                <pre><code>import React, { useState } from 'react';
import { StyleSheet, View, Text, Image, Pressable, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  interpolate,
  FadeIn,
  FadeOut,
} from 'react-native-reanimated';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

interface Card {
  id: string;
  title: string;
  image: string;
  description: string;
}

function ExpandableCard({ card }: { card: Card }) {
  const [expanded, setExpanded] = useState(false);
  const progress = useSharedValue(0);
  
  const toggle = () => {
    setExpanded(!expanded);
    progress.value = withSpring(expanded ? 0 : 1, {
      damping: 15,
      stiffness: 100,
    });
  };
  
  const containerStyle = useAnimatedStyle(() => {
    const width = interpolate(
      progress.value,
      [0, 1],
      [SCREEN_WIDTH - 32, SCREEN_WIDTH]
    );
    const height = interpolate(
      progress.value,
      [0, 1],
      [200, SCREEN_HEIGHT]
    );
    const borderRadius = interpolate(progress.value, [0, 1], [16, 0]);
    const translateX = interpolate(
      progress.value,
      [0, 1],
      [0, -16]
    );
    const translateY = interpolate(
      progress.value,
      [0, 1],
      [0, -100]
    );
    
    return {
      width,
      height,
      borderRadius,
      transform: [{ translateX }, { translateY }],
      zIndex: expanded ? 100 : 1,
    };
  });
  
  const imageStyle = useAnimatedStyle(() => {
    const height = interpolate(progress.value, [0, 1], [200, 300]);
    
    return { height };
  });
  
  const contentStyle = useAnimatedStyle(() => ({
    opacity: progress.value,
    transform: [
      { translateY: interpolate(progress.value, [0, 1], [20, 0]) },
    ],
  }));
  
  return (
    &lt;Pressable onPress={toggle}&gt;
      &lt;Animated.View style={[styles.card, containerStyle]}&gt;
        &lt;Animated.Image
          source={{ uri: card.image }}
          style={[styles.cardImage, imageStyle]}
        /&gt;
        
        &lt;View style={styles.cardContent}&gt;
          &lt;Text style={styles.cardTitle}&gt;{card.title}&lt;/Text&gt;
          
          {expanded && (
            &lt;Animated.View
              entering={FadeIn.delay(200)}
              exiting={FadeOut.duration(100)}
            &gt;
              &lt;Animated.Text style={[styles.cardDescription, contentStyle]}&gt;
                {card.description}
              &lt;/Animated.Text&gt;
            &lt;/Animated.View&gt;
          )}
        &lt;/View&gt;
        
        {expanded && (
          &lt;Animated.View
            entering={FadeIn.delay(300)}
            exiting={FadeOut.duration(100)}
            style={styles.closeButton}
          &gt;
            &lt;Text style={styles.closeText}&gt;√ó&lt;/Text&gt;
          &lt;/Animated.View&gt;
        )}
      &lt;/Animated.View&gt;
    &lt;/Pressable&gt;
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: 'white',
    marginHorizontal: 16,
    marginVertical: 8,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
  },
  cardImage: {
    width: '100%',
  },
  cardContent: {
    padding: 16,
  },
  cardTitle: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 8,
  },
  cardDescription: {
    fontSize: 16,
    lineHeight: 24,
    color: '#666',
  },
  closeButton: {
    position: 'absolute',
    top: 16,
    right: 16,
    width: 40,
    height: 40,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  closeText: {
    color: 'white',
    fontSize: 24,
  },
});</code></pre>

                <h3>Photo Gallery with Shared Transition</h3>

                <pre><code>import React, { useState } from 'react';
import { 
  StyleSheet, 
  View, 
  Image, 
  Pressable, 
  Dimensions,
  Modal,
} from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  FadeIn,
  FadeOut,
} from 'react-native-reanimated';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const COLUMNS = 3;
const GAP = 2;
const THUMB_SIZE = (SCREEN_WIDTH - (COLUMNS + 1) * GAP) / COLUMNS;

interface Photo {
  id: string;
  uri: string;
}

const photos: Photo[] = Array.from({ length: 12 }, (_, i) => ({
  id: `photo-${i}`,
  uri: `https://picsum.photos/400/400?random=${i}`,
}));

function PhotoGallery() {
  const [selectedPhoto, setSelectedPhoto] = useState&lt;Photo | null&gt;(null);
  const [origin, setOrigin] = useState({ x: 0, y: 0 });
  
  const scale = useSharedValue(0);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  
  const openPhoto = (photo: Photo, layout: { x: number; y: number }) => {
    setOrigin(layout);
    setSelectedPhoto(photo);
    
    // Calculate center offset
    translateX.value = layout.x - SCREEN_WIDTH / 2 + THUMB_SIZE / 2;
    translateY.value = layout.y - SCREEN_HEIGHT / 2 + THUMB_SIZE / 2;
    scale.value = THUMB_SIZE / SCREEN_WIDTH;
    
    // Animate to center
    translateX.value = withSpring(0, { damping: 15 });
    translateY.value = withSpring(0, { damping: 15 });
    scale.value = withSpring(1, { damping: 15 });
  };
  
  const closePhoto = () => {
    // Animate back to origin
    translateX.value = withSpring(
      origin.x - SCREEN_WIDTH / 2 + THUMB_SIZE / 2
    );
    translateY.value = withSpring(
      origin.y - SCREEN_HEIGHT / 2 + THUMB_SIZE / 2
    );
    scale.value = withTiming(THUMB_SIZE / SCREEN_WIDTH, { duration: 250 }, () => {
      runOnJS(setSelectedPhoto)(null);
    });
  };
  
  const imageStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
  }));
  
  return (
    &lt;View style={styles.container}&gt;
      {/* Thumbnail Grid */}
      &lt;View style={styles.grid}&gt;
        {photos.map((photo, index) => {
          const row = Math.floor(index / COLUMNS);
          const col = index % COLUMNS;
          const x = col * (THUMB_SIZE + GAP) + GAP;
          const y = row * (THUMB_SIZE + GAP) + GAP;
          
          return (
            &lt;Pressable
              key={photo.id}
              onPress={() => openPhoto(photo, { x, y })}
            &gt;
              &lt;Image
                source={{ uri: photo.uri }}
                style={styles.thumbnail}
              /&gt;
            &lt;/Pressable&gt;
          );
        })}
      &lt;/View&gt;
      
      {/* Full Screen Viewer */}
      {selectedPhoto && (
        &lt;Pressable style={styles.overlay} onPress={closePhoto}&gt;
          &lt;Animated.View
            entering={FadeIn.duration(200)}
            exiting={FadeOut.duration(200)}
            style={styles.backdrop}
          /&gt;
          
          &lt;Animated.Image
            source={{ uri: selectedPhoto.uri }}
            style={[styles.fullImage, imageStyle]}
            resizeMode="contain"
          /&gt;
        &lt;/Pressable&gt;
      )}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  grid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  thumbnail: {
    width: THUMB_SIZE,
    height: THUMB_SIZE,
    margin: GAP / 2,
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
  },
  backdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'black',
  },
  fullImage: {
    width: SCREEN_WIDTH,
    height: SCREEN_WIDTH,
  },
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° For True Shared Element Transitions</h4>
                    <p>For shared element transitions between navigation screens, consider:</p>
                    <ul>
                        <li><strong>React Navigation Shared Element:</strong> <code>react-navigation-shared-element</code></li>
                        <li><strong>Expo Router:</strong> Built-in shared transition support in newer versions</li>
                        <li><strong>Reanimated 3:</strong> SharedTransition API for custom implementations</li>
                    </ul>
                </div>
            </section>
            <!-- Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: Animated Notification Stack</h3>
                    <p>Create a notification system where notifications stack, slide in, and can be dismissed.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Notifications slide in from the top</li>
                        <li>Multiple notifications stack with layout animation</li>
                        <li>Swipe right to dismiss individual notifications</li>
                        <li>Auto-dismiss after 5 seconds (optional)</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import React, { useState, useEffect, useRef } from 'react';
import { StyleSheet, View, Text, Pressable, Dimensions } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  SlideInUp,
  SlideOutRight,
  Layout,
} from 'react-native-reanimated';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

interface Notification {
  id: string;
  title: string;
  message: string;
  type: 'info' | 'success' | 'warning' | 'error';
}

function NotificationItem({ 
  notification, 
  onDismiss 
}: { 
  notification: Notification;
  onDismiss: (id: string) => void;
}) {
  const translateX = useSharedValue(0);
  const timerRef = useRef&lt;NodeJS.Timeout&gt;();
  
  useEffect(() => {
    // Auto-dismiss after 5 seconds
    timerRef.current = setTimeout(() => {
      onDismiss(notification.id);
    }, 5000);
    
    return () => {
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);
  
  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      // Only allow right swipe
      translateX.value = Math.max(0, event.translationX);
    })
    .onEnd((event) => {
      if (translateX.value > 100 || event.velocityX > 500) {
        translateX.value = withTiming(SCREEN_WIDTH, { duration: 200 }, () => {
          runOnJS(onDismiss)(notification.id);
        });
      } else {
        translateX.value = withSpring(0);
      }
    });
  
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
    opacity: 1 - translateX.value / SCREEN_WIDTH,
  }));
  
  const getColors = () => {
    switch (notification.type) {
      case 'success': return { bg: '#34C759', icon: '‚úì' };
      case 'error': return { bg: '#FF3B30', icon: '‚úï' };
      case 'warning': return { bg: '#FF9500', icon: '‚ö†' };
      default: return { bg: '#007AFF', icon: '‚Ñπ' };
    }
  };
  
  const colors = getColors();
  
  return (
    &lt;GestureDetector gesture={panGesture}&gt;
      &lt;Animated.View
        entering={SlideInUp.springify().damping(15)}
        exiting={SlideOutRight.duration(200)}
        layout={Layout.springify()}
        style={[styles.notification, animatedStyle]}
      &gt;
        &lt;View style={[styles.iconContainer, { backgroundColor: colors.bg }]}&gt;
          &lt;Text style={styles.icon}&gt;{colors.icon}&lt;/Text&gt;
        &lt;/View&gt;
        &lt;View style={styles.content}&gt;
          &lt;Text style={styles.title}&gt;{notification.title}&lt;/Text&gt;
          &lt;Text style={styles.message}&gt;{notification.message}&lt;/Text&gt;
        &lt;/View&gt;
        &lt;Pressable 
          style={styles.closeButton}
          onPress={() => onDismiss(notification.id)}
        &gt;
          &lt;Text style={styles.closeText}&gt;√ó&lt;/Text&gt;
        &lt;/Pressable&gt;
      &lt;/Animated.View&gt;
    &lt;/GestureDetector&gt;
  );
}

function NotificationStack() {
  const [notifications, setNotifications] = useState&lt;Notification[]&gt;([]);
  
  const addNotification = (type: Notification['type']) => {
    const newNotification: Notification = {
      id: Date.now().toString(),
      title: `${type.charAt(0).toUpperCase() + type.slice(1)} Notification`,
      message: `This is a ${type} message that will auto-dismiss.`,
      type,
    };
    setNotifications(prev => [newNotification, ...prev]);
  };
  
  const dismissNotification = (id: string) => {
    setNotifications(prev => prev.filter(n => n.id !== id));
  };
  
  return (
    &lt;View style={styles.container}&gt;
      {/* Notification Stack */}
      &lt;View style={styles.stack}&gt;
        {notifications.map((notification) => (
          &lt;NotificationItem
            key={notification.id}
            notification={notification}
            onDismiss={dismissNotification}
          /&gt;
        ))}
      &lt;/View&gt;
      
      {/* Trigger Buttons */}
      &lt;View style={styles.buttons}&gt;
        &lt;Pressable 
          style={[styles.button, { backgroundColor: '#007AFF' }]}
          onPress={() => addNotification('info')}
        &gt;
          &lt;Text style={styles.buttonText}&gt;Info&lt;/Text&gt;
        &lt;/Pressable&gt;
        &lt;Pressable 
          style={[styles.button, { backgroundColor: '#34C759' }]}
          onPress={() => addNotification('success')}
        &gt;
          &lt;Text style={styles.buttonText}&gt;Success&lt;/Text&gt;
        &lt;/Pressable&gt;
        &lt;Pressable 
          style={[styles.button, { backgroundColor: '#FF9500' }]}
          onPress={() => addNotification('warning')}
        &gt;
          &lt;Text style={styles.buttonText}&gt;Warning&lt;/Text&gt;
        &lt;/Pressable&gt;
        &lt;Pressable 
          style={[styles.button, { backgroundColor: '#FF3B30' }]}
          onPress={() => addNotification('error')}
        &gt;
          &lt;Text style={styles.buttonText}&gt;Error&lt;/Text&gt;
        &lt;/Pressable&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  stack: {
    position: 'absolute',
    top: 50,
    left: 16,
    right: 16,
    zIndex: 100,
    gap: 8,
  },
  notification: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
  },
  iconContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  icon: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  content: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 2,
  },
  message: {
    fontSize: 14,
    color: '#666',
  },
  closeButton: {
    padding: 8,
  },
  closeText: {
    fontSize: 20,
    color: '#999',
  },
  buttons: {
    position: 'absolute',
    bottom: 50,
    left: 16,
    right: 16,
    flexDirection: 'row',
    gap: 8,
  },
  button: {
    flex: 1,
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: {
    color: 'white',
    fontWeight: '600',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Animated Tab Bar</h3>
                    <p>Build a custom animated tab bar with smooth indicator transitions.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>4 tabs with icons</li>
                        <li>Animated indicator slides between tabs</li>
                        <li>Selected tab icon scales up</li>
                        <li>Smooth spring animations</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import React, { useState } from 'react';
import { StyleSheet, View, Text, Pressable, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  interpolateColor,
} from 'react-native-reanimated';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

interface Tab {
  key: string;
  icon: string;
  label: string;
}

const tabs: Tab[] = [
  { key: 'home', icon: 'üè†', label: 'Home' },
  { key: 'search', icon: 'üîç', label: 'Search' },
  { key: 'notifications', icon: 'üîî', label: 'Alerts' },
  { key: 'profile', icon: 'üë§', label: 'Profile' },
];

const TAB_WIDTH = SCREEN_WIDTH / tabs.length;

function AnimatedTabBar() {
  const [activeIndex, setActiveIndex] = useState(0);
  const indicatorPosition = useSharedValue(0);
  
  const handleTabPress = (index: number) => {
    setActiveIndex(index);
    indicatorPosition.value = withSpring(index * TAB_WIDTH, {
      damping: 15,
      stiffness: 120,
    });
  };
  
  const indicatorStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: indicatorPosition.value }],
  }));
  
  return (
    &lt;View style={styles.container}&gt;
      {/* Content Area */}
      &lt;View style={styles.content}&gt;
        &lt;Text style={styles.contentText}&gt;
          {tabs[activeIndex].label} Screen
        &lt;/Text&gt;
      &lt;/View&gt;
      
      {/* Tab Bar */}
      &lt;View style={styles.tabBar}&gt;
        {/* Animated Indicator */}
        &lt;Animated.View style={[styles.indicator, indicatorStyle]} /&gt;
        
        {/* Tabs */}
        {tabs.map((tab, index) => (
          &lt;TabItem
            key={tab.key}
            tab={tab}
            index={index}
            activeIndex={activeIndex}
            onPress={() => handleTabPress(index)}
          /&gt;
        ))}
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

function TabItem({
  tab,
  index,
  activeIndex,
  onPress,
}: {
  tab: Tab;
  index: number;
  activeIndex: number;
  onPress: () => void;
}) {
  const isActive = index === activeIndex;
  const scale = useSharedValue(1);
  
  React.useEffect(() => {
    scale.value = withSpring(isActive ? 1.2 : 1, {
      damping: 12,
      stiffness: 150,
    });
  }, [isActive]);
  
  const iconStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));
  
  const labelStyle = useAnimatedStyle(() => ({
    opacity: isActive ? 1 : 0.6,
    transform: [{ scale: isActive ? 1 : 0.9 }],
  }));
  
  return (
    &lt;Pressable style={styles.tab} onPress={onPress}&gt;
      &lt;Animated.Text style={[styles.tabIcon, iconStyle]}&gt;
        {tab.icon}
      &lt;/Animated.Text&gt;
      &lt;Animated.Text 
        style={[
          styles.tabLabel, 
          labelStyle,
          isActive && styles.activeLabel
        ]}
      &gt;
        {tab.label}
      &lt;/Animated.Text&gt;
    &lt;/Pressable&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  contentText: {
    fontSize: 24,
    fontWeight: '600',
  },
  tabBar: {
    flexDirection: 'row',
    height: 80,
    backgroundColor: 'white',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingBottom: 20,
  },
  indicator: {
    position: 'absolute',
    top: 0,
    width: TAB_WIDTH,
    height: 3,
    backgroundColor: '#007AFF',
  },
  tab: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: 8,
  },
  tabIcon: {
    fontSize: 24,
    marginBottom: 4,
  },
  tabLabel: {
    fontSize: 12,
    color: '#666',
  },
  activeLabel: {
    color: '#007AFF',
    fontWeight: '600',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Animated Form Validation</h3>
                    <p>Create a form with animated validation feedback.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Input fields with animated border color on focus</li>
                        <li>Shake animation on validation error</li>
                        <li>Success checkmark animation when valid</li>
                        <li>Error message slides in with layout animation</li>
                    </ul>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import React, { useState, useRef } from 'react';
import { StyleSheet, View, Text, TextInput, Pressable } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  withSequence,
  interpolateColor,
  FadeIn,
  FadeOut,
  Layout,
} from 'react-native-reanimated';

const AnimatedTextInput = Animated.createAnimatedComponent(TextInput);

type ValidationState = 'idle' | 'valid' | 'invalid';

interface FormFieldProps {
  label: string;
  value: string;
  onChangeText: (text: string) => void;
  placeholder?: string;
  validate: (value: string) => string | null;
  secureTextEntry?: boolean;
}

function FormField({
  label,
  value,
  onChangeText,
  placeholder,
  validate,
  secureTextEntry,
}: FormFieldProps) {
  const [focused, setFocused] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const [validationState, setValidationState] = useState&lt;ValidationState&gt;('idle');
  
  const borderProgress = useSharedValue(0);
  const shakeX = useSharedValue(0);
  const checkScale = useSharedValue(0);
  
  const handleFocus = () => {
    setFocused(true);
    borderProgress.value = withTiming(0.5);
  };
  
  const handleBlur = () => {
    setFocused(false);
    
    const validationError = validate(value);
    
    if (validationError) {
      setError(validationError);
      setValidationState('invalid');
      borderProgress.value = withTiming(1);
      checkScale.value = withTiming(0);
      
      // Shake animation
      shakeX.value = withSequence(
        withTiming(-10, { duration: 50 }),
        withTiming(10, { duration: 50 }),
        withTiming(-10, { duration: 50 }),
        withTiming(10, { duration: 50 }),
        withTiming(0, { duration: 50 })
      );
    } else {
      setError(null);
      setValidationState('valid');
      borderProgress.value = withTiming(0);
      checkScale.value = withSpring(1, { damping: 8 });
    }
  };
  
  const containerStyle = useAnimatedStyle(() => {
    const borderColor = interpolateColor(
      borderProgress.value,
      [0, 0.5, 1],
      ['#E0E0E0', '#007AFF', '#FF3B30']
    );
    
    return {
      borderColor,
      transform: [{ translateX: shakeX.value }],
    };
  });
  
  const checkStyle = useAnimatedStyle(() => ({
    transform: [{ scale: checkScale.value }],
    opacity: checkScale.value,
  }));
  
  return (
    &lt;Animated.View layout={Layout.springify()} style={styles.fieldContainer}&gt;
      &lt;Text style={styles.label}&gt;{label}&lt;/Text&gt;
      
      &lt;Animated.View style={[styles.inputContainer, containerStyle]}&gt;
        &lt;TextInput
          style={styles.input}
          value={value}
          onChangeText={onChangeText}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholder={placeholder}
          placeholderTextColor="#999"
          secureTextEntry={secureTextEntry}
        /&gt;
        
        {validationState === 'valid' && (
          &lt;Animated.View style={[styles.checkmark, checkStyle]}&gt;
            &lt;Text style={styles.checkmarkText}&gt;‚úì&lt;/Text&gt;
          &lt;/Animated.View&gt;
        )}
      &lt;/Animated.View&gt;
      
      {error && (
        &lt;Animated.Text
          entering={FadeIn.duration(200)}
          exiting={FadeOut.duration(200)}
          style={styles.errorText}
        &gt;
          {error}
        &lt;/Animated.Text&gt;
      )}
    &lt;/Animated.View&gt;
  );
}

function AnimatedForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  
  const validateEmail = (value: string) => {
    if (!value) return 'Email is required';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
      return 'Please enter a valid email';
    }
    return null;
  };
  
  const validatePassword = (value: string) => {
    if (!value) return 'Password is required';
    if (value.length < 8) return 'Password must be at least 8 characters';
    return null;
  };
  
  const validateConfirmPassword = (value: string) => {
    if (!value) return 'Please confirm your password';
    if (value !== password) return 'Passwords do not match';
    return null;
  };
  
  return (
    &lt;View style={styles.form}&gt;
      &lt;Text style={styles.title}&gt;Create Account&lt;/Text&gt;
      
      &lt;FormField
        label="Email"
        value={email}
        onChangeText={setEmail}
        placeholder="you@example.com"
        validate={validateEmail}
      /&gt;
      
      &lt;FormField
        label="Password"
        value={password}
        onChangeText={setPassword}
        placeholder="At least 8 characters"
        validate={validatePassword}
        secureTextEntry
      /&gt;
      
      &lt;FormField
        label="Confirm Password"
        value={confirmPassword}
        onChangeText={setConfirmPassword}
        placeholder="Re-enter your password"
        validate={validateConfirmPassword}
        secureTextEntry
      /&gt;
      
      &lt;Pressable style={styles.submitButton}&gt;
        &lt;Text style={styles.submitText}&gt;Sign Up&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  form: {
    padding: 20,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 24,
    textAlign: 'center',
  },
  fieldContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
    color: '#333',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 2,
    borderRadius: 12,
    backgroundColor: 'white',
  },
  input: {
    flex: 1,
    padding: 16,
    fontSize: 16,
  },
  checkmark: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#34C759',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  checkmarkText: {
    color: 'white',
    fontWeight: 'bold',
  },
  errorText: {
    color: '#FF3B30',
    fontSize: 12,
    marginTop: 6,
    marginLeft: 4,
  },
  submitButton: {
    backgroundColor: '#007AFF',
    padding: 18,
    borderRadius: 12,
    alignItems: 'center',
    marginTop: 20,
  },
  submitText: {
    color: 'white',
    fontSize: 18,
    fontWeight: '600',
  },
});</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>Layout animations bring polish and professionalism to your React Native apps by smoothly handling component lifecycle events. With Reanimated's declarative API, you can easily add entering, exiting, and layout transitions that would otherwise require complex manual animation code.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>Entering animations:</strong> Run when components mount (<code>FadeIn</code>, <code>SlideInUp</code>, <code>ZoomIn</code>, etc.)</li>
                        <li><strong>Exiting animations:</strong> Run when components unmount, delaying removal (<code>FadeOut</code>, <code>SlideOutLeft</code>, etc.)</li>
                        <li><strong>Layout transitions:</strong> Animate position/size changes within layouts (<code>Layout.springify()</code>)</li>
                        <li><strong>Keyframes:</strong> Define multi-step animations with precise timing control</li>
                        <li><strong>Customization:</strong> Chain modifiers like <code>.delay()</code>, <code>.duration()</code>, <code>.springify()</code></li>
                        <li><strong>Lists:</strong> Combine with FlatList for animated add/remove/reorder</li>
                    </ul>
                </div>

                <h3>Layout Animation Quick Reference</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Animation Type</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Usage</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Common Options</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>entering</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>&lt;Animated.View entering={FadeIn}&gt;</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>.delay()</code>, <code>.duration()</code>, <code>.springify()</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>exiting</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>&lt;Animated.View exiting={FadeOut}&gt;</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>.delay()</code>, <code>.duration()</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>layout</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>&lt;Animated.View layout={Layout}&gt;</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>.springify()</code>, <code>.damping()</code>, <code>.stiffness()</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Keyframe</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>new Keyframe({ 0: {...}, 100: {...} })</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>.duration()</code>, <code>.delay()</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Animation Categories</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f5f5f5;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Category</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Entering</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Exiting</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Fade</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>FadeIn</code>, <code>FadeInUp</code>, <code>FadeInDown</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>FadeOut</code>, <code>FadeOutUp</code>, <code>FadeOutDown</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Slide</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>SlideInLeft</code>, <code>SlideInRight</code>, <code>SlideInUp</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>SlideOutLeft</code>, <code>SlideOutRight</code>, <code>SlideOutUp</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Zoom</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>ZoomIn</code>, <code>ZoomInRotate</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>ZoomOut</code>, <code>ZoomOutRotate</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Bounce</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>BounceIn</code>, <code>BounceInUp</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>BounceOut</code>, <code>BounceOutUp</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;">Flip</td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>FlipInXUp</code>, <code>FlipInYLeft</code></td>
                            <td style="padding: 12px; border-bottom: 1px solid #eee;"><code>FlipOutXUp</code>, <code>FlipOutYLeft</code></td>
                        </tr>
                    </tbody>
                </table>

                <p>This concludes Module 9 on Animations and Gestures. You now have the skills to create smooth, performant, and engaging animated interfaces that feel native and responsive.</p>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m09_l04_gesture_handler.html" class="prev-link">‚Üê Previous: Gesture Handler</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m10_l01_testing_fundamentals.html" class="next-link">Next: Module 10 - Testing ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
