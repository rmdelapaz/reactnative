<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn how to fetch data from APIs in React Native using fetch(), handle loading and error states, and manage cleanup with abort controllers">
    <meta name="author" content="React Native & Expo Course">
    <title>Fetching Data | Module 7: Data Management and Networking | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m07_l01_fetching_data.html">Module 7</a> &gt;
            <span>Lesson 7.1</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 7: Data Management and Networking</p>
                <h1>Fetching Data</h1>
                <p class="lesson-subtitle">Connecting your React Native app to the outside world</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Use the fetch() API in React Native just like you do on the web</li>
                    <li>Implement the loading ‚Üí success ‚Üí error state pattern</li>
                    <li>Cancel pending requests with AbortController to prevent memory leaks</li>
                    <li>Configure environment variables for different API endpoints</li>
                    <li>Handle common networking scenarios: timeouts, retries, and error responses</li>
                    <li>Build a reusable data fetching hook</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#good-news">The Good News: fetch() Just Works</a></li>
                        <li><a href="#basic-fetch">Basic Data Fetching</a></li>
                        <li><a href="#loading-states">The Loading State Trinity</a></li>
                        <li><a href="#abort-controllers">Abort Controllers: Preventing Memory Leaks</a></li>
                        <li><a href="#error-handling">Error Handling Done Right</a></li>
                        <li><a href="#environment-variables">Environment Variables for API URLs</a></li>
                        <li><a href="#custom-hook">Building a Reusable useFetch Hook</a></li>
                        <li><a href="#real-world-patterns">Real-World Patterns</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- The Good News -->
            <section id="good-news">
                <h2>The Good News: fetch() Just Works</h2>

                <p>Here's something refreshing after all the "mobile is different" discussions: data fetching in React Native works exactly like it does on the web. The <code>fetch()</code> API is built right into React Native's JavaScript runtime. No special libraries needed, no platform-specific code required.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Great News for Web Developers</h4>
                    <p>If you've used <code>fetch()</code> in React web apps, you already know how to fetch data in React Native. Same API, same patterns, same Promise-based flow. This is one area where your web skills transfer completely.</p>
                </div>

                <p>That said, there are mobile-specific considerations we'll cover: handling network state changes, dealing with slower connections, and managing background/foreground transitions. But the core mechanics? Identical.</p>

                <!-- Mermaid: What Transfers vs What's New -->
                <pre class="mermaid">
flowchart TB
    subgraph transfers["‚úÖ Transfers from Web"]
        F1["fetch() API"]
        F2["async/await syntax"]
        F3["JSON parsing"]
        F4["Request/Response objects"]
        F5["Headers configuration"]
        F6["AbortController"]
    end
    
    subgraph newstuff["üì± Mobile Considerations"]
        M1["Network state detection"]
        M2["Background fetch limits"]
        M3["Slower connections"]
        M4["App lifecycle impact"]
    end
    
    style transfers fill:#e8f5e9,stroke:#4CAF50
    style newstuff fill:#fff3e0,stroke:#FF9800
                </pre>
            </section>

            <!-- Basic Data Fetching -->
            <section id="basic-fetch">
                <h2>Basic Data Fetching</h2>

                <p>Let's start with the simplest possible example‚Äîfetching data when a component mounts. If you've done this in React web apps, this will look very familiar:</p>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';

interface User {
  id: number;
  name: string;
  email: string;
}

export default function UserProfile() {
  const [user, setUser] = useState&lt;User | null&gt;(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users/1')
      .then(response => response.json())
      .then(data => setUser(data));
  }, []);

  if (!user) {
    return &lt;Text&gt;Loading...&lt;/Text&gt;;
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.name}&gt;{user.name}&lt;/Text&gt;
      &lt;Text style={styles.email}&gt;{user.email}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  name: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  email: {
    fontSize: 16,
    color: '#666',
  },
});</code></pre>

                <p>This works, but it has problems. What if the request fails? What if the user navigates away before the request completes? Let's build this properly.</p>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è The Code Above Has Issues</h4>
                    <p>This naive approach has several problems we'll fix throughout this lesson: no error handling, no loading state management, and potential memory leaks if the component unmounts before the fetch completes. Never ship code like this!</p>
                </div>
            </section>

            <!-- The Loading State Trinity -->
            <section id="loading-states">
                <h2>The Loading State Trinity</h2>

                <p>Every data fetch operation has three possible outcomes: it's loading, it succeeded, or it failed. Your UI needs to handle all three states gracefully. This pattern is so common it has a name: the Loading State Trinity (or sometimes "loading/error/data" pattern).</p>

                <!-- SVG: Loading State Trinity -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 600 300" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="600" height="300" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="300" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">The Loading State Trinity</text>
                        
                        <!-- Initial State -->
                        <circle cx="100" cy="150" r="50" fill="#e3f2fd" stroke="#2196F3" stroke-width="2"/>
                        <text x="100" y="145" text-anchor="middle" font-size="11" font-weight="bold" fill="#1976D2">LOADING</text>
                        <text x="100" y="162" text-anchor="middle" font-size="9" fill="#666">Spinner</text>
                        
                        <!-- Arrow to Success -->
                        <path d="M155,120 Q230,80 280,105" fill="none" stroke="#4CAF50" stroke-width="2" marker-end="url(#arrowGreen)"/>
                        <text x="220" y="85" text-anchor="middle" font-size="10" fill="#4CAF50">200 OK</text>
                        
                        <!-- Arrow to Error -->
                        <path d="M155,180 Q230,220 280,195" fill="none" stroke="#f44336" stroke-width="2" marker-end="url(#arrowRed)"/>
                        <text x="220" y="235" text-anchor="middle" font-size="10" fill="#f44336">Error</text>
                        
                        <!-- Success State -->
                        <circle cx="350" cy="100" r="50" fill="#e8f5e9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="350" y="95" text-anchor="middle" font-size="11" font-weight="bold" fill="#2e7d32">SUCCESS</text>
                        <text x="350" y="112" text-anchor="middle" font-size="9" fill="#666">Show Data</text>
                        
                        <!-- Error State -->
                        <circle cx="350" cy="200" r="50" fill="#ffebee" stroke="#f44336" stroke-width="2"/>
                        <text x="350" y="195" text-anchor="middle" font-size="11" font-weight="bold" fill="#c62828">ERROR</text>
                        <text x="350" y="212" text-anchor="middle" font-size="9" fill="#666">Show Message</text>
                        
                        <!-- Retry Arrow -->
                        <path d="M405,200 Q480,200 480,150 Q480,100 405,100" fill="none" stroke="#FF9800" stroke-width="2" stroke-dasharray="5,3"/>
                        <path d="M520,150 L520,180" fill="none" stroke="#FF9800" stroke-width="2" marker-end="url(#arrowOrange)"/>
                        <text x="520" y="195" text-anchor="middle" font-size="9" fill="#FF9800">Retry</text>
                        
                        <!-- Refresh Arrow -->
                        <path d="M405,100 Q450,100 450,150" fill="none" stroke="#2196F3" stroke-width="2" stroke-dasharray="5,3" marker-end="url(#arrowBlue)"/>
                        <text x="470" y="130" text-anchor="middle" font-size="9" fill="#2196F3">Refresh</text>
                        
                        <!-- State Variables Box -->
                        <rect x="30" y="240" width="540" height="50" fill="#fff" stroke="#ddd" stroke-width="1" rx="4"/>
                        <text x="300" y="260" text-anchor="middle" font-size="11" font-weight="bold" fill="#333">State Variables</text>
                        <text x="300" y="278" text-anchor="middle" font-size="10" font-family="monospace" fill="#666">{ isLoading: boolean, error: Error | null, data: T | null }</text>
                        
                        <!-- Defs for arrows -->
                        <defs>
                            <marker id="arrowGreen" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#4CAF50"/>
                            </marker>
                            <marker id="arrowRed" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#f44336"/>
                            </marker>
                            <marker id="arrowOrange" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#FF9800"/>
                            </marker>
                            <marker id="arrowBlue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2196F3"/>
                            </marker>
                        </defs>
                    </svg>
                </div>

                <p>Here's the proper implementation with all three states:</p>

                <pre><code>import { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ActivityIndicator,
  Pressable 
} from 'react-native';

interface User {
  id: number;
  name: string;
  email: string;
  phone: string;
}

export default function UserProfile() {
  // The Trinity: loading, error, data
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  const [user, setUser] = useState&lt;User | null&gt;(null);

  const fetchUser = async () => {
    // Reset states before fetching
    setIsLoading(true);
    setError(null);
    
    try {
      const response = await fetch(
        'https://jsonplaceholder.typicode.com/users/1'
      );
      
      // Check if the response is OK (status 200-299)
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      setUser(data);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      // Always set loading to false when done
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchUser();
  }, []);

  // Render based on state
  if (isLoading) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;ActivityIndicator size="large" color="#667eea" /&gt;
        &lt;Text style={styles.loadingText}&gt;Loading profile...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  if (error) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;Text style={styles.errorText}&gt;üò¢ Something went wrong&lt;/Text&gt;
        &lt;Text style={styles.errorMessage}&gt;{error.message}&lt;/Text&gt;
        &lt;Pressable style={styles.retryButton} onPress={fetchUser}&gt;
          &lt;Text style={styles.retryText}&gt;Try Again&lt;/Text&gt;
        &lt;/Pressable&gt;
      &lt;/View&gt;
    );
  }

  if (!user) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;Text&gt;No user found&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  // Success! Show the data
  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.card}&gt;
        &lt;Text style={styles.name}&gt;{user.name}&lt;/Text&gt;
        &lt;Text style={styles.detail}&gt;üìß {user.email}&lt;/Text&gt;
        &lt;Text style={styles.detail}&gt;üì± {user.phone}&lt;/Text&gt;
      &lt;/View&gt;
      
      &lt;Pressable style={styles.refreshButton} onPress={fetchUser}&gt;
        &lt;Text style={styles.refreshText}&gt;üîÑ Refresh&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  errorMessage: {
    fontSize: 14,
    color: '#666',
    marginBottom: 20,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: '#667eea',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryText: {
    color: 'white',
    fontWeight: '600',
  },
  card: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
  },
  name: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  detail: {
    fontSize: 16,
    color: '#666',
    marginBottom: 8,
  },
  refreshButton: {
    marginTop: 20,
    padding: 12,
    alignItems: 'center',
  },
  refreshText: {
    color: '#667eea',
    fontSize: 16,
    fontWeight: '600',
  },
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why Three Separate States?</h4>
                    <p>You might wonder why we don't use a single <code>status</code> enum. While that pattern exists (and libraries like React Query use it), separate booleans are often clearer for beginners and work well for simple cases. We'll see the enum approach when we build our custom hook later.</p>
                </div>

                <h3>The Order of Conditionals Matters</h3>

                <p>Notice the order in our render logic: loading ‚Üí error ‚Üí no data ‚Üí success. This order is intentional:</p>

                <pre><code>// ‚úÖ Correct order
if (isLoading) return &lt;Loading /&gt;;      // Check loading first
if (error) return &lt;Error /&gt;;             // Then check errors  
if (!data) return &lt;Empty /&gt;;             // Then check for no data
return &lt;Content data={data} /&gt;;          // Finally render content

// ‚ùå Wrong order - might show error while still loading
if (error) return &lt;Error /&gt;;
if (isLoading) return &lt;Loading /&gt;;       // Too late!
// ...</code></pre>
            </section>

            <!-- Abort Controllers -->
            <section id="abort-controllers">
                <h2>Abort Controllers: Preventing Memory Leaks</h2>

                <p>Here's a scenario that will bite you if you're not careful: the user navigates to a screen, a fetch starts, but then they quickly navigate away. The fetch completes, tries to call <code>setState</code>... but the component is gone. React will warn you about "Can't perform a React state update on an unmounted component."</p>

                <p>The fix is <code>AbortController</code>‚Äîa web API that also works in React Native. It lets you cancel pending requests when a component unmounts.</p>

                <!-- Mermaid: Abort Controller Flow -->
                <pre class="mermaid">
sequenceDiagram
    participant C as Component
    participant AC as AbortController
    participant F as fetch()
    participant S as Server
    
    C->>AC: Create controller
    C->>F: Start fetch with signal
    F->>S: Request data
    
    Note over C: User navigates away
    C->>AC: abort()
    AC->>F: Signal abort
    F--xS: Request cancelled
    
    Note over C: Cleanup effect runs
    Note over F: AbortError thrown
    Note over C: No setState called ‚úì
                </pre>

                <p>Here's how to implement it:</p>

                <pre><code>import { useState, useEffect } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

interface Post {
  id: number;
  title: string;
  body: string;
}

export default function PostDetail({ postId }: { postId: number }) {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  const [post, setPost] = useState&lt;Post | null&gt;(null);

  useEffect(() => {
    // Create an AbortController for this effect
    const abortController = new AbortController();

    const fetchPost = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/posts/${postId}`,
          { signal: abortController.signal }  // Pass the signal to fetch
        );

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        
        // Only update state if not aborted
        setPost(data);
      } catch (err) {
        // Don't set error state if we aborted intentionally
        if (err instanceof Error && err.name === 'AbortError') {
          console.log('Fetch aborted');
          return;  // Exit early, don't update state
        }
        setError(err instanceof Error ? err : new Error('Unknown error'));
      } finally {
        // Only set loading false if not aborted
        if (!abortController.signal.aborted) {
          setIsLoading(false);
        }
      }
    };

    fetchPost();

    // Cleanup function - runs when component unmounts
    // or when postId changes
    return () => {
      abortController.abort();
    };
  }, [postId]);  // Re-fetch when postId changes

  // ... render logic
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Always Check for AbortError</h4>
                    <p>When a fetch is aborted, it throws an <code>AbortError</code>. You must check for this and handle it differently from real errors. Otherwise, your users might see "AbortError" messages when they're just navigating normally!</p>
                </div>

                <h3>The Cleanup Pattern</h3>

                <p>The key insight is that <code>useEffect</code>'s cleanup function runs when the component unmounts OR when dependencies change (causing a re-run of the effect). Both cases need the abort:</p>

                <pre><code>useEffect(() => {
  const controller = new AbortController();
  
  // ... fetch with controller.signal
  
  return () => {
    // This runs when:
    // 1. Component unmounts (navigating away)
    // 2. postId changes (new fetch starts)
    controller.abort();
  };
}, [postId]);</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: Abort on Dependency Changes Too</h4>
                    <p>If <code>postId</code> changes from 1 to 2, we want to abort the fetch for post 1 before starting the fetch for post 2. The cleanup function handles this automatically‚Äîit runs before the next effect execution.</p>
                </div>
            </section>

            <!-- Error Handling Done Right -->
            <section id="error-handling">
                <h2>Error Handling Done Right</h2>

                <p>Network requests can fail in many ways. Good error handling means giving users actionable information, not just "Something went wrong." Let's categorize the errors you'll encounter:</p>

                <!-- SVG: Error Types -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 350" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="350" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="350" y="25" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">Types of Network Errors</text>
                        
                        <!-- Network Error Box -->
                        <rect x="30" y="50" width="200" height="130" fill="#ffebee" stroke="#f44336" stroke-width="2" rx="8"/>
                        <text x="130" y="75" text-anchor="middle" font-size="12" font-weight="bold" fill="#c62828">üåê Network Errors</text>
                        <text x="40" y="100" font-size="10" fill="#333">‚Ä¢ No internet connection</text>
                        <text x="40" y="118" font-size="10" fill="#333">‚Ä¢ DNS resolution failed</text>
                        <text x="40" y="136" font-size="10" fill="#333">‚Ä¢ Request timeout</text>
                        <text x="40" y="154" font-size="10" fill="#333">‚Ä¢ Server unreachable</text>
                        <text x="130" y="172" text-anchor="middle" font-size="9" fill="#666" font-style="italic">fetch() throws Error</text>
                        
                        <!-- HTTP Error Box -->
                        <rect x="250" y="50" width="200" height="130" fill="#fff3e0" stroke="#FF9800" stroke-width="2" rx="8"/>
                        <text x="350" y="75" text-anchor="middle" font-size="12" font-weight="bold" fill="#e65100">üìã HTTP Errors</text>
                        <text x="260" y="100" font-size="10" fill="#333">‚Ä¢ 400 Bad Request</text>
                        <text x="260" y="118" font-size="10" fill="#333">‚Ä¢ 401 Unauthorized</text>
                        <text x="260" y="136" font-size="10" fill="#333">‚Ä¢ 404 Not Found</text>
                        <text x="260" y="154" font-size="10" fill="#333">‚Ä¢ 500 Server Error</text>
                        <text x="350" y="172" text-anchor="middle" font-size="9" fill="#666" font-style="italic">response.ok === false</text>
                        
                        <!-- Parse Error Box -->
                        <rect x="470" y="50" width="200" height="130" fill="#e8eaf6" stroke="#5C6BC0" stroke-width="2" rx="8"/>
                        <text x="570" y="75" text-anchor="middle" font-size="12" font-weight="bold" fill="#3949AB">üìÑ Parse Errors</text>
                        <text x="480" y="100" font-size="10" fill="#333">‚Ä¢ Invalid JSON</text>
                        <text x="480" y="118" font-size="10" fill="#333">‚Ä¢ Unexpected format</text>
                        <text x="480" y="136" font-size="10" fill="#333">‚Ä¢ Missing fields</text>
                        <text x="480" y="154" font-size="10" fill="#333">‚Ä¢ Type mismatches</text>
                        <text x="570" y="172" text-anchor="middle" font-size="9" fill="#666" font-style="italic">response.json() throws</text>
                        
                        <!-- User Actions Box -->
                        <rect x="100" y="210" width="500" height="120" fill="#e8f5e9" stroke="#4CAF50" stroke-width="2" rx="8"/>
                        <text x="350" y="235" text-anchor="middle" font-size="12" font-weight="bold" fill="#2e7d32">‚úÖ User-Friendly Error Handling</text>
                        
                        <text x="120" y="260" font-size="10" fill="#333">Network Error ‚Üí "Check your internet connection"</text>
                        <text x="120" y="280" font-size="10" fill="#333">401 Error ‚Üí "Please log in again"</text>
                        <text x="120" y="300" font-size="10" fill="#333">404 Error ‚Üí "This item no longer exists"</text>
                        <text x="120" y="320" font-size="10" fill="#333">500 Error ‚Üí "Server issue, try again later"</text>
                    </svg>
                </div>

                <p>Here's a comprehensive error handling approach:</p>

                <pre><code>// Custom error class for API errors
class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// Helper to get user-friendly error messages
function getErrorMessage(error: Error): string {
  // Network errors (no response at all)
  if (error.message === 'Network request failed') {
    return 'Please check your internet connection and try again.';
  }
  
  // Timeout errors
  if (error.name === 'TimeoutError') {
    return 'The request took too long. Please try again.';
  }
  
  // Abort errors (user navigated away)
  if (error.name === 'AbortError') {
    return ''; // Don't show anything, this is intentional
  }
  
  // API errors with status codes
  if (error instanceof ApiError) {
    switch (error.status) {
      case 400:
        return 'Invalid request. Please check your input.';
      case 401:
        return 'Your session has expired. Please log in again.';
      case 403:
        return 'You don\'t have permission to access this.';
      case 404:
        return 'The requested item was not found.';
      case 429:
        return 'Too many requests. Please wait a moment.';
      case 500:
      case 502:
      case 503:
        return 'Server error. Please try again later.';
      default:
        return `An error occurred (${error.status}).`;
    }
  }
  
  // Fallback for unknown errors
  return 'Something went wrong. Please try again.';
}

// Enhanced fetch function
async function apiFetch&lt;T&gt;(url: string, options?: RequestInit): Promise&lt;T&gt; {
  const response = await fetch(url, options);
  
  if (!response.ok) {
    // Try to parse error details from response body
    let errorMessage = `HTTP error ${response.status}`;
    let errorCode: string | undefined;
    
    try {
      const errorBody = await response.json();
      errorMessage = errorBody.message || errorMessage;
      errorCode = errorBody.code;
    } catch {
      // Response body wasn't JSON, use default message
    }
    
    throw new ApiError(errorMessage, response.status, errorCode);
  }
  
  return response.json();
}

// Usage in component
const fetchData = async () => {
  try {
    const data = await apiFetch&lt;User&gt;('/api/user');
    setUser(data);
  } catch (error) {
    if (error instanceof Error) {
      const message = getErrorMessage(error);
      if (message) {  // Don't set error for AbortError
        setError(new Error(message));
      }
    }
  }
};</code></pre>

                <div class="card">
                    <h4>üîÑ Retry Strategies</h4>
                    <p>Some errors are worth retrying automatically:</p>
                    <ul>
                        <li><strong>Network errors</strong> ‚Äî Might succeed when connection is restored</li>
                        <li><strong>5xx errors</strong> ‚Äî Server might recover quickly</li>
                        <li><strong>429 (Rate Limited)</strong> ‚Äî Wait and retry after delay</li>
                    </ul>
                    <p>Don't auto-retry:</p>
                    <ul>
                        <li><strong>4xx errors</strong> ‚Äî These are client errors that won't change</li>
                        <li><strong>Parse errors</strong> ‚Äî The response won't magically become valid JSON</li>
                    </ul>
                </div>
            </section>

            <!-- Environment Variables -->
            <section id="environment-variables">
                <h2>Environment Variables for API URLs</h2>

                <p>Hardcoding API URLs is a recipe for disaster. You need different URLs for development, staging, and production. In Expo, we use environment variables through <code>app.config.js</code> and <code>expo-constants</code>.</p>

                <h3>Setting Up Environment Variables</h3>

                <p>First, convert <code>app.json</code> to <code>app.config.js</code> (or <code>app.config.ts</code>):</p>

                <pre><code>// app.config.js
export default {
  expo: {
    name: 'MyApp',
    slug: 'my-app',
    version: '1.0.0',
    // ... other config
    extra: {
      // Access process.env at build time
      apiUrl: process.env.API_URL || 'https://api.dev.myapp.com',
      environment: process.env.APP_ENV || 'development',
    },
  },
};</code></pre>

                <p>Now access these in your code:</p>

                <pre><code>import Constants from 'expo-constants';

// Access the extra config
const { apiUrl, environment } = Constants.expoConfig?.extra ?? {};

console.log('API URL:', apiUrl);  // https://api.dev.myapp.com
console.log('Environment:', environment);  // development

// Use in fetch calls
async function fetchUsers() {
  const response = await fetch(`${apiUrl}/users`);
  return response.json();
}</code></pre>

                <h3>Using .env Files</h3>

                <p>For local development, you can use <code>.env</code> files with a package like <code>dotenv</code>:</p>

                <pre><code># .env.development
API_URL=https://api.dev.myapp.com
APP_ENV=development

# .env.staging
API_URL=https://api.staging.myapp.com
APP_ENV=staging

# .env.production
API_URL=https://api.myapp.com
APP_ENV=production</code></pre>

                <p>Update your <code>app.config.js</code> to load the right file:</p>

                <pre><code>// app.config.js
import 'dotenv/config';  // Load .env file

export default {
  expo: {
    name: process.env.APP_ENV === 'production' ? 'MyApp' : `MyApp (${process.env.APP_ENV})`,
    // ... rest of config
    extra: {
      apiUrl: process.env.API_URL,
      environment: process.env.APP_ENV,
    },
  },
};</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Security Warning</h4>
                    <p>Environment variables in React Native are bundled into your app's JavaScript bundle. This means they're not truly "secret"‚Äîanyone can extract them from your app. Never put API keys for paid services, database credentials, or other secrets directly in your app. Use a backend proxy for sensitive operations.</p>
                </div>

                <h3>Creating an API Client</h3>

                <p>With your environment configured, create a centralized API client:</p>

                <pre><code>// api/client.ts
import Constants from 'expo-constants';

const API_URL = Constants.expoConfig?.extra?.apiUrl;

if (!API_URL) {
  throw new Error('API_URL is not configured in app.config.js');
}

interface RequestOptions extends Omit&lt;RequestInit, 'body'&gt; {
  body?: object;
}

class ApiClient {
  private baseUrl: string;
  private defaultHeaders: HeadersInit;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
    };
  }

  setAuthToken(token: string) {
    this.defaultHeaders = {
      ...this.defaultHeaders,
      'Authorization': `Bearer ${token}`,
    };
  }

  clearAuthToken() {
    const { Authorization, ...rest } = this.defaultHeaders as Record&lt;string, string&gt;;
    this.defaultHeaders = rest;
  }

  async request&lt;T&gt;(
    endpoint: string,
    options: RequestOptions = {}
  ): Promise&lt;T&gt; {
    const { body, headers, ...rest } = options;

    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...rest,
      headers: {
        ...this.defaultHeaders,
        ...headers,
      },
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new ApiError(
        error.message || `HTTP ${response.status}`,
        response.status,
        error.code
      );
    }

    // Handle empty responses
    const text = await response.text();
    return text ? JSON.parse(text) : null;
  }

  get&lt;T&gt;(endpoint: string, options?: RequestOptions) {
    return this.request&lt;T&gt;(endpoint, { ...options, method: 'GET' });
  }

  post&lt;T&gt;(endpoint: string, body?: object, options?: RequestOptions) {
    return this.request&lt;T&gt;(endpoint, { ...options, method: 'POST', body });
  }

  put&lt;T&gt;(endpoint: string, body?: object, options?: RequestOptions) {
    return this.request&lt;T&gt;(endpoint, { ...options, method: 'PUT', body });
  }

  delete&lt;T&gt;(endpoint: string, options?: RequestOptions) {
    return this.request&lt;T&gt;(endpoint, { ...options, method: 'DELETE' });
  }
}

// Export a singleton instance
export const api = new ApiClient(API_URL);

// Usage:
// import { api } from './api/client';
// const users = await api.get&lt;User[]&gt;('/users');
// await api.post('/users', { name: 'John', email: 'john@example.com' });</code></pre>
            </section>

            <!-- Building a Reusable useFetch Hook -->
            <section id="custom-hook">
                <h2>Building a Reusable useFetch Hook</h2>

                <p>We've been writing a lot of boilerplate: state variables, loading states, error handling, abort controllers. Let's encapsulate all of this into a reusable hook that we can use throughout our app.</p>

                <pre><code>// hooks/useFetch.ts
import { useState, useEffect, useCallback } from 'react';

// Define possible states as a union type
type FetchStatus = 'idle' | 'loading' | 'success' | 'error';

interface UseFetchState&lt;T&gt; {
  data: T | null;
  error: Error | null;
  status: FetchStatus;
  isLoading: boolean;
  isError: boolean;
  isSuccess: boolean;
}

interface UseFetchOptions {
  enabled?: boolean;  // Set to false to prevent auto-fetching
  onSuccess?: (data: any) => void;
  onError?: (error: Error) => void;
}

interface UseFetchResult&lt;T&gt; extends UseFetchState&lt;T&gt; {
  refetch: () => Promise&lt;void&gt;;
}

export function useFetch&lt;T&gt;(
  url: string,
  options: UseFetchOptions = {}
): UseFetchResult&lt;T&gt; {
  const { enabled = true, onSuccess, onError } = options;

  const [state, setState] = useState&lt;UseFetchState&lt;T&gt;&gt;({
    data: null,
    error: null,
    status: 'idle',
    isLoading: false,
    isError: false,
    isSuccess: false,
  });

  const fetchData = useCallback(async (signal?: AbortSignal) => {
    setState(prev => ({
      ...prev,
      status: 'loading',
      isLoading: true,
      isError: false,
      error: null,
    }));

    try {
      const response = await fetch(url, { signal });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      setState({
        data,
        error: null,
        status: 'success',
        isLoading: false,
        isError: false,
        isSuccess: true,
      });

      onSuccess?.(data);
    } catch (error) {
      // Ignore abort errors
      if (error instanceof Error && error.name === 'AbortError') {
        return;
      }

      const err = error instanceof Error ? error : new Error('Unknown error');

      setState({
        data: null,
        error: err,
        status: 'error',
        isLoading: false,
        isError: true,
        isSuccess: false,
      });

      onError?.(err);
    }
  }, [url, onSuccess, onError]);

  // Auto-fetch on mount and URL change
  useEffect(() => {
    if (!enabled) return;

    const controller = new AbortController();
    fetchData(controller.signal);

    return () => controller.abort();
  }, [fetchData, enabled]);

  // Manual refetch function
  const refetch = useCallback(async () => {
    await fetchData();
  }, [fetchData]);

  return {
    ...state,
    refetch,
  };
}

// Example usage:
// const { data, isLoading, isError, error, refetch } = useFetch&lt;User[]&gt;(
//   'https://api.example.com/users'
// );</code></pre>

                <h3>Using the Hook</h3>

                <p>Now our components become much cleaner:</p>

                <pre><code>import { View, Text, FlatList, Pressable, ActivityIndicator } from 'react-native';
import { useFetch } from '../hooks/useFetch';

interface Post {
  id: number;
  title: string;
  body: string;
}

export default function PostList() {
  const { 
    data: posts, 
    isLoading, 
    isError, 
    error, 
    refetch 
  } = useFetch&lt;Post[]&gt;('https://jsonplaceholder.typicode.com/posts');

  if (isLoading) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;ActivityIndicator size="large" /&gt;
      &lt;/View&gt;
    );
  }

  if (isError) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;Text&gt;Error: {error?.message}&lt;/Text&gt;
        &lt;Pressable onPress={refetch}&gt;
          &lt;Text&gt;Retry&lt;/Text&gt;
        &lt;/Pressable&gt;
      &lt;/View&gt;
    );
  }

  return (
    &lt;FlatList
      data={posts}
      keyExtractor={item => item.id.toString()}
      renderItem={({ item }) =&gt; (
        &lt;View style={styles.post}&gt;
          &lt;Text style={styles.title}&gt;{item.title}&lt;/Text&gt;
          &lt;Text style={styles.body}&gt;{item.body}&lt;/Text&gt;
        &lt;/View&gt;
      )}
      onRefresh={refetch}
      refreshing={isLoading}
    /&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use This vs React Query</h4>
                    <p>This hook is perfect for learning and simple apps. For production apps with complex data requirements (caching, background refetching, optimistic updates, infinite queries), use a battle-tested library like React Query or SWR. We'll cover those in the next lesson!</p>
                </div>

                <h3>Extended Hook with POST Support</h3>

                <p>Here's an extended version that supports mutations (POST, PUT, DELETE):</p>

                <pre><code>// hooks/useMutation.ts
import { useState, useCallback } from 'react';

interface UseMutationState&lt;T&gt; {
  data: T | null;
  error: Error | null;
  isLoading: boolean;
  isError: boolean;
  isSuccess: boolean;
}

interface UseMutationOptions&lt;T&gt; {
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
}

export function useMutation&lt;TData, TVariables&gt;(
  url: string,
  method: 'POST' | 'PUT' | 'PATCH' | 'DELETE' = 'POST',
  options: UseMutationOptions&lt;TData&gt; = {}
) {
  const { onSuccess, onError } = options;

  const [state, setState] = useState&lt;UseMutationState&lt;TData&gt;&gt;({
    data: null,
    error: null,
    isLoading: false,
    isError: false,
    isSuccess: false,
  });

  const mutate = useCallback(async (variables?: TVariables) => {
    setState(prev => ({
      ...prev,
      isLoading: true,
      isError: false,
      error: null,
    }));

    try {
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: variables ? JSON.stringify(variables) : undefined,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      setState({
        data,
        error: null,
        isLoading: false,
        isError: false,
        isSuccess: true,
      });

      onSuccess?.(data);
      return data;
    } catch (error) {
      const err = error instanceof Error ? error : new Error('Unknown error');

      setState({
        data: null,
        error: err,
        isLoading: false,
        isError: true,
        isSuccess: false,
      });

      onError?.(err);
      throw err;
    }
  }, [url, method, onSuccess, onError]);

  const reset = useCallback(() => {
    setState({
      data: null,
      error: null,
      isLoading: false,
      isError: false,
      isSuccess: false,
    });
  }, []);

  return {
    ...state,
    mutate,
    reset,
  };
}

// Usage:
// const createPost = useMutation&lt;Post, { title: string; body: string }&gt;(
//   'https://api.example.com/posts',
//   'POST',
//   {
//     onSuccess: (newPost) => {
//       console.log('Created:', newPost);
//     },
//   }
// );
// 
// // In a handler:
// await createPost.mutate({ title: 'Hello', body: 'World' });</code></pre>
            </section>

            <!-- Real-World Patterns -->
            <section id="real-world-patterns">
                <h2>Real-World Patterns</h2>

                <p>Let's cover some patterns you'll need in production apps.</p>

                <h3>Adding Timeouts</h3>

                <p><code>fetch()</code> doesn't have a built-in timeout, but we can implement one with <code>AbortController</code>:</p>

                <pre><code>async function fetchWithTimeout&lt;T&gt;(
  url: string,
  options: RequestInit = {},
  timeoutMs: number = 10000  // 10 seconds default
): Promise&lt;T&gt; {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error('Request timeout');
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
}

// Usage:
try {
  const data = await fetchWithTimeout&lt;User&gt;('/api/user', {}, 5000);
} catch (error) {
  if (error.message === 'Request timeout') {
    // Handle timeout specifically
  }
}</code></pre>

                <h3>Retry with Exponential Backoff</h3>

                <p>For unreliable networks, implement automatic retries:</p>

                <pre><code>async function fetchWithRetry&lt;T&gt;(
  url: string,
  options: RequestInit = {},
  maxRetries: number = 3,
  baseDelayMs: number = 1000
): Promise&lt;T&gt; {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);

      if (!response.ok) {
        // Don't retry client errors (4xx)
        if (response.status >= 400 && response.status &lt; 500) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        // Retry server errors (5xx)
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error');

      // Don't retry if we've exhausted attempts
      if (attempt === maxRetries) {
        break;
      }

      // Don't retry client errors
      if (lastError.message.includes('status: 4')) {
        break;
      }

      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = baseDelayMs * Math.pow(2, attempt);
      console.log(`Retry ${attempt + 1}/${maxRetries} in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError;
}

// Usage:
const data = await fetchWithRetry&lt;User[]&gt;('/api/users', {}, 3, 1000);</code></pre>

                <h3>Detecting Network State</h3>

                <p>Before making requests, check if the device has network connectivity:</p>

                <pre><code>import NetInfo from '@react-native-community/netinfo';
import { useEffect, useState } from 'react';

// Hook to track network status
export function useNetworkStatus() {
  const [isConnected, setIsConnected] = useState&lt;boolean | null&gt;(null);
  const [connectionType, setConnectionType] = useState&lt;string | null&gt;(null);

  useEffect(() => {
    // Subscribe to network state updates
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsConnected(state.isConnected);
      setConnectionType(state.type);
    });

    return () => unsubscribe();
  }, []);

  return { isConnected, connectionType };
}

// Usage in a component:
function DataFetcher() {
  const { isConnected } = useNetworkStatus();
  const [shouldFetch, setShouldFetch] = useState(false);

  useEffect(() => {
    // Only fetch when connected
    if (isConnected) {
      setShouldFetch(true);
    }
  }, [isConnected]);

  if (isConnected === false) {
    return (
      &lt;View style={styles.offline}&gt;
        &lt;Text&gt;üìµ You're offline&lt;/Text&gt;
        &lt;Text&gt;Connect to the internet to load data&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  // ... rest of component
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Install NetInfo</h4>
                    <p>NetInfo is a community package. Install it with:</p>
                    <pre><code>npx expo install @react-native-community/netinfo</code></pre>
                </div>

                <h3>Combining Timeout, Retry, and Network Check</h3>

                <p>Here's a production-ready fetch wrapper that combines everything:</p>

                <pre><code>// utils/robustFetch.ts
import NetInfo from '@react-native-community/netinfo';

interface FetchConfig {
  timeoutMs?: number;
  maxRetries?: number;
  retryDelayMs?: number;
  checkNetwork?: boolean;
}

const defaultConfig: Required&lt;FetchConfig&gt; = {
  timeoutMs: 15000,
  maxRetries: 3,
  retryDelayMs: 1000,
  checkNetwork: true,
};

export async function robustFetch&lt;T&gt;(
  url: string,
  options: RequestInit = {},
  config: FetchConfig = {}
): Promise&lt;T&gt; {
  const { timeoutMs, maxRetries, retryDelayMs, checkNetwork } = {
    ...defaultConfig,
    ...config,
  };

  // Check network connectivity first
  if (checkNetwork) {
    const netState = await NetInfo.fetch();
    if (!netState.isConnected) {
      throw new Error('No internet connection');
    }
  }

  let lastError: Error | null = null;

  for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        // Don't retry 4xx errors
        if (response.status >= 400 && response.status &lt; 500) {
          const errorData = await response.json().catch(() => ({}));
          throw new ApiError(
            errorData.message || `HTTP ${response.status}`,
            response.status
          );
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof Error && error.name === 'AbortError') {
        lastError = new Error('Request timeout');
      } else {
        lastError = error instanceof Error ? error : new Error('Unknown error');
      }

      // Don't retry certain errors
      if (
        lastError instanceof ApiError ||
        lastError.message === 'No internet connection'
      ) {
        throw lastError;
      }

      if (attempt &lt; maxRetries) {
        const delay = retryDelayMs * Math.pow(2, attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError;
}</code></pre>
            </section>

            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: User List with Loading States</h3>
                    <p>Build a screen that fetches and displays a list of users from the JSONPlaceholder API.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Fetch users from <code>https://jsonplaceholder.typicode.com/users</code></li>
                        <li>Show a loading spinner while fetching</li>
                        <li>Display an error message with a retry button if the fetch fails</li>
                        <li>Use FlatList to render the users efficiently</li>
                        <li>Implement pull-to-refresh</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Start with the Loading State Trinity pattern. Create three state variables for loading, error, and data. Remember to set loading to true before fetching and handle both success and error cases.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect, useCallback } from 'react';
import { 
  View, 
  Text, 
  FlatList, 
  StyleSheet, 
  ActivityIndicator,
  Pressable,
  RefreshControl
} from 'react-native';

interface User {
  id: number;
  name: string;
  email: string;
  company: {
    name: string;
  };
}

export default function UserListScreen() {
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState&lt;Error | null&gt;(null);

  const fetchUsers = useCallback(async (isRefresh = false) => {
    if (isRefresh) {
      setIsRefreshing(true);
    } else {
      setIsLoading(true);
    }
    setError(null);

    try {
      const response = await fetch(
        'https://jsonplaceholder.typicode.com/users'
      );
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setIsLoading(false);
      setIsRefreshing(false);
    }
  }, []);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  if (isLoading) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;ActivityIndicator size="large" color="#667eea" /&gt;
        &lt;Text style={styles.loadingText}&gt;Loading users...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  if (error) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;Text style={styles.errorEmoji}&gt;üòï&lt;/Text&gt;
        &lt;Text style={styles.errorText}&gt;Failed to load users&lt;/Text&gt;
        &lt;Text style={styles.errorMessage}&gt;{error.message}&lt;/Text&gt;
        &lt;Pressable 
          style={styles.retryButton} 
          onPress={() => fetchUsers()}
        &gt;
          &lt;Text style={styles.retryText}&gt;Try Again&lt;/Text&gt;
        &lt;/Pressable&gt;
      &lt;/View&gt;
    );
  }

  return (
    &lt;FlatList
      data={users}
      keyExtractor={item => item.id.toString()}
      contentContainerStyle={styles.list}
      refreshControl={
        &lt;RefreshControl
          refreshing={isRefreshing}
          onRefresh={() => fetchUsers(true)}
          colors={['#667eea']}
        /&gt;
      }
      renderItem={({ item }) =&gt; (
        &lt;View style={styles.userCard}&gt;
          &lt;Text style={styles.userName}&gt;{item.name}&lt;/Text&gt;
          &lt;Text style={styles.userEmail}&gt;{item.email}&lt;/Text&gt;
          &lt;Text style={styles.userCompany}&gt;{item.company.name}&lt;/Text&gt;
        &lt;/View&gt;
      )}
    /&gt;
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorEmoji: {
    fontSize: 48,
    marginBottom: 12,
  },
  errorText: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  errorMessage: {
    fontSize: 14,
    color: '#666',
    marginBottom: 20,
  },
  retryButton: {
    backgroundColor: '#667eea',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryText: {
    color: 'white',
    fontWeight: '600',
  },
  list: {
    padding: 16,
  },
  userCard: {
    backgroundColor: 'white',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  userName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  userEmail: {
    fontSize: 14,
    color: '#667eea',
    marginBottom: 4,
  },
  userCompany: {
    fontSize: 14,
    color: '#666',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Post Detail with AbortController</h3>
                    <p>Create a Post Detail screen that properly cancels requests when unmounting.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Accept a <code>postId</code> prop</li>
                        <li>Fetch post from <code>https://jsonplaceholder.typicode.com/posts/{id}</code></li>
                        <li>Cancel the request if the component unmounts before it completes</li>
                        <li>Cancel the previous request when <code>postId</code> changes</li>
                        <li>Handle AbortError differently from other errors</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Create an <code>AbortController</code> inside useEffect. Pass its signal to fetch. In the cleanup function, call <code>abort()</code>. Check for <code>error.name === 'AbortError'</code> and don't show it to users.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ActivityIndicator } from 'react-native';

interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

interface PostDetailProps {
  postId: number;
}

export default function PostDetail({ postId }: PostDetailProps) {
  const [post, setPost] = useState&lt;Post | null&gt;(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);

  useEffect(() => {
    // Create abort controller for this effect instance
    const abortController = new AbortController();

    const fetchPost = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/posts/${postId}`,
          { signal: abortController.signal }
        );

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        setPost(data);
      } catch (err) {
        // Check if this was an intentional abort
        if (err instanceof Error && err.name === 'AbortError') {
          console.log(`Fetch for post ${postId} was aborted`);
          return; // Don't update state for aborted requests
        }
        setError(err instanceof Error ? err : new Error('Unknown error'));
      } finally {
        // Only update loading state if not aborted
        if (!abortController.signal.aborted) {
          setIsLoading(false);
        }
      }
    };

    fetchPost();

    // Cleanup: abort the request when effect re-runs or unmounts
    return () => {
      abortController.abort();
    };
  }, [postId]); // Re-fetch when postId changes

  if (isLoading) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;ActivityIndicator size="large" color="#667eea" /&gt;
      &lt;/View&gt;
    );
  }

  if (error) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;Text style={styles.errorText}&gt;Error: {error.message}&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  if (!post) {
    return (
      &lt;View style={styles.centered}&gt;
        &lt;Text&gt;Post not found&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;{post.title}&lt;/Text&gt;
      &lt;Text style={styles.body}&gt;{post.body}&lt;/Text&gt;
      &lt;Text style={styles.meta}&gt;Post #{post.id} by User #{post.userId}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    flex: 1,
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  body: {
    fontSize: 16,
    lineHeight: 24,
    color: '#333',
    marginBottom: 20,
  },
  meta: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  errorText: {
    color: 'red',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Create Your Own useFetch Hook</h3>
                    <p>Build a reusable <code>useFetch</code> hook from scratch based on what you've learned.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Accept a URL string as the first argument</li>
                        <li>Return <code>data</code>, <code>isLoading</code>, <code>error</code>, and <code>refetch</code></li>
                        <li>Automatically fetch on mount</li>
                        <li>Cancel requests on unmount</li>
                        <li>Provide a <code>refetch</code> function for manual refreshes</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use <code>useState</code> for the three states, <code>useEffect</code> for the automatic fetch with cleanup, and <code>useCallback</code> for the refetch function. The refetch function should be stable (not recreated on every render).</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect, useCallback } from 'react';

interface UseFetchResult&lt;T&gt; {
  data: T | null;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

export function useFetch&lt;T&gt;(url: string): UseFetchResult&lt;T&gt; {
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  // Track if we should trigger a refetch
  const [fetchTrigger, setFetchTrigger] = useState(0);

  useEffect(() => {
    const abortController = new AbortController();

    const fetchData = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetch(url, {
          signal: abortController.signal,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err instanceof Error && err.name === 'AbortError') {
          return;
        }
        setError(err instanceof Error ? err : new Error('Unknown error'));
      } finally {
        if (!abortController.signal.aborted) {
          setIsLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      abortController.abort();
    };
  }, [url, fetchTrigger]);

  // Stable refetch function
  const refetch = useCallback(() => {
    setFetchTrigger(prev => prev + 1);
  }, []);

  return { data, isLoading, error, refetch };
}

// Usage example:
// const { data, isLoading, error, refetch } = useFetch&lt;User[]&gt;(
//   'https://jsonplaceholder.typicode.com/users'
// );</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>In this lesson, you learned how to fetch data in React Native‚Äîa skill that transfers almost directly from web development. Let's recap the key points:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>fetch() works identically</strong> in React Native and web‚Äîsame API, same patterns</li>
                        <li><strong>Always handle three states:</strong> loading, success, and error (the Loading State Trinity)</li>
                        <li><strong>Use AbortController</strong> to cancel requests when components unmount or dependencies change</li>
                        <li><strong>Check for AbortError</strong> and don't show it to users‚Äîit's an intentional cancellation</li>
                        <li><strong>Provide user-friendly error messages</strong> based on error type (network, HTTP status, parse)</li>
                        <li><strong>Use environment variables</strong> via <code>app.config.js</code> and <code>expo-constants</code> for API URLs</li>
                        <li><strong>Build reusable hooks</strong> to avoid repeating boilerplate across components</li>
                        <li><strong>Add production patterns</strong> like timeouts, retries, and network state detection for robust apps</li>
                    </ul>
                </div>

                <p>In the next lesson, we'll explore data fetching libraries like React Query and SWR that handle caching, background refetching, and much more‚Äîbuilding on these fundamentals to create even more powerful data management solutions.</p>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m06_l08_advanced_patterns.html" class="prev-link">‚Üê Previous: Advanced Patterns</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m07_l02_data_fetching_libraries.html" class="next-link">Next: Data Fetching Libraries ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
