<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master SectionList for rendering grouped data with headers - perfect for contacts, settings, and organized content">
    <meta name="author" content="React Native & Expo Course">
    <title>SectionList for Grouped Data | Module 5: Lists and Performance | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m05_l01_why_scrollview_isnt_enough.html">Module 5</a> &gt;
            <span>Lesson 5.5</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 5: Lists and Performance</p>
                <h1>SectionList for Grouped Data</h1>
                <p class="lesson-subtitle">Organize your content with section headers and grouped items</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Understand when to use SectionList vs FlatList</li>
                    <li>Structure data for SectionList consumption</li>
                    <li>Implement section headers and item rendering</li>
                    <li>Create sticky section headers for better UX</li>
                    <li>Use section and item separators effectively</li>
                    <li>Build common patterns: contacts, settings, grouped content</li>
                    <li>Apply TypeScript for type-safe sectioned data</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#when-to-use">When to Use SectionList</a></li>
                        <li><a href="#data-structure">The Section Data Structure</a></li>
                        <li><a href="#basic-implementation">Basic Implementation</a></li>
                        <li><a href="#section-headers">Section Headers</a></li>
                        <li><a href="#sticky-headers">Sticky Section Headers</a></li>
                        <li><a href="#separators">Separators</a></li>
                        <li><a href="#section-footer">Section Footers</a></li>
                        <li><a href="#typescript">TypeScript Patterns</a></li>
                        <li><a href="#common-patterns">Common Patterns</a></li>
                        <li><a href="#performance">Performance Considerations</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- When to Use SectionList -->
            <section id="when-to-use">
                <h2>When to Use SectionList</h2>

                <p>SectionList is FlatList's sibling, designed specifically for rendering grouped data with section headers. While you could build this with FlatList, SectionList makes it much cleaner.</p>

                <h3>FlatList vs SectionList</h3>

                <!-- SVG: Comparison visualization -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 600 320" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="600" height="320" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="300" y="25" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">FlatList vs SectionList</text>
                        
                        <!-- FlatList -->
                        <rect x="50" y="50" width="200" height="240" fill="#fff" stroke="#333" stroke-width="2" rx="12"/>
                        <text x="150" y="75" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">FlatList</text>
                        
                        <rect x="65" y="90" width="170" height="30" fill="#e0e0e0" rx="4"/>
                        <text x="150" y="110" text-anchor="middle" font-size="11" fill="#666">Item 1</text>
                        
                        <rect x="65" y="125" width="170" height="30" fill="#e0e0e0" rx="4"/>
                        <text x="150" y="145" text-anchor="middle" font-size="11" fill="#666">Item 2</text>
                        
                        <rect x="65" y="160" width="170" height="30" fill="#e0e0e0" rx="4"/>
                        <text x="150" y="180" text-anchor="middle" font-size="11" fill="#666">Item 3</text>
                        
                        <rect x="65" y="195" width="170" height="30" fill="#e0e0e0" rx="4"/>
                        <text x="150" y="215" text-anchor="middle" font-size="11" fill="#666">Item 4</text>
                        
                        <rect x="65" y="230" width="170" height="30" fill="#e0e0e0" rx="4"/>
                        <text x="150" y="250" text-anchor="middle" font-size="11" fill="#666">Item 5</text>
                        
                        <text x="150" y="300" text-anchor="middle" font-size="11" fill="#666">Flat list of items</text>
                        
                        <!-- SectionList -->
                        <rect x="350" y="50" width="200" height="240" fill="#fff" stroke="#6200ee" stroke-width="2" rx="12"/>
                        <text x="450" y="75" text-anchor="middle" font-size="14" font-weight="bold" fill="#6200ee">SectionList</text>
                        
                        <!-- Section A -->
                        <rect x="365" y="90" width="170" height="24" fill="#6200ee" rx="4"/>
                        <text x="450" y="107" text-anchor="middle" font-size="11" fill="#fff" font-weight="bold">Section A</text>
                        
                        <rect x="365" y="117" width="170" height="26" fill="#e3f2fd" rx="3"/>
                        <text x="450" y="135" text-anchor="middle" font-size="10" fill="#333">Item A1</text>
                        
                        <rect x="365" y="145" width="170" height="26" fill="#e3f2fd" rx="3"/>
                        <text x="450" y="163" text-anchor="middle" font-size="10" fill="#333">Item A2</text>
                        
                        <!-- Section B -->
                        <rect x="365" y="178" width="170" height="24" fill="#6200ee" rx="4"/>
                        <text x="450" y="195" text-anchor="middle" font-size="11" fill="#fff" font-weight="bold">Section B</text>
                        
                        <rect x="365" y="205" width="170" height="26" fill="#e3f2fd" rx="3"/>
                        <text x="450" y="223" text-anchor="middle" font-size="10" fill="#333">Item B1</text>
                        
                        <rect x="365" y="233" width="170" height="26" fill="#e3f2fd" rx="3"/>
                        <text x="450" y="251" text-anchor="middle" font-size="10" fill="#333">Item B2</text>
                        
                        <text x="450" y="300" text-anchor="middle" font-size="11" fill="#6200ee">Grouped with headers</text>
                    </svg>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Choose SectionList When...</h4>
                    <ul>
                        <li>Data is naturally grouped (contacts by letter, settings by category)</li>
                        <li>You need section headers that describe groups</li>
                        <li>You want sticky headers as users scroll</li>
                        <li>Different sections might have different item types</li>
                    </ul>
                    <h4 style="margin-top: 1rem;">Choose FlatList When...</h4>
                    <ul>
                        <li>Data is a simple flat array</li>
                        <li>No grouping or headers needed</li>
                        <li>You're doing your own grouping logic</li>
                        <li>Performance is critical (SectionList has slightly more overhead)</li>
                    </ul>
                </div>

                <h3>Common Use Cases</h3>

                <pre class="mermaid">
flowchart LR
    subgraph SectionList["SectionList Use Cases"]
        S1["üì± Contacts<br/>(A-Z groups)"]
        S2["‚öôÔ∏è Settings<br/>(categories)"]
        S3["üìÖ Events<br/>(by date)"]
        S4["üõí Products<br/>(by category)"]
        S5["üìß Inbox<br/>(Today, Yesterday)"]
    end
    
    style S1 fill:#e3f2fd
    style S2 fill:#e3f2fd
    style S3 fill:#e3f2fd
    style S4 fill:#e3f2fd
    style S5 fill:#e3f2fd
                </pre>
            </section>

            <!-- Data Structure -->
            <section id="data-structure">
                <h2>The Section Data Structure</h2>

                <p>SectionList requires a specific data structure: an array of section objects, each containing a <code>data</code> array for its items.</p>

                <h3>Required Structure</h3>

                <pre><code class="language-tsx">// The sections prop expects this shape
const sections = [
  {
    // Optional: any extra data for the section
    title: 'Section Title',
    
    // Required: array of items in this section
    data: [item1, item2, item3],
  },
  {
    title: 'Another Section',
    data: [item4, item5],
  },
];

// Minimal example
const minimalSections = [
  { data: ['A', 'B', 'C'] },
  { data: ['D', 'E'] },
];</code></pre>

                <h3>Transforming Flat Data to Sections</h3>

                <pre><code class="language-tsx">// Starting with flat data
interface Contact {
  id: string;
  name: string;
  phone: string;
}

const flatContacts: Contact[] = [
  { id: '1', name: 'Alice Smith', phone: '555-0001' },
  { id: '2', name: 'Bob Johnson', phone: '555-0002' },
  { id: '3', name: 'Amy Brown', phone: '555-0003' },
  { id: '4', name: 'Brian Davis', phone: '555-0004' },
];

// Transform to sections (grouped by first letter)
interface Section {
  title: string;
  data: Contact[];
}

const groupByFirstLetter = (contacts: Contact[]): Section[] => {
  // Group contacts by first letter
  const groups = contacts.reduce((acc, contact) => {
    const letter = contact.name[0].toUpperCase();
    if (!acc[letter]) {
      acc[letter] = [];
    }
    acc[letter].push(contact);
    return acc;
  }, {} as Record&lt;string, Contact[]&gt;);

  // Convert to section array and sort
  return Object.entries(groups)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([letter, contacts]) => ({
      title: letter,
      data: contacts.sort((a, b) => a.name.localeCompare(b.name)),
    }));
};

const sections = groupByFirstLetter(flatContacts);
// Result:
// [
//   { title: 'A', data: [Alice, Amy] },
//   { title: 'B', data: [Bob, Brian] },
// ]</code></pre>

                <h3>Adding Section Metadata</h3>

                <pre><code class="language-tsx">// Sections can include any extra properties
interface CategorySection {
  title: string;
  subtitle?: string;
  icon?: string;
  collapsible?: boolean;
  data: Product[];
}

const productSections: CategorySection[] = [
  {
    title: 'Electronics',
    subtitle: '24 items',
    icon: 'üì±',
    data: electronicsProducts,
  },
  {
    title: 'Clothing',
    subtitle: '56 items',
    icon: 'üëï',
    data: clothingProducts,
  },
  {
    title: 'Books',
    subtitle: '12 items',
    icon: 'üìö',
    collapsible: true,
    data: bookProducts,
  },
];</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è The data Property is Required</h4>
                    <p>Every section object <strong>must</strong> have a <code>data</code> property that's an array. Even for empty sections:</p>
                    <pre><code class="language-tsx">// ‚ùå Wrong - missing data
const badSection = { title: 'Empty' };

// ‚úÖ Correct - empty array
const goodSection = { title: 'Empty', data: [] };</code></pre>
                </div>
            </section>

            <!-- Basic Implementation -->
            <section id="basic-implementation">
                <h2>Basic Implementation</h2>

                <p>SectionList has a similar API to FlatList, with additional props for handling sections.</p>

                <h3>Minimal Example</h3>

                <pre><code class="language-tsx">import { SectionList, View, Text, StyleSheet } from 'react-native';

const DATA = [
  {
    title: 'Fruits',
    data: ['Apple', 'Banana', 'Orange'],
  },
  {
    title: 'Vegetables',
    data: ['Carrot', 'Broccoli', 'Spinach'],
  },
];

function BasicSectionList() {
  return (
    &lt;SectionList
      sections={DATA}
      keyExtractor={(item, index) => item + index}
      renderItem={({ item }) => (
        &lt;View style={styles.item}&gt;
          &lt;Text&gt;{item}&lt;/Text&gt;
        &lt;/View&gt;
      )}
      renderSectionHeader={({ section: { title } }) => (
        &lt;View style={styles.header}&gt;
          &lt;Text style={styles.headerText}&gt;{title}&lt;/Text&gt;
        &lt;/View&gt;
      )}
    /&gt;
  );
}

const styles = StyleSheet.create({
  header: {
    backgroundColor: '#f4f4f4',
    padding: 12,
  },
  headerText: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  item: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
});</code></pre>

                <h3>Required Props</h3>

                <div class="card">
                    <h4>üìö SectionList Required Props</h4>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 0.5rem;">
                        <tr>
                            <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Prop</th>
                            <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Type</th>
                            <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Description</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>sections</code></td>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>Array&lt;Section&gt;</code></td>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">Array of section objects with <code>data</code> arrays</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><code>renderItem</code></td>
                            <td style="padding: 8px;"><code>Function</code></td>
                            <td style="padding: 8px;">Renders each item within sections</td>
                        </tr>
                    </table>
                </div>

                <h3>The renderItem Function</h3>

                <p>SectionList's <code>renderItem</code> receives more information than FlatList's:</p>

                <pre><code class="language-tsx">// renderItem receives section info too
&lt;SectionList
  sections={sections}
  renderItem={({ item, index, section, separators }) => {
    // item: The current data item
    // index: Position within the section (not global)
    // section: The entire section object
    // separators: Same as FlatList
    
    return (
      &lt;View&gt;
        &lt;Text&gt;{item.name}&lt;/Text&gt;
        &lt;Text style={styles.sectionLabel}&gt;
          In section: {section.title}
        &lt;/Text&gt;
        {index === 0 && (
          &lt;Text style={styles.firstBadge}&gt;First in section&lt;/Text&gt;
        )}
      &lt;/View&gt;
    );
  }}
/&gt;</code></pre>
            </section>

            <!-- Section Headers -->
            <section id="section-headers">
                <h2>Section Headers</h2>

                <p>Section headers are what make SectionList special. They appear before each group of items.</p>

                <h3>renderSectionHeader</h3>

                <pre><code class="language-tsx">// Basic section header
&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={({ section }) => (
    &lt;View style={styles.sectionHeader}&gt;
      &lt;Text style={styles.sectionTitle}&gt;{section.title}&lt;/Text&gt;
    &lt;/View&gt;
  )}
/&gt;

// Header with metadata
interface ProductSection {
  title: string;
  icon: string;
  itemCount: number;
  data: Product[];
}

&lt;SectionList
  sections={productSections}
  renderItem={renderProduct}
  renderSectionHeader={({ section }) => (
    &lt;View style={styles.sectionHeader}&gt;
      &lt;Text style={styles.sectionIcon}&gt;{section.icon}&lt;/Text&gt;
      &lt;View style={styles.sectionInfo}&gt;
        &lt;Text style={styles.sectionTitle}&gt;{section.title}&lt;/Text&gt;
        &lt;Text style={styles.sectionCount}&gt;
          {section.data.length} items
        &lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  )}
/&gt;</code></pre>

                <h3>Conditional Headers</h3>

                <pre><code class="language-tsx">// Only show header if section has items
&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={({ section }) => {
    // Don't render header for empty sections
    if (section.data.length === 0) {
      return null;
    }
    
    return (
      &lt;View style={styles.sectionHeader}&gt;
        &lt;Text&gt;{section.title}&lt;/Text&gt;
      &lt;/View&gt;
    );
  }}
/&gt;

// Different header styles per section
&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={({ section }) => {
    const isHighlighted = section.highlighted;
    
    return (
      &lt;View style={[
        styles.sectionHeader,
        isHighlighted && styles.highlightedHeader,
      ]}&gt;
        &lt;Text style={[
          styles.sectionTitle,
          isHighlighted && styles.highlightedTitle,
        ]}&gt;
          {section.title}
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }}
/&gt;</code></pre>

                <h3>Interactive Headers</h3>

                <pre><code class="language-tsx">// Collapsible sections
function CollapsibleSectionList() {
  const [collapsedSections, setCollapsedSections] = useState&lt;Set&lt;string&gt;&gt;(
    new Set()
  );

  const toggleSection = (title: string) => {
    setCollapsedSections(prev => {
      const next = new Set(prev);
      if (next.has(title)) {
        next.delete(title);
      } else {
        next.add(title);
      }
      return next;
    });
  };

  // Filter out collapsed section data
  const visibleSections = sections.map(section => ({
    ...section,
    data: collapsedSections.has(section.title) ? [] : section.data,
  }));

  return (
    &lt;SectionList
      sections={visibleSections}
      renderItem={renderItem}
      renderSectionHeader={({ section }) => (
        &lt;Pressable
          style={styles.sectionHeader}
          onPress={() => toggleSection(section.title)}
        &gt;
          &lt;Text style={styles.sectionTitle}&gt;{section.title}&lt;/Text&gt;
          &lt;Text style={styles.collapseIcon}&gt;
            {collapsedSections.has(section.title) ? '‚ñ∂' : '‚ñº'}
          &lt;/Text&gt;
        &lt;/Pressable&gt;
      )}
    /&gt;
  );
}</code></pre>
            </section>

            <!-- Sticky Section Headers -->
            <section id="sticky-headers">
                <h2>Sticky Section Headers</h2>

                <p>Sticky headers remain visible at the top while scrolling through their section. This is one of SectionList's most powerful features.</p>

                <h3>Enabling Sticky Headers</h3>

                <pre><code class="language-tsx">// Sticky headers are ON by default on iOS, OFF on Android
// Explicitly enable for consistency:
&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={renderSectionHeader}
  stickySectionHeadersEnabled={true}  // Enable sticky headers
/&gt;

// Disable sticky headers:
&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={renderSectionHeader}
  stickySectionHeadersEnabled={false}
/&gt;</code></pre>

                <!-- SVG: Sticky header behavior -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 600 280" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="600" height="280" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="300" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Sticky Section Headers Behavior</text>
                        
                        <!-- State 1: Initial -->
                        <rect x="30" y="45" width="130" height="200" fill="#fff" stroke="#333" stroke-width="2" rx="12"/>
                        <text x="95" y="65" text-anchor="middle" font-size="10" fill="#666">Initial</text>
                        
                        <rect x="40" y="75" width="110" height="20" fill="#6200ee" rx="3"/>
                        <text x="95" y="89" text-anchor="middle" font-size="9" fill="#fff">Section A</text>
                        <rect x="40" y="98" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="40" y="118" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="40" y="138" width="110" height="20" fill="#6200ee" rx="3"/>
                        <text x="95" y="152" text-anchor="middle" font-size="9" fill="#fff">Section B</text>
                        <rect x="40" y="161" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="40" y="181" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="40" y="201" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        
                        <!-- Arrow -->
                        <text x="175" y="145" font-size="20" fill="#666">‚Üí</text>
                        <text x="175" y="165" font-size="9" fill="#666">scroll</text>
                        
                        <!-- State 2: Scrolling -->
                        <rect x="200" y="45" width="130" height="200" fill="#fff" stroke="#333" stroke-width="2" rx="12"/>
                        <text x="265" y="65" text-anchor="middle" font-size="10" fill="#666">Scrolling</text>
                        
                        <!-- Sticky header A -->
                        <rect x="210" y="75" width="110" height="20" fill="#6200ee" rx="3" stroke="#4a148c" stroke-width="2"/>
                        <text x="265" y="89" text-anchor="middle" font-size="9" fill="#fff">Section A (stuck)</text>
                        
                        <rect x="210" y="98" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <text x="265" y="110" text-anchor="middle" font-size="8" fill="#666">Item A3</text>
                        <rect x="210" y="118" width="110" height="20" fill="#6200ee" rx="3"/>
                        <text x="265" y="132" text-anchor="middle" font-size="9" fill="#fff">Section B</text>
                        <rect x="210" y="141" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="210" y="161" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="210" y="181" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="210" y="201" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        
                        <!-- Arrow -->
                        <text x="345" y="145" font-size="20" fill="#666">‚Üí</text>
                        <text x="345" y="165" font-size="9" fill="#666">scroll</text>
                        
                        <!-- State 3: Section B sticky -->
                        <rect x="370" y="45" width="130" height="200" fill="#fff" stroke="#333" stroke-width="2" rx="12"/>
                        <text x="435" y="65" text-anchor="middle" font-size="10" fill="#666">In Section B</text>
                        
                        <!-- Sticky header B (pushed A away) -->
                        <rect x="380" y="75" width="110" height="20" fill="#6200ee" rx="3" stroke="#4a148c" stroke-width="2"/>
                        <text x="435" y="89" text-anchor="middle" font-size="9" fill="#fff">Section B (stuck)</text>
                        
                        <rect x="380" y="98" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <text x="435" y="110" text-anchor="middle" font-size="8" fill="#666">Item B2</text>
                        <rect x="380" y="118" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <text x="435" y="130" text-anchor="middle" font-size="8" fill="#666">Item B3</text>
                        <rect x="380" y="138" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="380" y="158" width="110" height="20" fill="#6200ee" rx="3"/>
                        <text x="435" y="172" text-anchor="middle" font-size="9" fill="#fff">Section C</text>
                        <rect x="380" y="181" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        <rect x="380" y="201" width="110" height="18" fill="#e3f2fd" rx="2"/>
                        
                        <!-- Legend -->
                        <rect x="520" y="100" width="15" height="15" fill="#6200ee" stroke="#4a148c" stroke-width="2" rx="2"/>
                        <text x="540" y="112" font-size="10" fill="#666">Stuck</text>
                        <rect x="520" y="125" width="15" height="15" fill="#6200ee" rx="2"/>
                        <text x="540" y="137" font-size="10" fill="#666">Normal</text>
                    </svg>
                </div>

                <h3>Styling Sticky Headers</h3>

                <pre><code class="language-tsx">// Add shadow when header is stuck
const styles = StyleSheet.create({
  sectionHeader: {
    backgroundColor: '#fff',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    // iOS shadow
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    // Android elevation
    elevation: 3,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
});

// Compact contact-list style headers
const contactHeaderStyles = StyleSheet.create({
  header: {
    backgroundColor: '#f7f7f7',
    paddingVertical: 6,
    paddingHorizontal: 16,
  },
  letter: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#6200ee',
  },
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Sticky Header Best Practices</h4>
                    <ul>
                        <li><strong>Keep headers short:</strong> Tall sticky headers take up too much screen space</li>
                        <li><strong>Use subtle backgrounds:</strong> Solid backgrounds prevent content showing through</li>
                        <li><strong>Add shadows:</strong> Helps users see the header is elevated above content</li>
                        <li><strong>Enable on both platforms:</strong> Set <code>stickySectionHeadersEnabled</code> explicitly for consistency</li>
                    </ul>
                </div>
            </section>
            <!-- Separators -->
            <section id="separators">
                <h2>Separators</h2>

                <p>SectionList provides granular control over separators with different components for items within sections and between sections.</p>

                <h3>ItemSeparatorComponent</h3>

                <p>Renders between items within a section (not after the last item):</p>

                <pre><code class="language-tsx">&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={renderSectionHeader}
  ItemSeparatorComponent={() => (
    &lt;View style={styles.itemSeparator} /&gt;
  )}
/&gt;

const styles = StyleSheet.create({
  itemSeparator: {
    height: 1,
    backgroundColor: '#e0e0e0',
    marginLeft: 16,  // Inset for iOS style
  },
});</code></pre>

                <h3>SectionSeparatorComponent</h3>

                <p>Renders between sections (after section header and before next section's header):</p>

                <pre><code class="language-tsx">&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={renderSectionHeader}
  SectionSeparatorComponent={() => (
    &lt;View style={styles.sectionSeparator} /&gt;
  )}
/&gt;

const styles = StyleSheet.create({
  sectionSeparator: {
    height: 24,
    backgroundColor: '#f5f5f5',
  },
});</code></pre>

                <h3>Understanding Separator Placement</h3>

                <!-- SVG: Separator placement diagram -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 500 400" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="500" height="400" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="250" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Separator Placement</text>
                        
                        <!-- List container -->
                        <rect x="100" y="45" width="300" height="330" fill="#fff" stroke="#333" stroke-width="2" rx="8"/>
                        
                        <!-- Section A Header -->
                        <rect x="110" y="55" width="280" height="30" fill="#6200ee" rx="4"/>
                        <text x="250" y="75" text-anchor="middle" font-size="12" fill="#fff">Section A Header</text>
                        
                        <!-- Section Separator (top of section) -->
                        <rect x="110" y="88" width="280" height="8" fill="#ffecb3" stroke="#ff9800" stroke-width="1"/>
                        <text x="420" y="95" font-size="9" fill="#ff9800">SectionSeparator</text>
                        
                        <!-- Item A1 -->
                        <rect x="110" y="99" width="280" height="35" fill="#e3f2fd" rx="2"/>
                        <text x="250" y="121" text-anchor="middle" font-size="11" fill="#333">Item A1</text>
                        
                        <!-- Item Separator -->
                        <rect x="126" y="136" width="264" height="2" fill="#c8e6c9"/>
                        <text x="420" y="140" font-size="9" fill="#4CAF50">ItemSeparator</text>
                        
                        <!-- Item A2 -->
                        <rect x="110" y="140" width="280" height="35" fill="#e3f2fd" rx="2"/>
                        <text x="250" y="162" text-anchor="middle" font-size="11" fill="#333">Item A2</text>
                        
                        <!-- Item Separator -->
                        <rect x="126" y="177" width="264" height="2" fill="#c8e6c9"/>
                        
                        <!-- Item A3 -->
                        <rect x="110" y="181" width="280" height="35" fill="#e3f2fd" rx="2"/>
                        <text x="250" y="203" text-anchor="middle" font-size="11" fill="#333">Item A3 (last in section)</text>
                        
                        <!-- Section Separator (end of section) -->
                        <rect x="110" y="219" width="280" height="8" fill="#ffecb3" stroke="#ff9800" stroke-width="1"/>
                        <text x="420" y="226" font-size="9" fill="#ff9800">SectionSeparator</text>
                        
                        <!-- Section B Header -->
                        <rect x="110" y="230" width="280" height="30" fill="#6200ee" rx="4"/>
                        <text x="250" y="250" text-anchor="middle" font-size="12" fill="#fff">Section B Header</text>
                        
                        <!-- Section Separator -->
                        <rect x="110" y="263" width="280" height="8" fill="#ffecb3" stroke="#ff9800" stroke-width="1"/>
                        
                        <!-- Item B1 -->
                        <rect x="110" y="274" width="280" height="35" fill="#e3f2fd" rx="2"/>
                        <text x="250" y="296" text-anchor="middle" font-size="11" fill="#333">Item B1</text>
                        
                        <!-- Item Separator -->
                        <rect x="126" y="311" width="264" height="2" fill="#c8e6c9"/>
                        
                        <!-- Item B2 -->
                        <rect x="110" y="315" width="280" height="35" fill="#e3f2fd" rx="2"/>
                        <text x="250" y="337" text-anchor="middle" font-size="11" fill="#333">Item B2</text>
                        
                        <!-- No separator after last item -->
                        <text x="250" y="365" text-anchor="middle" font-size="9" fill="#999">(No separator after last item)</text>
                        
                        <!-- Legend -->
                        <rect x="30" y="55" width="50" height="12" fill="#c8e6c9"/>
                        <text x="30" y="80" font-size="9" fill="#4CAF50">Item</text>
                        <text x="30" y="90" font-size="9" fill="#4CAF50">Separator</text>
                        
                        <rect x="30" y="105" width="50" height="12" fill="#ffecb3"/>
                        <text x="30" y="130" font-size="9" fill="#ff9800">Section</text>
                        <text x="30" y="140" font-size="9" fill="#ff9800">Separator</text>
                    </svg>
                </div>

                <h3>Context-Aware Separators</h3>

                <p>Separator components receive information about their position:</p>

                <pre><code class="language-tsx">// ItemSeparatorComponent with context
&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  ItemSeparatorComponent={({ highlighted, leadingItem, trailingItem, section }) => {
    // highlighted: true if adjacent item is highlighted
    // leadingItem: the item above this separator
    // trailingItem: the item below this separator
    // section: the section containing these items
    
    return (
      &lt;View style={[
        styles.separator,
        highlighted && styles.separatorHighlighted,
      ]} /&gt;
    );
  }}
/&gt;

// SectionSeparatorComponent with context
&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  SectionSeparatorComponent={({ leadingItem, leadingSection, trailingItem, trailingSection }) => {
    // Render different separator after different sections
    if (leadingSection?.title === 'Featured') {
      return &lt;View style={styles.featuredSeparator} /&gt;;
    }
    return &lt;View style={styles.normalSeparator} /&gt;;
  }}
/&gt;</code></pre>

                <h3>Common Separator Patterns</h3>

                <pre><code class="language-tsx">// Pattern 1: Inset separators (iOS style)
const InsetSeparator = () => (
  &lt;View style={{
    height: StyleSheet.hairlineWidth,
    backgroundColor: '#c6c6c8',
    marginLeft: 60,  // Inset from left
  }} /&gt;
);

// Pattern 2: Full-width separators
const FullSeparator = () => (
  &lt;View style={{
    height: 1,
    backgroundColor: '#e0e0e0',
  }} /&gt;
);

// Pattern 3: Spacing separators
const SpacingSeparator = () => (
  &lt;View style={{ height: 12 }} /&gt;
);

// Pattern 4: Section gap with background
const SectionGap = () => (
  &lt;View style={{
    height: 20,
    backgroundColor: '#f5f5f5',
  }} /&gt;
);</code></pre>
            </section>

            <!-- Section Footers -->
            <section id="section-footer">
                <h2>Section Footers</h2>

                <p>While less common than headers, section footers can be useful for actions or summaries at the end of each section.</p>

                <h3>renderSectionFooter</h3>

                <pre><code class="language-tsx">&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={renderSectionHeader}
  renderSectionFooter={({ section }) => (
    &lt;View style={styles.sectionFooter}&gt;
      &lt;Text style={styles.footerText}&gt;
        {section.data.length} items in {section.title}
      &lt;/Text&gt;
    &lt;/View&gt;
  )}
/&gt;

// Footer with action
&lt;SectionList
  sections={cartSections}
  renderItem={renderCartItem}
  renderSectionHeader={renderSectionHeader}
  renderSectionFooter={({ section }) => (
    &lt;View style={styles.sectionFooter}&gt;
      &lt;Text style={styles.subtotal}&gt;
        Subtotal: ${section.data.reduce((sum, item) => sum + item.price, 0).toFixed(2)}
      &lt;/Text&gt;
      &lt;Pressable 
        style={styles.clearButton}
        onPress={() => clearSection(section.title)}
      &gt;
        &lt;Text&gt;Clear Section&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  )}
/&gt;</code></pre>

                <h3>Conditional Footers</h3>

                <pre><code class="language-tsx">// Only show footer for sections with items
renderSectionFooter={({ section }) => {
  if (section.data.length === 0) {
    return null;
  }
  
  // Only show footer if section has a footer property
  if (!section.showFooter) {
    return null;
  }
  
  return (
    &lt;View style={styles.footer}&gt;
      &lt;Text&gt;{section.footerText}&lt;/Text&gt;
    &lt;/View&gt;
  );
}}</code></pre>
            </section>

            <!-- TypeScript Patterns -->
            <section id="typescript">
                <h2>TypeScript Patterns</h2>

                <p>TypeScript helps catch data structure mistakes early and provides excellent autocomplete when working with sections.</p>

                <h3>Typing Sections</h3>

                <pre><code class="language-tsx">import { SectionList, SectionListData, SectionListRenderItem } from 'react-native';

// Define your item type
interface Contact {
  id: string;
  name: string;
  phone: string;
  avatar: string;
}

// Define your section type (extends the base with custom properties)
interface ContactSection {
  title: string;
  data: Contact[];
}

// Type the SectionList
function TypedContactList() {
  const sections: ContactSection[] = [
    {
      title: 'A',
      data: [
        { id: '1', name: 'Alice', phone: '555-0001', avatar: '...' },
      ],
    },
  ];

  const renderItem: SectionListRenderItem&lt;Contact, ContactSection&gt; = ({ item, section }) => (
    &lt;View&gt;
      &lt;Text&gt;{item.name}&lt;/Text&gt;  {/* item is Contact */}
      &lt;Text&gt;Section: {section.title}&lt;/Text&gt;  {/* section is ContactSection */}
    &lt;/View&gt;
  );

  return (
    &lt;SectionList&lt;Contact, ContactSection&gt;
      sections={sections}
      renderItem={renderItem}
      renderSectionHeader={({ section }) => (
        &lt;Text&gt;{section.title}&lt;/Text&gt;  {/* section.title is typed */}
      )}
      keyExtractor={(item) => item.id}  {/* item.id is typed */}
    /&gt;
  );
}</code></pre>

                <h3>Using SectionListData</h3>

                <pre><code class="language-tsx">import { SectionListData } from 'react-native';

// SectionListData is the built-in type for sections
// It requires a data property and allows custom properties

interface Product {
  id: string;
  name: string;
  price: number;
}

// Using SectionListData with custom section properties
type ProductSection = SectionListData&lt;Product&gt; & {
  title: string;
  icon: string;
};

const sections: ProductSection[] = [
  {
    title: 'Electronics',
    icon: 'üì±',
    data: [
      { id: '1', name: 'Phone', price: 999 },
      { id: '2', name: 'Laptop', price: 1499 },
    ],
  },
];

// Alternative: Define your own section type
interface MySection&lt;T&gt; {
  title: string;
  subtitle?: string;
  data: T[];
}

const mySections: MySection&lt;Product&gt;[] = [...];</code></pre>

                <h3>Typing Render Functions</h3>

                <pre><code class="language-tsx">import { 
  SectionListRenderItem,
  SectionListRenderItemInfo,
} from 'react-native';

// Option 1: Use the SectionListRenderItem type
const renderItem: SectionListRenderItem&lt;Contact, ContactSection&gt; = (info) => {
  const { item, index, section, separators } = info;
  return &lt;ContactCard contact={item} /&gt;;
};

// Option 2: Type the parameter directly
const renderItem = ({ 
  item, 
  section 
}: SectionListRenderItemInfo&lt;Contact, ContactSection&gt;) => {
  return &lt;ContactCard contact={item} sectionTitle={section.title} /&gt;;
};

// Option 3: Inline with generic
&lt;SectionList&lt;Contact, ContactSection&gt;
  sections={sections}
  renderItem={({ item }) => &lt;ContactCard contact={item} /&gt;}
/&gt;</code></pre>

                <h3>Generic Section List Component</h3>

                <pre><code class="language-tsx">// Create a reusable typed section list
interface GenericSection&lt;T&gt; {
  title: string;
  data: T[];
}

interface GroupedListProps&lt;T&gt; {
  sections: GenericSection&lt;T&gt;[];
  renderItem: (item: T) => React.ReactElement;
  keyExtractor: (item: T) => string;
}

function GroupedList&lt;T&gt;({ 
  sections, 
  renderItem, 
  keyExtractor 
}: GroupedListProps&lt;T&gt;) {
  return (
    &lt;SectionList&lt;T, GenericSection&lt;T&gt;&gt;
      sections={sections}
      keyExtractor={keyExtractor}
      renderItem={({ item }) => renderItem(item)}
      renderSectionHeader={({ section }) => (
        &lt;View style={styles.header}&gt;
          &lt;Text style={styles.headerText}&gt;{section.title}&lt;/Text&gt;
        &lt;/View&gt;
      )}
      stickySectionHeadersEnabled
    /&gt;
  );
}

// Usage
&lt;GroupedList&lt;Contact&gt;
  sections={contactSections}
  renderItem={(contact) => &lt;ContactRow contact={contact} /&gt;}
  keyExtractor={(contact) => contact.id}
/&gt;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ TypeScript Tips</h4>
                    <ul>
                        <li><strong>Always type your items:</strong> Prevents rendering bugs and enables autocomplete</li>
                        <li><strong>Extend section types:</strong> Add custom properties like <code>title</code>, <code>icon</code>, etc.</li>
                        <li><strong>Use the generic:</strong> <code>&lt;SectionList&lt;ItemType, SectionType&gt;</code></li>
                        <li><strong>Type render functions:</strong> Use <code>SectionListRenderItem</code> for explicit typing</li>
                    </ul>
                </div>
            </section>

            <!-- Common Patterns -->
            <section id="common-patterns">
                <h2>Common Patterns</h2>

                <p>Let's implement the most common SectionList use cases you'll encounter in real apps.</p>

                <h3>Pattern 1: Contacts List (A-Z)</h3>

                <pre><code class="language-tsx">import React, { useMemo, useCallback } from 'react';
import { SectionList, View, Text, Image, StyleSheet } from 'react-native';

interface Contact {
  id: string;
  name: string;
  phone: string;
  avatar: string;
}

interface ContactSection {
  title: string;
  data: Contact[];
}

// Group contacts alphabetically
const groupContacts = (contacts: Contact[]): ContactSection[] => {
  const sorted = [...contacts].sort((a, b) => 
    a.name.localeCompare(b.name)
  );
  
  const groups: Record&lt;string, Contact[]&gt; = {};
  
  sorted.forEach(contact => {
    const letter = contact.name[0].toUpperCase();
    if (!groups[letter]) groups[letter] = [];
    groups[letter].push(contact);
  });
  
  return Object.entries(groups)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([letter, contacts]) => ({
      title: letter,
      data: contacts,
    }));
};

const ContactItem = React.memo(({ contact }: { contact: Contact }) => (
  &lt;View style={styles.contactItem}&gt;
    &lt;Image source={{ uri: contact.avatar }} style={styles.avatar} /&gt;
    &lt;View style={styles.contactInfo}&gt;
      &lt;Text style={styles.name}&gt;{contact.name}&lt;/Text&gt;
      &lt;Text style={styles.phone}&gt;{contact.phone}&lt;/Text&gt;
    &lt;/View&gt;
  &lt;/View&gt;
));

export default function ContactsList({ contacts }: { contacts: Contact[] }) {
  const sections = useMemo(() => groupContacts(contacts), [contacts]);

  const renderItem = useCallback(
    ({ item }: { item: Contact }) => &lt;ContactItem contact={item} /&gt;,
    []
  );

  const renderSectionHeader = useCallback(
    ({ section }: { section: ContactSection }) => (
      &lt;View style={styles.sectionHeader}&gt;
        &lt;Text style={styles.sectionTitle}&gt;{section.title}&lt;/Text&gt;
      &lt;/View&gt;
    ),
    []
  );

  return (
    &lt;SectionList&lt;Contact, ContactSection&gt;
      sections={sections}
      renderItem={renderItem}
      renderSectionHeader={renderSectionHeader}
      keyExtractor={(item) => item.id}
      stickySectionHeadersEnabled
      ItemSeparatorComponent={() => &lt;View style={styles.separator} /&gt;}
    /&gt;
  );
}

const styles = StyleSheet.create({
  sectionHeader: {
    backgroundColor: '#f7f7f7',
    paddingVertical: 6,
    paddingHorizontal: 16,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#6200ee',
  },
  contactItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    paddingHorizontal: 16,
    backgroundColor: '#fff',
  },
  avatar: {
    width: 44,
    height: 44,
    borderRadius: 22,
    marginRight: 12,
  },
  contactInfo: {
    flex: 1,
  },
  name: {
    fontSize: 16,
    fontWeight: '500',
  },
  phone: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  separator: {
    height: StyleSheet.hairlineWidth,
    backgroundColor: '#c6c6c8',
    marginLeft: 72,
  },
});</code></pre>

                <h3>Pattern 2: Settings Screen</h3>

                <pre><code class="language-tsx">import React, { useCallback } from 'react';
import { 
  SectionList, 
  View, 
  Text, 
  Switch, 
  Pressable, 
  StyleSheet 
} from 'react-native';

type SettingType = 'toggle' | 'navigate' | 'action';

interface Setting {
  id: string;
  label: string;
  type: SettingType;
  value?: boolean;
  icon?: string;
  danger?: boolean;
}

interface SettingsSection {
  title: string;
  data: Setting[];
}

const SETTINGS: SettingsSection[] = [
  {
    title: 'Account',
    data: [
      { id: 'profile', label: 'Edit Profile', type: 'navigate', icon: 'üë§' },
      { id: 'password', label: 'Change Password', type: 'navigate', icon: 'üîë' },
      { id: 'email', label: 'Email Preferences', type: 'navigate', icon: 'üìß' },
    ],
  },
  {
    title: 'Preferences',
    data: [
      { id: 'notifications', label: 'Push Notifications', type: 'toggle', value: true, icon: 'üîî' },
      { id: 'darkMode', label: 'Dark Mode', type: 'toggle', value: false, icon: 'üåô' },
      { id: 'sounds', label: 'Sound Effects', type: 'toggle', value: true, icon: 'üîä' },
    ],
  },
  {
    title: 'Support',
    data: [
      { id: 'help', label: 'Help Center', type: 'navigate', icon: '‚ùì' },
      { id: 'feedback', label: 'Send Feedback', type: 'navigate', icon: 'üí¨' },
      { id: 'about', label: 'About', type: 'navigate', icon: '‚ÑπÔ∏è' },
    ],
  },
  {
    title: '',
    data: [
      { id: 'logout', label: 'Log Out', type: 'action', icon: 'üö™', danger: true },
    ],
  },
];

const SettingRow = ({ 
  setting, 
  onToggle, 
  onPress 
}: { 
  setting: Setting;
  onToggle: (id: string, value: boolean) => void;
  onPress: (id: string) => void;
}) => {
  const content = (
    &lt;View style={styles.settingRow}&gt;
      &lt;Text style={styles.settingIcon}&gt;{setting.icon}&lt;/Text&gt;
      &lt;Text style={[
        styles.settingLabel,
        setting.danger && styles.dangerLabel,
      ]}&gt;
        {setting.label}
      &lt;/Text&gt;
      {setting.type === 'toggle' && (
        &lt;Switch
          value={setting.value}
          onValueChange={(value) => onToggle(setting.id, value)}
        /&gt;
      )}
      {setting.type === 'navigate' && (
        &lt;Text style={styles.chevron}&gt;‚Ä∫&lt;/Text&gt;
      )}
    &lt;/View&gt;
  );

  if (setting.type === 'toggle') {
    return content;
  }

  return (
    &lt;Pressable onPress={() => onPress(setting.id)}&gt;
      {content}
    &lt;/Pressable&gt;
  );
};

export default function SettingsScreen() {
  const handleToggle = useCallback((id: string, value: boolean) => {
    console.log(`Toggle ${id}: ${value}`);
  }, []);

  const handlePress = useCallback((id: string) => {
    console.log(`Navigate/Action: ${id}`);
  }, []);

  const renderItem = useCallback(
    ({ item }: { item: Setting }) => (
      &lt;SettingRow 
        setting={item} 
        onToggle={handleToggle}
        onPress={handlePress}
      /&gt;
    ),
    [handleToggle, handlePress]
  );

  const renderSectionHeader = useCallback(
    ({ section }: { section: SettingsSection }) => {
      if (!section.title) return null;
      return (
        &lt;View style={styles.sectionHeader}&gt;
          &lt;Text style={styles.sectionTitle}&gt;{section.title}&lt;/Text&gt;
        &lt;/View&gt;
      );
    },
    []
  );

  return (
    &lt;SectionList&lt;Setting, SettingsSection&gt;
      sections={SETTINGS}
      renderItem={renderItem}
      renderSectionHeader={renderSectionHeader}
      keyExtractor={(item) => item.id}
      ItemSeparatorComponent={() => &lt;View style={styles.separator} /&gt;}
      SectionSeparatorComponent={() => &lt;View style={styles.sectionGap} /&gt;}
      contentContainerStyle={styles.container}
    /&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#f2f2f7',
  },
  sectionHeader: {
    paddingHorizontal: 16,
    paddingTop: 24,
    paddingBottom: 8,
  },
  sectionTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: '#666',
    textTransform: 'uppercase',
  },
  settingRow: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  settingIcon: {
    fontSize: 20,
    marginRight: 12,
  },
  settingLabel: {
    flex: 1,
    fontSize: 16,
  },
  dangerLabel: {
    color: '#f44336',
  },
  chevron: {
    fontSize: 20,
    color: '#c7c7cc',
  },
  separator: {
    height: StyleSheet.hairlineWidth,
    backgroundColor: '#c6c6c8',
    marginLeft: 52,
  },
  sectionGap: {
    height: 8,
  },
});</code></pre>
            </section>
                <h3>Pattern 3: Events by Date</h3>

                <pre><code class="language-tsx">import React, { useMemo, useCallback } from 'react';
import { SectionList, View, Text, StyleSheet } from 'react-native';

interface CalendarEvent {
  id: string;
  title: string;
  time: string;
  location?: string;
  color: string;
}

interface EventSection {
  title: string;
  date: Date;
  data: CalendarEvent[];
}

// Group events by date
const groupEventsByDate = (events: CalendarEvent[]): EventSection[] => {
  // In a real app, events would have date objects
  // This is a simplified example
  return [
    {
      title: 'Today',
      date: new Date(),
      data: events.slice(0, 3),
    },
    {
      title: 'Tomorrow',
      date: new Date(Date.now() + 86400000),
      data: events.slice(3, 5),
    },
    {
      title: 'This Week',
      date: new Date(Date.now() + 172800000),
      data: events.slice(5),
    },
  ];
};

const EventCard = React.memo(({ event }: { event: CalendarEvent }) => (
  &lt;View style={styles.eventCard}&gt;
    &lt;View style={[styles.colorBar, { backgroundColor: event.color }]} /&gt;
    &lt;View style={styles.eventContent}&gt;
      &lt;Text style={styles.eventTime}&gt;{event.time}&lt;/Text&gt;
      &lt;Text style={styles.eventTitle}&gt;{event.title}&lt;/Text&gt;
      {event.location && (
        &lt;Text style={styles.eventLocation}&gt;üìç {event.location}&lt;/Text&gt;
      )}
    &lt;/View&gt;
  &lt;/View&gt;
));

export default function EventsCalendar() {
  const events: CalendarEvent[] = [
    { id: '1', title: 'Team Standup', time: '9:00 AM', location: 'Zoom', color: '#4CAF50' },
    { id: '2', title: 'Product Review', time: '11:00 AM', location: 'Room 3B', color: '#2196F3' },
    { id: '3', title: 'Lunch with Alex', time: '12:30 PM', location: 'Caf√© Luna', color: '#FF9800' },
    { id: '4', title: 'Client Call', time: '2:00 PM', color: '#f44336' },
    { id: '5', title: 'Sprint Planning', time: '4:00 PM', location: 'Main Office', color: '#9C27B0' },
    { id: '6', title: 'Dentist Appointment', time: '10:00 AM', location: 'Dr. Smith', color: '#607D8B' },
    { id: '7', title: 'Birthday Party', time: '6:00 PM', location: 'Tom\'s Place', color: '#E91E63' },
  ];

  const sections = useMemo(() => groupEventsByDate(events), [events]);

  const renderItem = useCallback(
    ({ item }: { item: CalendarEvent }) => &lt;EventCard event={item} /&gt;,
    []
  );

  const renderSectionHeader = useCallback(
    ({ section }: { section: EventSection }) => (
      &lt;View style={styles.dateHeader}&gt;
        &lt;Text style={styles.dateTitle}&gt;{section.title}&lt;/Text&gt;
        &lt;Text style={styles.dateSubtitle}&gt;
          {section.date.toLocaleDateString('en-US', { 
            weekday: 'long',
            month: 'short', 
            day: 'numeric' 
          })}
        &lt;/Text&gt;
      &lt;/View&gt;
    ),
    []
  );

  const renderSectionFooter = useCallback(
    ({ section }: { section: EventSection }) => (
      &lt;View style={styles.sectionFooter}&gt;
        &lt;Text style={styles.eventCount}&gt;
          {section.data.length} event{section.data.length !== 1 ? 's' : ''}
        &lt;/Text&gt;
      &lt;/View&gt;
    ),
    []
  );

  return (
    &lt;SectionList&lt;CalendarEvent, EventSection&gt;
      sections={sections}
      renderItem={renderItem}
      renderSectionHeader={renderSectionHeader}
      renderSectionFooter={renderSectionFooter}
      keyExtractor={(item) => item.id}
      stickySectionHeadersEnabled
      ItemSeparatorComponent={() => &lt;View style={{ height: 8 }} /&gt;}
      SectionSeparatorComponent={() => &lt;View style={{ height: 16 }} /&gt;}
      contentContainerStyle={styles.container}
    /&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#f5f5f5',
  },
  dateHeader: {
    backgroundColor: '#f5f5f5',
    paddingVertical: 8,
  },
  dateTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  dateSubtitle: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  eventCard: {
    flexDirection: 'row',
    backgroundColor: '#fff',
    borderRadius: 12,
    overflow: 'hidden',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  colorBar: {
    width: 4,
  },
  eventContent: {
    flex: 1,
    padding: 12,
  },
  eventTime: {
    fontSize: 13,
    fontWeight: '600',
    color: '#6200ee',
  },
  eventTitle: {
    fontSize: 16,
    fontWeight: '500',
    marginTop: 4,
  },
  eventLocation: {
    fontSize: 13,
    color: '#666',
    marginTop: 4,
  },
  sectionFooter: {
    paddingTop: 8,
    alignItems: 'flex-end',
  },
  eventCount: {
    fontSize: 12,
    color: '#999',
  },
});</code></pre>
            </section>

            <!-- Performance Considerations -->
            <section id="performance">
                <h2>Performance Considerations</h2>

                <p>SectionList inherits FlatList's virtualization, but there are some additional considerations for sectioned data.</p>

                <h3>getItemLayout with Sections</h3>

                <p>Unlike FlatList, implementing <code>getItemLayout</code> for SectionList is complex because you need to account for section headers:</p>

                <pre><code class="language-tsx">// Simple case: all items and headers have fixed heights
const HEADER_HEIGHT = 40;
const ITEM_HEIGHT = 60;

// This gets complicated with sections!
// You need to calculate the cumulative offset including all previous
// sections' headers and items

const getItemLayout = (
  data: SectionListData&lt;Item&gt;[] | null,
  index: number
) => {
  // For SectionList, the index is a "virtual" index across all items
  // This is complex to implement correctly
  
  // A helper function to calculate:
  let offset = 0;
  let itemIndex = 0;
  
  if (!data) {
    return { length: ITEM_HEIGHT, offset: 0, index };
  }
  
  for (const section of data) {
    // Add section header height
    offset += HEADER_HEIGHT;
    
    for (const item of section.data) {
      if (itemIndex === index) {
        return { length: ITEM_HEIGHT, offset, index };
      }
      offset += ITEM_HEIGHT;
      itemIndex++;
    }
  }
  
  return { length: ITEM_HEIGHT, offset, index };
};

// ‚ö†Ô∏è This is simplified - real implementation needs to handle
// separators, footers, and empty sections</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è getItemLayout Complexity</h4>
                    <p>Due to the complexity of calculating offsets with variable section sizes, many developers skip <code>getItemLayout</code> for SectionList unless performance is critical. Focus on other optimizations first:</p>
                    <ul>
                        <li>Memoize section data transformations</li>
                        <li>Use <code>React.memo</code> on item components</li>
                        <li>Memoize render functions with <code>useCallback</code></li>
                        <li>Keep section headers simple and lightweight</li>
                    </ul>
                </div>

                <h3>Memoizing Section Data</h3>

                <pre><code class="language-tsx">// ‚ùå Bad: Creates new sections array every render
function BadExample({ contacts }) {
  // This runs every render!
  const sections = groupContactsByLetter(contacts);
  
  return &lt;SectionList sections={sections} ... /&gt;;
}

// ‚úÖ Good: Memoize the transformation
function GoodExample({ contacts }) {
  const sections = useMemo(
    () => groupContactsByLetter(contacts),
    [contacts]  // Only recalculate when contacts change
  );
  
  return &lt;SectionList sections={sections} ... /&gt;;
}

// ‚úÖ Even better: Memoize deeply
function BetterExample({ contacts }) {
  // Memoize the grouping
  const sections = useMemo(
    () => groupContactsByLetter(contacts),
    [contacts]
  );
  
  // Memoize render functions
  const renderItem = useCallback(
    ({ item }) => &lt;ContactRow contact={item} /&gt;,
    []
  );
  
  const renderSectionHeader = useCallback(
    ({ section }) => &lt;SectionHeader title={section.title} /&gt;,
    []
  );
  
  // Memoize item component
  const ContactRow = memo(({ contact }) => (
    &lt;View&gt;&lt;Text&gt;{contact.name}&lt;/Text&gt;&lt;/View&gt;
  ));
  
  return (
    &lt;SectionList
      sections={sections}
      renderItem={renderItem}
      renderSectionHeader={renderSectionHeader}
      keyExtractor={keyExtractor}
    /&gt;
  );
}</code></pre>

                <h3>Performance Props</h3>

                <p>SectionList supports the same performance props as FlatList:</p>

                <pre><code class="language-tsx">&lt;SectionList
  sections={sections}
  renderItem={renderItem}
  renderSectionHeader={renderSectionHeader}
  
  // Virtualization tuning
  windowSize={11}
  maxToRenderPerBatch={10}
  initialNumToRender={10}
  updateCellsBatchingPeriod={50}
  
  // Remove off-screen views (Android)
  removeClippedSubviews={true}
  
  // Extra data for re-render triggers
  extraData={selectedId}
/&gt;</code></pre>

                <h3>Large Number of Sections</h3>

                <pre><code class="language-tsx">// If you have many sections (e.g., 26 alphabet sections),
// consider whether SectionList is the right choice

// Option 1: Flatten for very large datasets
// Use FlatList with inline headers in your data
const flattenedData = sections.flatMap(section => [
  { type: 'header', title: section.title },
  ...section.data.map(item => ({ type: 'item', ...item })),
]);

&lt;FlatList
  data={flattenedData}
  renderItem={({ item }) => {
    if (item.type === 'header') {
      return &lt;SectionHeader title={item.title} /&gt;;
    }
    return &lt;ItemRow item={item} /&gt;;
  }}
  getItemLayout={...}  // Easier to implement
/&gt;

// Option 2: Use FlashList (covered in next lesson)
// FlashList handles sections more efficiently</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ SectionList Performance Checklist</h4>
                    <ul>
                        <li>‚òê Memoize section data with <code>useMemo</code></li>
                        <li>‚òê Memoize <code>renderItem</code> and <code>renderSectionHeader</code> with <code>useCallback</code></li>
                        <li>‚òê Wrap item components with <code>React.memo</code></li>
                        <li>‚òê Keep section headers lightweight (minimal components)</li>
                        <li>‚òê Use <code>keyExtractor</code> with unique, stable keys</li>
                        <li>‚òê Consider <code>windowSize</code> tuning for very long lists</li>
                        <li>‚òê Avoid inline functions and styles</li>
                    </ul>
                </div>
            </section>

            <!-- Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <p>Practice building real-world sectioned lists.</p>

                <!-- Exercise 1 -->
                <div class="exercise-card">
                    <h4>Exercise 1: Music Library</h4>
                    <p>Build a music library with songs grouped by album.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Group songs by album</li>
                        <li>Section header shows album name and cover art</li>
                        <li>Each song shows title, artist, and duration</li>
                        <li>Sticky section headers</li>
                        <li>Section footer shows total album duration</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Create an <code>AlbumSection</code> interface with album metadata. Calculate total duration in the footer by summing song durations in <code>section.data</code>.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-tsx">import React, { useCallback } from 'react';
import { SectionList, View, Text, Image, StyleSheet } from 'react-native';

interface Song {
  id: string;
  title: string;
  artist: string;
  duration: number; // seconds
}

interface AlbumSection {
  title: string;
  artist: string;
  coverArt: string;
  year: number;
  data: Song[];
}

const formatDuration = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

const ALBUMS: AlbumSection[] = [
  {
    title: 'Abbey Road',
    artist: 'The Beatles',
    coverArt: 'https://picsum.photos/seed/album1/100',
    year: 1969,
    data: [
      { id: '1', title: 'Come Together', artist: 'The Beatles', duration: 259 },
      { id: '2', title: 'Something', artist: 'The Beatles', duration: 182 },
      { id: '3', title: 'Here Comes The Sun', artist: 'The Beatles', duration: 185 },
    ],
  },
  {
    title: 'Thriller',
    artist: 'Michael Jackson',
    coverArt: 'https://picsum.photos/seed/album2/100',
    year: 1982,
    data: [
      { id: '4', title: 'Wanna Be Startin\' Somethin\'', artist: 'Michael Jackson', duration: 363 },
      { id: '5', title: 'Thriller', artist: 'Michael Jackson', duration: 357 },
      { id: '6', title: 'Beat It', artist: 'Michael Jackson', duration: 258 },
      { id: '7', title: 'Billie Jean', artist: 'Michael Jackson', duration: 294 },
    ],
  },
  {
    title: 'Back in Black',
    artist: 'AC/DC',
    coverArt: 'https://picsum.photos/seed/album3/100',
    year: 1980,
    data: [
      { id: '8', title: 'Hells Bells', artist: 'AC/DC', duration: 312 },
      { id: '9', title: 'Back in Black', artist: 'AC/DC', duration: 255 },
      { id: '10', title: 'You Shook Me All Night Long', artist: 'AC/DC', duration: 210 },
    ],
  },
];

const SongRow = React.memo(({ song, index }: { song: Song; index: number }) => (
  &lt;View style={styles.songRow}&gt;
    &lt;Text style={styles.songNumber}&gt;{index + 1}&lt;/Text&gt;
    &lt;View style={styles.songInfo}&gt;
      &lt;Text style={styles.songTitle}&gt;{song.title}&lt;/Text&gt;
      &lt;Text style={styles.songArtist}&gt;{song.artist}&lt;/Text&gt;
    &lt;/View&gt;
    &lt;Text style={styles.songDuration}&gt;{formatDuration(song.duration)}&lt;/Text&gt;
  &lt;/View&gt;
));

export default function MusicLibrary() {
  const renderItem = useCallback(
    ({ item, index }: { item: Song; index: number }) => (
      &lt;SongRow song={item} index={index} /&gt;
    ),
    []
  );

  const renderSectionHeader = useCallback(
    ({ section }: { section: AlbumSection }) => (
      &lt;View style={styles.albumHeader}&gt;
        &lt;Image source={{ uri: section.coverArt }} style={styles.albumCover} /&gt;
        &lt;View style={styles.albumInfo}&gt;
          &lt;Text style={styles.albumTitle}&gt;{section.title}&lt;/Text&gt;
          &lt;Text style={styles.albumArtist}&gt;{section.artist}&lt;/Text&gt;
          &lt;Text style={styles.albumYear}&gt;{section.year}&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    ),
    []
  );

  const renderSectionFooter = useCallback(
    ({ section }: { section: AlbumSection }) => {
      const totalSeconds = section.data.reduce((sum, song) => sum + song.duration, 0);
      const mins = Math.floor(totalSeconds / 60);
      
      return (
        &lt;View style={styles.albumFooter}&gt;
          &lt;Text style={styles.footerText}&gt;
            {section.data.length} songs ¬∑ {mins} minutes
          &lt;/Text&gt;
        &lt;/View&gt;
      );
    },
    []
  );

  return (
    &lt;SectionList&lt;Song, AlbumSection&gt;
      sections={ALBUMS}
      renderItem={renderItem}
      renderSectionHeader={renderSectionHeader}
      renderSectionFooter={renderSectionFooter}
      keyExtractor={(item) => item.id}
      stickySectionHeadersEnabled
      ItemSeparatorComponent={() => &lt;View style={styles.separator} /&gt;}
      SectionSeparatorComponent={() => &lt;View style={styles.sectionGap} /&gt;}
      contentContainerStyle={styles.container}
    /&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#1a1a1a',
  },
  albumHeader: {
    flexDirection: 'row',
    padding: 16,
    backgroundColor: '#1a1a1a',
    alignItems: 'center',
  },
  albumCover: {
    width: 80,
    height: 80,
    borderRadius: 4,
  },
  albumInfo: {
    marginLeft: 16,
    flex: 1,
  },
  albumTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#fff',
  },
  albumArtist: {
    fontSize: 16,
    color: '#ccc',
    marginTop: 4,
  },
  albumYear: {
    fontSize: 14,
    color: '#888',
    marginTop: 2,
  },
  songRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    backgroundColor: '#1a1a1a',
  },
  songNumber: {
    width: 30,
    fontSize: 14,
    color: '#888',
  },
  songInfo: {
    flex: 1,
  },
  songTitle: {
    fontSize: 16,
    color: '#fff',
  },
  songArtist: {
    fontSize: 13,
    color: '#888',
    marginTop: 2,
  },
  songDuration: {
    fontSize: 14,
    color: '#888',
  },
  separator: {
    height: StyleSheet.hairlineWidth,
    backgroundColor: '#333',
    marginLeft: 46,
  },
  sectionGap: {
    height: 24,
  },
  albumFooter: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#1a1a1a',
  },
  footerText: {
    fontSize: 13,
    color: '#666',
  },
});</code></pre>
                    </details>
                </div>

                <!-- Exercise 2 -->
                <div class="exercise-card">
                    <h4>Exercise 2: FAQ Accordion</h4>
                    <p>Build an FAQ page with collapsible section categories.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>FAQ items grouped by category (Account, Billing, Technical)</li>
                        <li>Tap section header to collapse/expand that category</li>
                        <li>Tap FAQ item to expand/collapse the answer</li>
                        <li>Smooth visual feedback for expanded/collapsed states</li>
                        <li>Track expanded states for both sections and items</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use two pieces of state: <code>collapsedSections</code> (Set of collapsed section titles) and <code>expandedItems</code> (Set of expanded FAQ IDs). Filter section data based on collapsed state.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-tsx">import React, { useState, useCallback, useMemo } from 'react';
import { 
  SectionList, 
  View, 
  Text, 
  Pressable, 
  StyleSheet,
  LayoutAnimation,
  Platform,
  UIManager,
} from 'react-native';

// Enable LayoutAnimation on Android
if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

interface FAQItem {
  id: string;
  question: string;
  answer: string;
}

interface FAQSection {
  title: string;
  icon: string;
  data: FAQItem[];
}

const FAQ_DATA: FAQSection[] = [
  {
    title: 'Account',
    icon: 'üë§',
    data: [
      { id: '1', question: 'How do I reset my password?', answer: 'Go to Settings > Account > Change Password. Enter your current password, then create a new one.' },
      { id: '2', question: 'Can I change my username?', answer: 'Yes! Navigate to Settings > Profile > Edit Username. Note: You can only change it once every 30 days.' },
      { id: '3', question: 'How do I delete my account?', answer: 'Go to Settings > Account > Delete Account. Please note this action is permanent and cannot be undone.' },
    ],
  },
  {
    title: 'Billing',
    icon: 'üí≥',
    data: [
      { id: '4', question: 'What payment methods do you accept?', answer: 'We accept Visa, MasterCard, American Express, PayPal, and Apple Pay.' },
      { id: '5', question: 'How do I get a refund?', answer: 'Contact our support team within 14 days of purchase. Refunds are processed within 5-7 business days.' },
    ],
  },
  {
    title: 'Technical',
    icon: 'üîß',
    data: [
      { id: '6', question: 'The app is crashing. What should I do?', answer: 'Try these steps: 1) Force close and reopen the app, 2) Clear app cache, 3) Update to the latest version, 4) Reinstall the app.' },
      { id: '7', question: 'How do I enable notifications?', answer: 'Go to your device Settings > Notifications > [App Name] and toggle on Allow Notifications.' },
      { id: '8', question: 'Is my data synced across devices?', answer: 'Yes! As long as you\'re signed in with the same account, your data syncs automatically.' },
    ],
  },
];

const FAQItemRow = React.memo(({ 
  item, 
  isExpanded, 
  onToggle 
}: { 
  item: FAQItem; 
  isExpanded: boolean;
  onToggle: () => void;
}) => (
  &lt;Pressable style={styles.faqItem} onPress={onToggle}&gt;
    &lt;View style={styles.questionRow}&gt;
      &lt;Text style={styles.question}&gt;{item.question}&lt;/Text&gt;
      &lt;Text style={styles.expandIcon}&gt;{isExpanded ? '‚àí' : '+'}&lt;/Text&gt;
    &lt;/View&gt;
    {isExpanded && (
      &lt;Text style={styles.answer}&gt;{item.answer}&lt;/Text&gt;
    )}
  &lt;/Pressable&gt;
));

export default function FAQScreen() {
  const [collapsedSections, setCollapsedSections] = useState&lt;Set&lt;string&gt;&gt;(new Set());
  const [expandedItems, setExpandedItems] = useState&lt;Set&lt;string&gt;&gt;(new Set());

  const toggleSection = useCallback((title: string) => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setCollapsedSections(prev => {
      const next = new Set(prev);
      if (next.has(title)) {
        next.delete(title);
      } else {
        next.add(title);
      }
      return next;
    });
  }, []);

  const toggleItem = useCallback((id: string) => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setExpandedItems(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  }, []);

  // Filter out collapsed sections' data
  const sections = useMemo(() => 
    FAQ_DATA.map(section => ({
      ...section,
      data: collapsedSections.has(section.title) ? [] : section.data,
    })),
    [collapsedSections]
  );

  const renderItem = useCallback(
    ({ item }: { item: FAQItem }) => (
      &lt;FAQItemRow
        item={item}
        isExpanded={expandedItems.has(item.id)}
        onToggle={() => toggleItem(item.id)}
      /&gt;
    ),
    [expandedItems, toggleItem]
  );

  const renderSectionHeader = useCallback(
    ({ section }: { section: FAQSection }) => {
      const isCollapsed = collapsedSections.has(section.title);
      const originalSection = FAQ_DATA.find(s => s.title === section.title);
      const itemCount = originalSection?.data.length ?? 0;
      
      return (
        &lt;Pressable 
          style={styles.sectionHeader}
          onPress={() => toggleSection(section.title)}
        &gt;
          &lt;Text style={styles.sectionIcon}&gt;{section.icon}&lt;/Text&gt;
          &lt;View style={styles.sectionInfo}&gt;
            &lt;Text style={styles.sectionTitle}&gt;{section.title}&lt;/Text&gt;
            &lt;Text style={styles.sectionCount}&gt;{itemCount} questions&lt;/Text&gt;
          &lt;/View&gt;
          &lt;Text style={styles.collapseIcon}&gt;{isCollapsed ? '‚ñ∂' : '‚ñº'}&lt;/Text&gt;
        &lt;/Pressable&gt;
      );
    },
    [collapsedSections, toggleSection]
  );

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Frequently Asked Questions&lt;/Text&gt;
      &lt;SectionList&lt;FAQItem, FAQSection&gt;
        sections={sections}
        renderItem={renderItem}
        renderSectionHeader={renderSectionHeader}
        keyExtractor={(item) => item.id}
        stickySectionHeadersEnabled={false}
        ItemSeparatorComponent={() => &lt;View style={styles.separator} /&gt;}
        SectionSeparatorComponent={() => &lt;View style={styles.sectionGap} /&gt;}
        contentContainerStyle={styles.listContent}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    padding: 16,
    backgroundColor: '#fff',
  },
  listContent: {
    padding: 16,
  },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 12,
    marginBottom: 8,
  },
  sectionIcon: {
    fontSize: 24,
    marginRight: 12,
  },
  sectionInfo: {
    flex: 1,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  sectionCount: {
    fontSize: 13,
    color: '#666',
    marginTop: 2,
  },
  collapseIcon: {
    fontSize: 14,
    color: '#999',
  },
  faqItem: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
  },
  questionRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  question: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
    lineHeight: 22,
  },
  expandIcon: {
    fontSize: 20,
    color: '#6200ee',
    marginLeft: 12,
    fontWeight: 'bold',
  },
  answer: {
    fontSize: 14,
    color: '#666',
    lineHeight: 22,
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  separator: {
    height: 8,
  },
  sectionGap: {
    height: 16,
  },
});</code></pre>
                    </details>
                </div>
                <!-- Exercise 3 -->
                <div class="exercise-card">
                    <h4>Exercise 3: Shopping Cart</h4>
                    <p>Build a shopping cart grouped by store/seller.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Group cart items by store</li>
                        <li>Section header shows store name and logo</li>
                        <li>Each item shows product image, name, price, quantity controls</li>
                        <li>Section footer shows store subtotal</li>
                        <li>List footer shows grand total</li>
                        <li>Empty state when cart is empty</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Create a <code>StoreSection</code> with store metadata. Use <code>ListFooterComponent</code> for the grand total. Calculate subtotals in section footers.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-tsx">import React, { useState, useCallback, useMemo } from 'react';
import {
  SectionList,
  View,
  Text,
  Image,
  Pressable,
  StyleSheet,
} from 'react-native';

interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
  image: string;
}

interface StoreSection {
  storeId: string;
  storeName: string;
  storeLogo: string;
  data: CartItem[];
}

const INITIAL_CART: StoreSection[] = [
  {
    storeId: '1',
    storeName: 'TechStore',
    storeLogo: 'https://picsum.photos/seed/tech/40',
    data: [
      { id: '1', name: 'Wireless Earbuds', price: 79.99, quantity: 1, image: 'https://picsum.photos/seed/p1/80' },
      { id: '2', name: 'Phone Case', price: 19.99, quantity: 2, image: 'https://picsum.photos/seed/p2/80' },
    ],
  },
  {
    storeId: '2',
    storeName: 'Fashion Hub',
    storeLogo: 'https://picsum.photos/seed/fashion/40',
    data: [
      { id: '3', name: 'Cotton T-Shirt', price: 24.99, quantity: 3, image: 'https://picsum.photos/seed/p3/80' },
      { id: '4', name: 'Denim Jeans', price: 59.99, quantity: 1, image: 'https://picsum.photos/seed/p4/80' },
    ],
  },
  {
    storeId: '3',
    storeName: 'Home Essentials',
    storeLogo: 'https://picsum.photos/seed/home/40',
    data: [
      { id: '5', name: 'Scented Candle Set', price: 34.99, quantity: 1, image: 'https://picsum.photos/seed/p5/80' },
    ],
  },
];

const CartItemRow = React.memo(({
  item,
  onUpdateQuantity,
}: {
  item: CartItem;
  onUpdateQuantity: (id: string, delta: number) => void;
}) => (
  &lt;View style={styles.cartItem}&gt;
    &lt;Image source={{ uri: item.image }} style={styles.productImage} /&gt;
    &lt;View style={styles.productInfo}&gt;
      &lt;Text style={styles.productName}&gt;{item.name}&lt;/Text&gt;
      &lt;Text style={styles.productPrice}&gt;${item.price.toFixed(2)}&lt;/Text&gt;
    &lt;/View&gt;
    &lt;View style={styles.quantityControls}&gt;
      &lt;Pressable
        style={styles.qtyButton}
        onPress={() => onUpdateQuantity(item.id, -1)}
      &gt;
        &lt;Text style={styles.qtyButtonText}&gt;‚àí&lt;/Text&gt;
      &lt;/Pressable&gt;
      &lt;Text style={styles.quantity}&gt;{item.quantity}&lt;/Text&gt;
      &lt;Pressable
        style={styles.qtyButton}
        onPress={() => onUpdateQuantity(item.id, 1)}
      &gt;
        &lt;Text style={styles.qtyButtonText}&gt;+&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  &lt;/View&gt;
));

export default function ShoppingCart() {
  const [cart, setCart] = useState&lt;StoreSection[]&gt;(INITIAL_CART);

  const updateQuantity = useCallback((itemId: string, delta: number) => {
    setCart(prevCart =>
      prevCart.map(store => ({
        ...store,
        data: store.data
          .map(item =>
            item.id === itemId
              ? { ...item, quantity: Math.max(0, item.quantity + delta) }
              : item
          )
          .filter(item => item.quantity > 0),
      })).filter(store => store.data.length > 0)
    );
  }, []);

  const grandTotal = useMemo(() =>
    cart.reduce(
      (total, store) =>
        total + store.data.reduce((sum, item) => sum + item.price * item.quantity, 0),
      0
    ),
    [cart]
  );

  const renderItem = useCallback(
    ({ item }: { item: CartItem }) => (
      &lt;CartItemRow item={item} onUpdateQuantity={updateQuantity} /&gt;
    ),
    [updateQuantity]
  );

  const renderSectionHeader = useCallback(
    ({ section }: { section: StoreSection }) => (
      &lt;View style={styles.storeHeader}&gt;
        &lt;Image source={{ uri: section.storeLogo }} style={styles.storeLogo} /&gt;
        &lt;Text style={styles.storeName}&gt;{section.storeName}&lt;/Text&gt;
      &lt;/View&gt;
    ),
    []
  );

  const renderSectionFooter = useCallback(
    ({ section }: { section: StoreSection }) => {
      const subtotal = section.data.reduce(
        (sum, item) => sum + item.price * item.quantity,
        0
      );
      return (
        &lt;View style={styles.storeFooter}&gt;
          &lt;Text style={styles.subtotalLabel}&gt;Store Subtotal:&lt;/Text&gt;
          &lt;Text style={styles.subtotalValue}&gt;${subtotal.toFixed(2)}&lt;/Text&gt;
        &lt;/View&gt;
      );
    },
    []
  );

  const ListFooter = useMemo(() => (
    &lt;View style={styles.grandTotalContainer}&gt;
      &lt;View style={styles.grandTotalRow}&gt;
        &lt;Text style={styles.grandTotalLabel}&gt;Grand Total&lt;/Text&gt;
        &lt;Text style={styles.grandTotalValue}&gt;${grandTotal.toFixed(2)}&lt;/Text&gt;
      &lt;/View&gt;
      &lt;Pressable style={styles.checkoutButton}&gt;
        &lt;Text style={styles.checkoutText}&gt;Proceed to Checkout&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  ), [grandTotal]);

  const EmptyCart = useMemo(() => (
    &lt;View style={styles.emptyContainer}&gt;
      &lt;Text style={styles.emptyIcon}&gt;üõí&lt;/Text&gt;
      &lt;Text style={styles.emptyTitle}&gt;Your cart is empty&lt;/Text&gt;
      &lt;Text style={styles.emptySubtitle}&gt;Add items to get started!&lt;/Text&gt;
    &lt;/View&gt;
  ), []);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Shopping Cart&lt;/Text&gt;
      &lt;SectionList&lt;CartItem, StoreSection&gt;
        sections={cart}
        renderItem={renderItem}
        renderSectionHeader={renderSectionHeader}
        renderSectionFooter={renderSectionFooter}
        keyExtractor={(item) => item.id}
        ListFooterComponent={cart.length > 0 ? ListFooter : null}
        ListEmptyComponent={EmptyCart}
        ItemSeparatorComponent={() => &lt;View style={styles.itemSeparator} /&gt;}
        SectionSeparatorComponent={() => &lt;View style={styles.sectionSeparator} /&gt;}
        contentContainerStyle={styles.listContent}
        stickySectionHeadersEnabled
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    padding: 16,
    backgroundColor: '#fff',
  },
  listContent: {
    flexGrow: 1,
  },
  storeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  storeLogo: {
    width: 32,
    height: 32,
    borderRadius: 16,
    marginRight: 10,
  },
  storeName: {
    fontSize: 16,
    fontWeight: '600',
  },
  cartItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 12,
  },
  productImage: {
    width: 60,
    height: 60,
    borderRadius: 8,
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
  },
  productName: {
    fontSize: 15,
    fontWeight: '500',
  },
  productPrice: {
    fontSize: 15,
    color: '#6200ee',
    fontWeight: '600',
    marginTop: 4,
  },
  quantityControls: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  qtyButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
  },
  qtyButtonText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  quantity: {
    fontSize: 16,
    fontWeight: '600',
    marginHorizontal: 12,
    minWidth: 24,
    textAlign: 'center',
  },
  storeFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    backgroundColor: '#fafafa',
    padding: 12,
  },
  subtotalLabel: {
    fontSize: 14,
    color: '#666',
  },
  subtotalValue: {
    fontSize: 14,
    fontWeight: '600',
  },
  itemSeparator: {
    height: 1,
    backgroundColor: '#eee',
    marginLeft: 84,
  },
  sectionSeparator: {
    height: 16,
  },
  grandTotalContainer: {
    padding: 16,
    backgroundColor: '#fff',
    marginTop: 16,
  },
  grandTotalRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  grandTotalLabel: {
    fontSize: 18,
    fontWeight: '600',
  },
  grandTotalValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#6200ee',
  },
  checkoutButton: {
    backgroundColor: '#6200ee',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  checkoutText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyIcon: {
    fontSize: 64,
    marginBottom: 16,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 8,
  },
  emptySubtitle: {
    fontSize: 16,
    color: '#666',
  },
});</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>You've mastered SectionList‚Äîthe essential component for rendering grouped data with section headers in React Native.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéØ Key Takeaways</h4>
                    <ul>
                        <li><strong>Section structure:</strong> Each section needs a <code>data</code> array plus any custom properties</li>
                        <li><strong>renderSectionHeader:</strong> Receives the full section object for rendering headers</li>
                        <li><strong>Sticky headers:</strong> Use <code>stickySectionHeadersEnabled</code> for headers that stay visible</li>
                        <li><strong>Separators:</strong> <code>ItemSeparatorComponent</code> for items, <code>SectionSeparatorComponent</code> for sections</li>
                        <li><strong>TypeScript:</strong> Use <code>&lt;SectionList&lt;ItemType, SectionType&gt;</code> for type safety</li>
                        <li><strong>Performance:</strong> Memoize section data transformations and render functions</li>
                        <li><strong>Use cases:</strong> Contacts, settings, calendars, shopping carts, FAQs</li>
                    </ul>
                </div>

                <h3>SectionList vs FlatList Quick Reference</h3>

                <pre class="mermaid">
flowchart TD
    A["Do you have grouped data?"] -->|"Yes"| B["Need section headers?"]
    A -->|"No"| C["Use FlatList"]
    
    B -->|"Yes"| D["Need sticky headers?"]
    B -->|"No"| C
    
    D -->|"Yes"| E["Use SectionList<br/>stickySectionHeadersEnabled"]
    D -->|"No"| F["Use SectionList<br/>or FlatList with<br/>inline headers"]
    
    style C fill:#bbdefb
    style E fill:#c8e6c9
    style F fill:#fff3cd
                </pre>

                <h3>SectionList Props Cheat Sheet</h3>

                <div class="card">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                        <thead>
                            <tr style="background: #f5f5f5;">
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Prop</th>
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>sections</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Array of section objects with <code>data</code> arrays</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>renderItem</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Renders each item (receives section info)</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>renderSectionHeader</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Renders section header</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>renderSectionFooter</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Renders section footer</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>stickySectionHeadersEnabled</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Makes section headers sticky</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>ItemSeparatorComponent</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Separator between items in a section</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><code>SectionSeparatorComponent</code></td>
                                <td style="padding: 8px;">Separator between sections</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üöÄ What's Next?</h4>
                    <p style="color: white;">You now know both FlatList and SectionList inside out! The next lesson introduces <strong>FlashList</strong>‚ÄîShopify's high-performance list component that's up to 10x faster than FlatList. You'll learn when and how to use FlashList for the ultimate list performance in demanding applications.</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m05_l04_flatlist_features.html" class="prev-link">
                    <span class="arrow">‚Üê</span>
                    <div class="nav-content">
                        <span class="nav-label">Previous</span>
                        <span class="nav-title">FlatList Features</span>
                    </div>
                </a>
                
                <a href="index.html" class="home-link" title="Back to Course Home">
                    üè†
                </a>
                
                <a href="m05_l06_flashlist_for_maximum_performance.html" class="next-link">
                    <div class="nav-content">
                        <span class="nav-label">Next</span>
                        <span class="nav-title">FlashList for Maximum Performance</span>
                    </div>
                    <span class="arrow">‚Üí</span>
                </a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">Modules</a> |
                <a href="index.html#appendices">Appendices</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/course-enhancements.js"></script>
</body>
</html>
