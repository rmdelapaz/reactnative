<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master forms in React Native with React Hook Form, Zod validation, and proper keyboard handling for a smooth user experience">
    <meta name="author" content="React Native & Expo Course">
    <title>Forms and Validation | Module 7: Data Management and Networking | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m07_l01_fetching_data.html">Module 7</a> &gt;
            <span>Lesson 7.5</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 7: Data Management and Networking</p>
                <h1>Forms and Validation</h1>
                <p class="lesson-subtitle">Building robust, user-friendly forms in React Native</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Understand controlled vs uncontrolled form patterns in React Native</li>
                    <li>Implement forms efficiently with React Hook Form</li>
                    <li>Define validation schemas with Zod</li>
                    <li>Display validation errors clearly to users</li>
                    <li>Handle keyboard interactions and input focus properly</li>
                    <li>Build reusable form components</li>
                    <li>Implement common patterns: login, registration, and multi-step forms</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#form-challenges">Form Challenges in React Native</a></li>
                        <li><a href="#controlled-forms">Controlled Forms: The Basic Approach</a></li>
                        <li><a href="#react-hook-form">React Hook Form: The Better Way</a></li>
                        <li><a href="#zod-validation">Zod: Type-Safe Validation</a></li>
                        <li><a href="#error-display">Displaying Validation Errors</a></li>
                        <li><a href="#keyboard-handling">Keyboard Handling</a></li>
                        <li><a href="#reusable-components">Building Reusable Form Components</a></li>
                        <li><a href="#real-world-forms">Real-World Form Examples</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- Form Challenges -->
            <section id="form-challenges">
                <h2>Form Challenges in React Native</h2>

                <p>Forms in React Native come with unique challenges that don't exist on the web. Understanding these challenges will help you build better user experiences.</p>

                <div class="card">
                    <h4>üì± Mobile Form Challenges</h4>
                    <ul>
                        <li><strong>Keyboard covers input:</strong> The soft keyboard can hide the field being edited</li>
                        <li><strong>No HTML form element:</strong> No native form submission, validation, or autocomplete</li>
                        <li><strong>Focus management:</strong> Moving between inputs requires manual handling</li>
                        <li><strong>Different keyboards:</strong> Need to specify keyboard type for each input</li>
                        <li><strong>Dismissing keyboard:</strong> Users need a way to hide the keyboard</li>
                        <li><strong>Performance:</strong> Many inputs can cause re-render performance issues</li>
                    </ul>
                </div>

                <!-- SVG: Form Challenges -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 300" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="300" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="350" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">The Keyboard Problem</text>
                        
                        <!-- Phone 1: Without handling -->
                        <rect x="80" y="50" width="150" height="220" fill="#fff" stroke="#333" stroke-width="2" rx="15"/>
                        <rect x="130" y="55" width="50" height="8" fill="#333" rx="3"/>
                        <rect x="90" y="75" width="130" height="180" fill="#f5f5f5"/>
                        
                        <!-- Form fields -->
                        <rect x="100" y="85" width="110" height="25" fill="#fff" stroke="#ddd" stroke-width="1" rx="4"/>
                        <text x="110" y="102" font-size="8" fill="#999">Email</text>
                        
                        <rect x="100" y="120" width="110" height="25" fill="#fff" stroke="#ddd" stroke-width="1" rx="4"/>
                        <text x="110" y="137" font-size="8" fill="#999">Password</text>
                        
                        <!-- Active field (hidden by keyboard) -->
                        <rect x="100" y="155" width="110" height="25" fill="#e3f2fd" stroke="#2196F3" stroke-width="2" rx="4"/>
                        <text x="110" y="172" font-size="8" fill="#333">Bio...</text>
                        
                        <!-- Keyboard covering -->
                        <rect x="90" y="175" width="130" height="80" fill="#e0e0e0" stroke="#bdbdbd" stroke-width="1"/>
                        <text x="155" y="205" text-anchor="middle" font-size="8" fill="#666">‚å®Ô∏è Keyboard</text>
                        <text x="155" y="220" text-anchor="middle" font-size="8" fill="#666">(covers input!)</text>
                        
                        <!-- X mark -->
                        <circle cx="155" cy="280" r="15" fill="#ffebee" stroke="#f44336" stroke-width="2"/>
                        <text x="155" y="285" text-anchor="middle" font-size="14" fill="#f44336">‚úó</text>
                        
                        <text x="155" y="45" text-anchor="middle" font-size="10" fill="#c62828">Without KeyboardAvoidingView</text>
                        
                        <!-- Phone 2: With handling -->
                        <rect x="470" y="50" width="150" height="220" fill="#fff" stroke="#333" stroke-width="2" rx="15"/>
                        <rect x="520" y="55" width="50" height="8" fill="#333" rx="3"/>
                        <rect x="480" y="75" width="130" height="180" fill="#f5f5f5"/>
                        
                        <!-- Scrolled form fields -->
                        <rect x="490" y="80" width="110" height="25" fill="#fff" stroke="#ddd" stroke-width="1" rx="4"/>
                        <text x="500" y="97" font-size="8" fill="#999">Email</text>
                        
                        <rect x="490" y="110" width="110" height="25" fill="#fff" stroke="#ddd" stroke-width="1" rx="4"/>
                        <text x="500" y="127" font-size="8" fill="#999">Password</text>
                        
                        <!-- Active field (visible!) -->
                        <rect x="490" y="140" width="110" height="25" fill="#e3f2fd" stroke="#2196F3" stroke-width="2" rx="4"/>
                        <text x="500" y="157" font-size="8" fill="#333">Bio...</text>
                        
                        <!-- Keyboard (not covering) -->
                        <rect x="480" y="175" width="130" height="80" fill="#e0e0e0" stroke="#bdbdbd" stroke-width="1"/>
                        <text x="545" y="205" text-anchor="middle" font-size="8" fill="#666">‚å®Ô∏è Keyboard</text>
                        <text x="545" y="220" text-anchor="middle" font-size="8" fill="#666">(input visible!)</text>
                        
                        <!-- Check mark -->
                        <circle cx="545" cy="280" r="15" fill="#e8f5e9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="545" y="285" text-anchor="middle" font-size="14" fill="#4CAF50">‚úì</text>
                        
                        <text x="545" y="45" text-anchor="middle" font-size="10" fill="#2e7d32">With KeyboardAvoidingView</text>
                        
                        <!-- Arrow -->
                        <path d="M280,160 L420,160" stroke="#667eea" stroke-width="3" marker-end="url(#arrowPurple)"/>
                        <text x="350" y="150" text-anchor="middle" font-size="10" fill="#667eea">Fix it!</text>
                        
                        <defs>
                            <marker id="arrowPurple" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#667eea"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
            </section>

            <!-- Controlled Forms -->
            <section id="controlled-forms">
                <h2>Controlled Forms: The Basic Approach</h2>

                <p>Before we introduce libraries, let's understand the controlled form pattern‚Äîwhere React state drives the form values.</p>

                <pre><code>import { useState } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  Pressable, 
  StyleSheet,
  Alert 
} from 'react-native';

interface FormData {
  email: string;
  password: string;
}

interface FormErrors {
  email?: string;
  password?: string;
}

export default function BasicLoginForm() {
  const [formData, setFormData] = useState&lt;FormData&gt;({
    email: '',
    password: '',
  });
  const [errors, setErrors] = useState&lt;FormErrors&gt;({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Update a single field
  const handleChange = (field: keyof FormData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };

  // Validate all fields
  const validate = (): boolean => {
    const newErrors: FormErrors = {};

    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Invalid email format';
    }

    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle submission
  const handleSubmit = async () => {
    if (!validate()) return;

    setIsSubmitting(true);
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      Alert.alert('Success', 'Logged in successfully!');
    } catch (error) {
      Alert.alert('Error', 'Login failed');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.field}&gt;
        &lt;Text style={styles.label}&gt;Email&lt;/Text&gt;
        &lt;TextInput
          style={[styles.input, errors.email && styles.inputError]}
          value={formData.email}
          onChangeText={(value) => handleChange('email', value)}
          placeholder="your@email.com"
          keyboardType="email-address"
          autoCapitalize="none"
          autoCorrect={false}
        /&gt;
        {errors.email && (
          &lt;Text style={styles.errorText}&gt;{errors.email}&lt;/Text&gt;
        )}
      &lt;/View&gt;

      &lt;View style={styles.field}&gt;
        &lt;Text style={styles.label}&gt;Password&lt;/Text&gt;
        &lt;TextInput
          style={[styles.input, errors.password && styles.inputError]}
          value={formData.password}
          onChangeText={(value) => handleChange('password', value)}
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          secureTextEntry
        /&gt;
        {errors.password && (
          &lt;Text style={styles.errorText}&gt;{errors.password}&lt;/Text&gt;
        )}
      &lt;/View&gt;

      &lt;Pressable
        style={[styles.button, isSubmitting && styles.buttonDisabled]}
        onPress={handleSubmit}
        disabled={isSubmitting}
      &gt;
        &lt;Text style={styles.buttonText}&gt;
          {isSubmitting ? 'Logging in...' : 'Log In'}
        &lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  field: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 6,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  inputError: {
    borderColor: '#f44336',
  },
  errorText: {
    color: '#f44336',
    fontSize: 12,
    marginTop: 4,
  },
  button: {
    backgroundColor: '#667eea',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 8,
  },
  buttonDisabled: {
    backgroundColor: '#bbb',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Problems with This Approach</h4>
                    <ul>
                        <li><strong>Boilerplate:</strong> Every form needs the same state, validation, and error handling code</li>
                        <li><strong>Re-renders:</strong> Every keystroke re-renders the entire form</li>
                        <li><strong>Validation logic:</strong> Grows complex and hard to maintain</li>
                        <li><strong>Type safety:</strong> Manual typing of errors and validation</li>
                    </ul>
                    <p>This is why we use <strong>React Hook Form</strong> and <strong>Zod</strong>.</p>
                </div>
            </section>

            <!-- React Hook Form -->
            <section id="react-hook-form">
                <h2>React Hook Form: The Better Way</h2>

                <p>React Hook Form minimizes re-renders by using uncontrolled inputs with refs under the hood, while still giving you the familiar controlled component API. It's the most popular form library for React and works great in React Native.</p>

                <h3>Installation</h3>

                <pre><code>npx expo install react-hook-form</code></pre>

                <h3>Basic Usage</h3>

                <pre><code>import { useForm, Controller } from 'react-hook-form';
import { View, Text, TextInput, Pressable, StyleSheet } from 'react-native';

interface LoginFormData {
  email: string;
  password: string;
}

export default function LoginForm() {
  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm&lt;LoginFormData&gt;({
    defaultValues: {
      email: '',
      password: '',
    },
  });

  const onSubmit = async (data: LoginFormData) => {
    console.log('Form data:', data);
    // Handle login...
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;Controller
        control={control}
        name="email"
        rules={{
          required: 'Email is required',
          pattern: {
            value: /\S+@\S+\.\S+/,
            message: 'Invalid email format',
          },
        }}
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Email&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.email && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              placeholder="your@email.com"
              keyboardType="email-address"
              autoCapitalize="none"
            /&gt;
            {errors.email && (
              &lt;Text style={styles.errorText}&gt;{errors.email.message}&lt;/Text&gt;
            )}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Controller
        control={control}
        name="password"
        rules={{
          required: 'Password is required',
          minLength: {
            value: 8,
            message: 'Password must be at least 8 characters',
          },
        }}
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Password&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.password && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
              secureTextEntry
            /&gt;
            {errors.password && (
              &lt;Text style={styles.errorText}&gt;{errors.password.message}&lt;/Text&gt;
            )}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Pressable
        style={[styles.button, isSubmitting && styles.buttonDisabled]}
        onPress={handleSubmit(onSubmit)}
        disabled={isSubmitting}
      &gt;
        &lt;Text style={styles.buttonText}&gt;
          {isSubmitting ? 'Logging in...' : 'Log In'}
        &lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Understanding Controller</h3>

                <p>Unlike web React where you can use <code>register</code> directly on inputs, React Native requires the <code>Controller</code> component because TextInput doesn't support refs the same way HTML inputs do.</p>

                <pre class="mermaid">
flowchart LR
    A[Controller] --> B[Manages field state]
    A --> C[Tracks validation]
    A --> D[Handles onChange/onBlur]
    
    B --> E[render prop]
    C --> E
    D --> E
    
    E --> F[Your TextInput]
    
    style A fill:#667eea,color:#fff
    style F fill:#e3f2fd,stroke:#2196F3
                </pre>

                <h3>Useful Form State</h3>

                <pre><code>const {
  control,
  handleSubmit,
  watch,           // Watch field values
  setValue,        // Programmatically set values
  reset,           // Reset form to defaults
  getValues,       // Get current values
  trigger,         // Trigger validation manually
  formState: {
    errors,        // Validation errors
    isSubmitting,  // Form is being submitted
    isValid,       // All fields are valid
    isDirty,       // Form has been modified
    dirtyFields,   // Which fields were modified
    touchedFields, // Which fields were touched
  },
} = useForm&lt;FormData&gt;();</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ React Hook Form Benefits</h4>
                    <ul>
                        <li><strong>Minimal re-renders:</strong> Only the field being edited re-renders</li>
                        <li><strong>Built-in validation:</strong> Required, min, max, pattern, custom</li>
                        <li><strong>Great DX:</strong> TypeScript support, DevTools extension</li>
                        <li><strong>Tiny:</strong> ~9KB gzipped with no dependencies</li>
                        <li><strong>Easy integration:</strong> Works with any UI library</li>
                    </ul>
                </div>
            </section>

            <!-- Zod Validation -->
            <section id="zod-validation">
                <h2>Zod: Type-Safe Validation</h2>

                <p>While React Hook Form's built-in validation is fine for simple forms, complex validation benefits from a dedicated schema library. Zod provides type-safe schemas that work beautifully with TypeScript.</p>

                <h3>Installation</h3>

                <pre><code>npx expo install zod @hookform/resolvers</code></pre>

                <h3>Creating a Schema</h3>

                <pre><code>import { z } from 'zod';

// Define your schema
const loginSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .email('Invalid email format'),
  password: z
    .string()
    .min(1, 'Password is required')
    .min(8, 'Password must be at least 8 characters'),
});

// TypeScript type is automatically inferred!
type LoginFormData = z.infer&lt;typeof loginSchema&gt;;
// Equivalent to:
// type LoginFormData = {
//   email: string;
//   password: string;
// }</code></pre>

                <h3>Integration with React Hook Form</h3>

                <pre><code>import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const loginSchema = z.object({
  email: z.string().min(1, 'Email is required').email('Invalid email'),
  password: z.string().min(1, 'Password is required').min(8, 'Min 8 characters'),
});

type LoginFormData = z.infer&lt;typeof loginSchema&gt;;

export default function LoginForm() {
  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm&lt;LoginFormData&gt;({
    resolver: zodResolver(loginSchema),  // Use Zod for validation!
    defaultValues: {
      email: '',
      password: '',
    },
  });

  // ... rest of form
}</code></pre>

                <h3>Advanced Zod Schemas</h3>

                <pre><code>import { z } from 'zod';

// Registration form with complex validation
const registrationSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .email('Invalid email format'),
  
  password: z
    .string()
    .min(1, 'Password is required')
    .min(8, 'At least 8 characters')
    .regex(/[A-Z]/, 'Must contain uppercase letter')
    .regex(/[a-z]/, 'Must contain lowercase letter')
    .regex(/[0-9]/, 'Must contain a number'),
  
  confirmPassword: z
    .string()
    .min(1, 'Please confirm your password'),
  
  username: z
    .string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be at most 20 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Only letters, numbers, and underscores'),
  
  age: z
    .number({ invalid_type_error: 'Age must be a number' })
    .int('Age must be a whole number')
    .min(13, 'Must be at least 13 years old')
    .max(120, 'Invalid age'),
  
  website: z
    .string()
    .url('Invalid URL')
    .optional()
    .or(z.literal('')),  // Allow empty string
  
  terms: z
    .boolean()
    .refine(val => val === true, 'You must accept the terms'),
})
// Cross-field validation
.refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'],  // Show error on confirmPassword field
});

type RegistrationFormData = z.infer&lt;typeof registrationSchema&gt;;</code></pre>

                <h3>Async Validation</h3>

                <pre><code>// Check if username is available (async validation)
const usernameSchema = z
  .string()
  .min(3, 'Username must be at least 3 characters')
  .refine(
    async (username) => {
      // Call API to check availability
      const response = await fetch(`/api/check-username?u=${username}`);
      const { available } = await response.json();
      return available;
    },
    { message: 'Username is already taken' }
  );

// Use with mode: 'onBlur' to avoid checking on every keystroke
const { control } = useForm({
  resolver: zodResolver(schema),
  mode: 'onBlur',  // Validate on blur instead of onChange
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why Zod over React Hook Form Rules?</h4>
                    <ul>
                        <li><strong>Type inference:</strong> Schema automatically generates TypeScript types</li>
                        <li><strong>Reusable:</strong> Same schema can validate API responses, not just forms</li>
                        <li><strong>Composable:</strong> Build complex schemas from simple ones</li>
                        <li><strong>Cross-field validation:</strong> Easy password confirmation, date ranges, etc.</li>
                        <li><strong>Transform data:</strong> Coerce strings to numbers, trim whitespace, etc.</li>
                    </ul>
                </div>
            </section>

            <!-- Displaying Validation Errors -->
            <section id="error-display">
                <h2>Displaying Validation Errors</h2>

                <p>Good error messages help users fix problems quickly. Here's how to display them effectively:</p>

                <h3>Inline Errors</h3>

                <pre><code>// Simple inline error
{errors.email && (
  &lt;Text style={styles.errorText}&gt;{errors.email.message}&lt;/Text&gt;
)}

// Animated error with react-native-reanimated
import Animated, { FadeIn, FadeOut } from 'react-native-reanimated';

{errors.email && (
  &lt;Animated.Text
    entering={FadeIn.duration(200)}
    exiting={FadeOut.duration(200)}
    style={styles.errorText}
  &gt;
    {errors.email.message}
  &lt;/Animated.Text&gt;
)}</code></pre>

                <h3>Error Summary</h3>

                <pre><code>// Show all errors at the top of the form
function ErrorSummary({ errors }: { errors: FieldErrors }) {
  const errorMessages = Object.values(errors)
    .map(error => error?.message)
    .filter(Boolean);

  if (errorMessages.length === 0) return null;

  return (
    &lt;View style={styles.errorSummary}&gt;
      &lt;Text style={styles.errorTitle}&gt;Please fix the following:&lt;/Text&gt;
      {errorMessages.map((message, index) => (
        &lt;Text key={index} style={styles.errorItem}&gt;‚Ä¢ {message}&lt;/Text&gt;
      ))}
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Input with Error State</h3>

                <pre><code>interface FormInputProps {
  label: string;
  error?: string;
  // ... other TextInput props
}

function FormInput({ label, error, ...props }: FormInputProps) {
  return (
    &lt;View style={styles.field}&gt;
      &lt;Text style={styles.label}&gt;{label}&lt;/Text&gt;
      &lt;TextInput
        style={[
          styles.input,
          error && styles.inputError,
          props.editable === false && styles.inputDisabled,
        ]}
        placeholderTextColor="#999"
        {...props}
      /&gt;
      {error && (
        &lt;View style={styles.errorContainer}&gt;
          &lt;Text style={styles.errorIcon}&gt;‚ö†Ô∏è&lt;/Text&gt;
          &lt;Text style={styles.errorText}&gt;{error}&lt;/Text&gt;
        &lt;/View&gt;
      )}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  field: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 6,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  inputError: {
    borderColor: '#f44336',
    borderWidth: 2,
  },
  inputDisabled: {
    backgroundColor: '#f5f5f5',
    color: '#999',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  errorIcon: {
    marginRight: 4,
  },
  errorText: {
    color: '#f44336',
    fontSize: 12,
  },
});</code></pre>
            </section>

            <!-- Keyboard Handling -->
            <section id="keyboard-handling">
                <h2>Keyboard Handling</h2>

                <p>Proper keyboard handling is crucial for a good form experience on mobile. Let's cover the essential patterns.</p>

                <h3>KeyboardAvoidingView</h3>

                <pre><code>import { 
  KeyboardAvoidingView, 
  Platform, 
  ScrollView 
} from 'react-native';

function FormScreen() {
  return (
    &lt;KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    &gt;
      &lt;ScrollView contentContainerStyle={styles.container}&gt;
        {/* Form fields */}
      &lt;/ScrollView&gt;
    &lt;/KeyboardAvoidingView&gt;
  );
}</code></pre>

                <h3>Dismissing the Keyboard</h3>

                <pre><code>import { 
  Keyboard, 
  TouchableWithoutFeedback, 
  View 
} from 'react-native';

// Dismiss keyboard when tapping outside inputs
function DismissKeyboard({ children }: { children: React.ReactNode }) {
  return (
    &lt;TouchableWithoutFeedback onPress={Keyboard.dismiss}&gt;
      &lt;View style={{ flex: 1 }}&gt;{children}&lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  );
}

// Usage
&lt;DismissKeyboard&gt;
  &lt;KeyboardAvoidingView ...&gt;
    {/* Form */}
  &lt;/KeyboardAvoidingView&gt;
&lt;/DismissKeyboard&gt;</code></pre>

                <h3>Moving Between Fields</h3>

                <pre><code>import { useRef } from 'react';
import { TextInput } from 'react-native';

function MultiFieldForm() {
  const emailRef = useRef&lt;TextInput&gt;(null);
  const passwordRef = useRef&lt;TextInput&gt;(null);
  const confirmRef = useRef&lt;TextInput&gt;(null);

  return (
    &lt;View&gt;
      &lt;TextInput
        ref={emailRef}
        placeholder="Email"
        returnKeyType="next"
        onSubmitEditing={() => passwordRef.current?.focus()}
        blurOnSubmit={false}
      /&gt;

      &lt;TextInput
        ref={passwordRef}
        placeholder="Password"
        secureTextEntry
        returnKeyType="next"
        onSubmitEditing={() => confirmRef.current?.focus()}
        blurOnSubmit={false}
      /&gt;

      &lt;TextInput
        ref={confirmRef}
        placeholder="Confirm Password"
        secureTextEntry
        returnKeyType="done"
        onSubmitEditing={handleSubmit}  // Submit on done
      /&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Complete Form with All Keyboard Handling</h3>

                <pre><code>import { useRef } from 'react';
import { useForm, Controller } from 'react-hook-form';
import {
  View,
  Text,
  TextInput,
  KeyboardAvoidingView,
  ScrollView,
  TouchableWithoutFeedback,
  Keyboard,
  Platform,
  Pressable,
  StyleSheet,
} from 'react-native';

export default function CompleteForm() {
  const passwordRef = useRef&lt;TextInput&gt;(null);
  
  const { control, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = (data: any) => {
    Keyboard.dismiss();
    console.log(data);
  };

  return (
    &lt;TouchableWithoutFeedback onPress={Keyboard.dismiss}&gt;
      &lt;KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      &gt;
        &lt;ScrollView
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
        &gt;
          &lt;Controller
            control={control}
            name="email"
            rules={{ required: 'Email required' }}
            render={({ field: { onChange, onBlur, value } }) =&gt; (
              &lt;TextInput
                style={styles.input}
                placeholder="Email"
                onBlur={onBlur}
                onChangeText={onChange}
                value={value}
                keyboardType="email-address"
                autoCapitalize="none"
                returnKeyType="next"
                onSubmitEditing={() => passwordRef.current?.focus()}
                blurOnSubmit={false}
              /&gt;
            )}
          /&gt;

          &lt;Controller
            control={control}
            name="password"
            rules={{ required: 'Password required' }}
            render={({ field: { onChange, onBlur, value } }) =&gt; (
              &lt;TextInput
                ref={passwordRef}
                style={styles.input}
                placeholder="Password"
                onBlur={onBlur}
                onChangeText={onChange}
                value={value}
                secureTextEntry
                returnKeyType="done"
                onSubmitEditing={handleSubmit(onSubmit)}
              /&gt;
            )}
          /&gt;

          &lt;Pressable style={styles.button} onPress={handleSubmit(onSubmit)}&gt;
            &lt;Text style={styles.buttonText}&gt;Submit&lt;/Text&gt;
          &lt;/Pressable&gt;
        &lt;/ScrollView&gt;
      &lt;/KeyboardAvoidingView&gt;
    &lt;/TouchableWithoutFeedback&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è keyboardShouldPersistTaps</h4>
                    <p>Set <code>keyboardShouldPersistTaps="handled"</code> on ScrollView to allow pressing buttons while the keyboard is open. Without this, the first tap dismisses the keyboard instead of pressing the button.</p>
                </div>
            </section>
            <!-- Reusable Form Components -->
            <section id="reusable-components">
                <h2>Building Reusable Form Components</h2>

                <p>To avoid repeating the Controller boilerplate, create reusable form input components that integrate with React Hook Form.</p>

                <h3>FormInput Component</h3>

                <pre><code>// components/form/FormInput.tsx
import { Controller, Control, FieldValues, Path } from 'react-hook-form';
import { 
  View, 
  Text, 
  TextInput, 
  TextInputProps, 
  StyleSheet 
} from 'react-native';

interface FormInputProps&lt;T extends FieldValues&gt; extends Omit&lt;TextInputProps, 'value' | 'onChangeText'&gt; {
  control: Control&lt;T&gt;;
  name: Path&lt;T&gt;;
  label: string;
  rules?: object;
}

export function FormInput&lt;T extends FieldValues&gt;({
  control,
  name,
  label,
  rules,
  ...textInputProps
}: FormInputProps&lt;T&gt;) {
  return (
    &lt;Controller
      control={control}
      name={name}
      rules={rules}
      render={({ 
        field: { onChange, onBlur, value },
        fieldState: { error }
      }) =&gt; (
        &lt;View style={styles.container}&gt;
          &lt;Text style={styles.label}&gt;{label}&lt;/Text&gt;
          &lt;TextInput
            style={[
              styles.input,
              error && styles.inputError,
            ]}
            onBlur={onBlur}
            onChangeText={onChange}
            value={value}
            placeholderTextColor="#999"
            {...textInputProps}
          /&gt;
          {error && (
            &lt;Text style={styles.errorText}&gt;{error.message}&lt;/Text&gt;
          )}
        &lt;/View&gt;
      )}
    /&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 6,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  inputError: {
    borderColor: '#f44336',
    borderWidth: 2,
  },
  errorText: {
    color: '#f44336',
    fontSize: 12,
    marginTop: 4,
  },
});</code></pre>

                <h3>Usage with the Reusable Component</h3>

                <pre><code>import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { FormInput } from '../components/form/FormInput';

const schema = z.object({
  email: z.string().min(1, 'Required').email('Invalid email'),
  password: z.string().min(8, 'Min 8 characters'),
});

type FormData = z.infer&lt;typeof schema&gt;;

export default function LoginForm() {
  const { control, handleSubmit } = useForm&lt;FormData&gt;({
    resolver: zodResolver(schema),
    defaultValues: { email: '', password: '' },
  });

  return (
    &lt;View&gt;
      &lt;FormInput
        control={control}
        name="email"
        label="Email"
        placeholder="your@email.com"
        keyboardType="email-address"
        autoCapitalize="none"
      /&gt;

      &lt;FormInput
        control={control}
        name="password"
        label="Password"
        placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
        secureTextEntry
      /&gt;

      &lt;Button title="Log In" onPress={handleSubmit(onSubmit)} /&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>More Reusable Components</h3>

                <pre><code>// components/form/FormSelect.tsx
import { Controller, Control, FieldValues, Path } from 'react-hook-form';
import { View, Text, StyleSheet } from 'react-native';
import { Picker } from '@react-native-picker/picker';

interface Option {
  label: string;
  value: string;
}

interface FormSelectProps&lt;T extends FieldValues&gt; {
  control: Control&lt;T&gt;;
  name: Path&lt;T&gt;;
  label: string;
  options: Option[];
  placeholder?: string;
}

export function FormSelect&lt;T extends FieldValues&gt;({
  control,
  name,
  label,
  options,
  placeholder = 'Select an option',
}: FormSelectProps&lt;T&gt;) {
  return (
    &lt;Controller
      control={control}
      name={name}
      render={({ 
        field: { onChange, value },
        fieldState: { error }
      }) =&gt; (
        &lt;View style={styles.container}&gt;
          &lt;Text style={styles.label}&gt;{label}&lt;/Text&gt;
          &lt;View style={[styles.pickerContainer, error && styles.pickerError]}&gt;
            &lt;Picker
              selectedValue={value}
              onValueChange={onChange}
            &gt;
              &lt;Picker.Item label={placeholder} value="" /&gt;
              {options.map((option) =&gt; (
                &lt;Picker.Item
                  key={option.value}
                  label={option.label}
                  value={option.value}
                /&gt;
              ))}
            &lt;/Picker&gt;
          &lt;/View&gt;
          {error && (
            &lt;Text style={styles.errorText}&gt;{error.message}&lt;/Text&gt;
          )}
        &lt;/View&gt;
      )}
    /&gt;
  );
}

// components/form/FormCheckbox.tsx
import { Controller, Control, FieldValues, Path } from 'react-hook-form';
import { View, Text, Pressable, StyleSheet } from 'react-native';

interface FormCheckboxProps&lt;T extends FieldValues&gt; {
  control: Control&lt;T&gt;;
  name: Path&lt;T&gt;;
  label: string;
}

export function FormCheckbox&lt;T extends FieldValues&gt;({
  control,
  name,
  label,
}: FormCheckboxProps&lt;T&gt;) {
  return (
    &lt;Controller
      control={control}
      name={name}
      render={({ 
        field: { onChange, value },
        fieldState: { error }
      }) =&gt; (
        &lt;View style={styles.container}&gt;
          &lt;Pressable
            style={styles.checkboxRow}
            onPress={() =&gt; onChange(!value)}
          &gt;
            &lt;View style={[styles.checkbox, value && styles.checkboxChecked]}&gt;
              {value && &lt;Text style={styles.checkmark}&gt;‚úì&lt;/Text&gt;}
            &lt;/View&gt;
            &lt;Text style={styles.checkboxLabel}&gt;{label}&lt;/Text&gt;
          &lt;/Pressable&gt;
          {error && (
            &lt;Text style={styles.errorText}&gt;{error.message}&lt;/Text&gt;
          )}
        &lt;/View&gt;
      )}
    /&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  checkboxRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  checkbox: {
    width: 24,
    height: 24,
    borderWidth: 2,
    borderColor: '#ddd',
    borderRadius: 4,
    marginRight: 12,
    alignItems: 'center',
    justifyContent: 'center',
  },
  checkboxChecked: {
    backgroundColor: '#667eea',
    borderColor: '#667eea',
  },
  checkmark: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  checkboxLabel: {
    fontSize: 14,
    color: '#333',
  },
  errorText: {
    color: '#f44336',
    fontSize: 12,
    marginTop: 4,
  },
});</code></pre>
            </section>

            <!-- Real-World Form Examples -->
            <section id="real-world-forms">
                <h2>Real-World Form Examples</h2>

                <h3>Complete Registration Form</h3>

                <pre><code>import { useRef } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import {
  View,
  Text,
  TextInput,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  StyleSheet,
  Alert,
} from 'react-native';
import { FormInput } from '../components/form/FormInput';
import { FormCheckbox } from '../components/form/FormCheckbox';

const registrationSchema = z.object({
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  email: z.string().min(1, 'Email is required').email('Invalid email'),
  password: z
    .string()
    .min(1, 'Password is required')
    .min(8, 'At least 8 characters')
    .regex(/[A-Z]/, 'Must contain uppercase')
    .regex(/[0-9]/, 'Must contain a number'),
  confirmPassword: z.string().min(1, 'Please confirm password'),
  acceptTerms: z.boolean().refine(val => val, 'You must accept the terms'),
}).refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'],
});

type RegistrationData = z.infer&lt;typeof registrationSchema&gt;;

export default function RegistrationForm() {
  const lastNameRef = useRef&lt;TextInput&gt;(null);
  const emailRef = useRef&lt;TextInput&gt;(null);
  const passwordRef = useRef&lt;TextInput&gt;(null);
  const confirmPasswordRef = useRef&lt;TextInput&gt;(null);

  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm&lt;RegistrationData&gt;({
    resolver: zodResolver(registrationSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      email: '',
      password: '',
      confirmPassword: '',
      acceptTerms: false,
    },
  });

  const onSubmit = async (data: RegistrationData) => {
    try {
      // API call to register
      await new Promise(resolve => setTimeout(resolve, 1500));
      Alert.alert('Success', 'Account created successfully!');
    } catch (error) {
      Alert.alert('Error', 'Registration failed. Please try again.');
    }
  };

  return (
    &lt;KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    &gt;
      &lt;ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      &gt;
        &lt;Text style={styles.title}&gt;Create Account&lt;/Text&gt;

        &lt;View style={styles.row}&gt;
          &lt;View style={styles.halfField}&gt;
            &lt;FormInput
              control={control}
              name="firstName"
              label="First Name"
              placeholder="John"
              returnKeyType="next"
              onSubmitEditing={() =&gt; lastNameRef.current?.focus()}
              blurOnSubmit={false}
            /&gt;
          &lt;/View&gt;
          &lt;View style={styles.halfField}&gt;
            &lt;FormInput
              control={control}
              name="lastName"
              label="Last Name"
              placeholder="Doe"
              ref={lastNameRef}
              returnKeyType="next"
              onSubmitEditing={() =&gt; emailRef.current?.focus()}
              blurOnSubmit={false}
            /&gt;
          &lt;/View&gt;
        &lt;/View&gt;

        &lt;FormInput
          control={control}
          name="email"
          label="Email"
          placeholder="john@example.com"
          keyboardType="email-address"
          autoCapitalize="none"
          ref={emailRef}
          returnKeyType="next"
          onSubmitEditing={() =&gt; passwordRef.current?.focus()}
          blurOnSubmit={false}
        /&gt;

        &lt;FormInput
          control={control}
          name="password"
          label="Password"
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          secureTextEntry
          ref={passwordRef}
          returnKeyType="next"
          onSubmitEditing={() =&gt; confirmPasswordRef.current?.focus()}
          blurOnSubmit={false}
        /&gt;

        &lt;FormInput
          control={control}
          name="confirmPassword"
          label="Confirm Password"
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          secureTextEntry
          ref={confirmPasswordRef}
          returnKeyType="done"
        /&gt;

        &lt;FormCheckbox
          control={control}
          name="acceptTerms"
          label="I accept the Terms of Service and Privacy Policy"
        /&gt;

        &lt;Pressable
          style={[styles.button, isSubmitting && styles.buttonDisabled]}
          onPress={handleSubmit(onSubmit)}
          disabled={isSubmitting}
        &gt;
          &lt;Text style={styles.buttonText}&gt;
            {isSubmitting ? 'Creating Account...' : 'Create Account'}
          &lt;/Text&gt;
        &lt;/Pressable&gt;
      &lt;/ScrollView&gt;
    &lt;/KeyboardAvoidingView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    padding: 20,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 24,
    color: '#333',
  },
  row: {
    flexDirection: 'row',
    gap: 12,
  },
  halfField: {
    flex: 1,
  },
  button: {
    backgroundColor: '#667eea',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 8,
  },
  buttonDisabled: {
    backgroundColor: '#bbb',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});</code></pre>

                <h3>Multi-Step Form</h3>

                <pre><code>import { useState } from 'react';
import { useForm, FormProvider, useFormContext } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { View, Text, Pressable, StyleSheet } from 'react-native';
import { FormInput } from '../components/form/FormInput';

// Schema for each step
const step1Schema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Min 8 characters'),
});

const step2Schema = z.object({
  firstName: z.string().min(1, 'Required'),
  lastName: z.string().min(1, 'Required'),
  phone: z.string().min(10, 'Invalid phone number'),
});

const step3Schema = z.object({
  address: z.string().min(1, 'Required'),
  city: z.string().min(1, 'Required'),
  zipCode: z.string().min(5, 'Invalid zip code'),
});

// Combined schema
const fullSchema = step1Schema.merge(step2Schema).merge(step3Schema);
type FormData = z.infer&lt;typeof fullSchema&gt;;

const stepSchemas = [step1Schema, step2Schema, step3Schema];

// Step components
function Step1() {
  const { control } = useFormContext&lt;FormData&gt;();
  return (
    &lt;&gt;
      &lt;Text style={styles.stepTitle}&gt;Account Details&lt;/Text&gt;
      &lt;FormInput control={control} name="email" label="Email" keyboardType="email-address" /&gt;
      &lt;FormInput control={control} name="password" label="Password" secureTextEntry /&gt;
    &lt;/&gt;
  );
}

function Step2() {
  const { control } = useFormContext&lt;FormData&gt;();
  return (
    &lt;&gt;
      &lt;Text style={styles.stepTitle}&gt;Personal Info&lt;/Text&gt;
      &lt;FormInput control={control} name="firstName" label="First Name" /&gt;
      &lt;FormInput control={control} name="lastName" label="Last Name" /&gt;
      &lt;FormInput control={control} name="phone" label="Phone" keyboardType="phone-pad" /&gt;
    &lt;/&gt;
  );
}

function Step3() {
  const { control } = useFormContext&lt;FormData&gt;();
  return (
    &lt;&gt;
      &lt;Text style={styles.stepTitle}&gt;Address&lt;/Text&gt;
      &lt;FormInput control={control} name="address" label="Street Address" /&gt;
      &lt;FormInput control={control} name="city" label="City" /&gt;
      &lt;FormInput control={control} name="zipCode" label="Zip Code" keyboardType="number-pad" /&gt;
    &lt;/&gt;
  );
}

const steps = [Step1, Step2, Step3];

export default function MultiStepForm() {
  const [currentStep, setCurrentStep] = useState(0);
  
  const methods = useForm&lt;FormData&gt;({
    resolver: zodResolver(fullSchema),
    mode: 'onChange',
    defaultValues: {
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phone: '',
      address: '',
      city: '',
      zipCode: '',
    },
  });

  const { trigger, handleSubmit, formState: { isSubmitting } } = methods;

  const CurrentStepComponent = steps[currentStep];

  // Get fields for current step to validate
  const getStepFields = (step: number): (keyof FormData)[] => {
    switch (step) {
      case 0: return ['email', 'password'];
      case 1: return ['firstName', 'lastName', 'phone'];
      case 2: return ['address', 'city', 'zipCode'];
      default: return [];
    }
  };

  const handleNext = async () => {
    const fields = getStepFields(currentStep);
    const isValid = await trigger(fields);
    
    if (isValid) {
      setCurrentStep(prev => prev + 1);
    }
  };

  const handleBack = () => {
    setCurrentStep(prev => prev - 1);
  };

  const onSubmit = async (data: FormData) => {
    console.log('Final data:', data);
    // Submit to API...
  };

  const isLastStep = currentStep === steps.length - 1;

  return (
    &lt;FormProvider {...methods}&gt;
      &lt;View style={styles.container}&gt;
        {/* Progress indicator */}
        &lt;View style={styles.progressContainer}&gt;
          {steps.map((_, index) =&gt; (
            &lt;View
              key={index}
              style={[
                styles.progressDot,
                index &lt;= currentStep && styles.progressDotActive,
              ]}
            /&gt;
          ))}
        &lt;/View&gt;

        {/* Current step content */}
        &lt;View style={styles.stepContent}&gt;
          &lt;CurrentStepComponent /&gt;
        &lt;/View&gt;

        {/* Navigation buttons */}
        &lt;View style={styles.buttonRow}&gt;
          {currentStep &gt; 0 && (
            &lt;Pressable style={styles.backButton} onPress={handleBack}&gt;
              &lt;Text style={styles.backButtonText}&gt;Back&lt;/Text&gt;
            &lt;/Pressable&gt;
          )}
          
          &lt;Pressable
            style={[styles.nextButton, isSubmitting && styles.buttonDisabled]}
            onPress={isLastStep ? handleSubmit(onSubmit) : handleNext}
            disabled={isSubmitting}
          &gt;
            &lt;Text style={styles.nextButtonText}&gt;
              {isLastStep ? (isSubmitting ? 'Submitting...' : 'Submit') : 'Next'}
            &lt;/Text&gt;
          &lt;/Pressable&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    &lt;/FormProvider&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  progressContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 8,
    marginBottom: 24,
  },
  progressDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: '#ddd',
  },
  progressDotActive: {
    backgroundColor: '#667eea',
  },
  stepContent: {
    flex: 1,
  },
  stepTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    color: '#333',
  },
  buttonRow: {
    flexDirection: 'row',
    gap: 12,
  },
  backButton: {
    flex: 1,
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  backButtonText: {
    color: '#666',
    fontSize: 16,
    fontWeight: '600',
  },
  nextButton: {
    flex: 2,
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    backgroundColor: '#667eea',
  },
  nextButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  buttonDisabled: {
    backgroundColor: '#bbb',
  },
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Multi-Step Form Tips</h4>
                    <ul>
                        <li>Use <code>FormProvider</code> to share form context across step components</li>
                        <li>Validate only the current step's fields before moving forward</li>
                        <li>Use <code>mode: 'onChange'</code> for immediate validation feedback</li>
                        <li>Consider saving progress to AsyncStorage for long forms</li>
                        <li>Show a clear progress indicator</li>
                    </ul>
                </div>
            </section>

            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: Contact Form with React Hook Form</h3>
                    <p>Build a contact form with name, email, subject, and message fields.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>All fields required</li>
                        <li>Email must be valid format</li>
                        <li>Message must be at least 20 characters</li>
                        <li>Use Zod for validation</li>
                        <li>Show character count for message</li>
                        <li>Disable submit while submitting</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use <code>watch('message')</code> to get the current message value for displaying the character count. Create a Zod schema with <code>.min()</code> validators for each field.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { View, Text, TextInput, Pressable, StyleSheet } from 'react-native';

const contactSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().min(1, 'Email is required').email('Invalid email'),
  subject: z.string().min(1, 'Subject is required'),
  message: z.string().min(20, 'Message must be at least 20 characters'),
});

type ContactFormData = z.infer&lt;typeof contactSchema&gt;;

export default function ContactForm() {
  const {
    control,
    handleSubmit,
    watch,
    formState: { errors, isSubmitting },
  } = useForm&lt;ContactFormData&gt;({
    resolver: zodResolver(contactSchema),
    defaultValues: {
      name: '',
      email: '',
      subject: '',
      message: '',
    },
  });

  const messageValue = watch('message');
  const charCount = messageValue?.length || 0;

  const onSubmit = async (data: ContactFormData) => {
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('Submitted:', data);
    alert('Message sent!');
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;Controller
        control={control}
        name="name"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Name&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.name && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              placeholder="Your name"
            /&gt;
            {errors.name && &lt;Text style={styles.error}&gt;{errors.name.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Controller
        control={control}
        name="email"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Email&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.email && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              placeholder="your@email.com"
              keyboardType="email-address"
              autoCapitalize="none"
            /&gt;
            {errors.email && &lt;Text style={styles.error}&gt;{errors.email.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Controller
        control={control}
        name="subject"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Subject&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.subject && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              placeholder="What's this about?"
            /&gt;
            {errors.subject && &lt;Text style={styles.error}&gt;{errors.subject.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Controller
        control={control}
        name="message"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;View style={styles.labelRow}&gt;
              &lt;Text style={styles.label}&gt;Message&lt;/Text&gt;
              &lt;Text style={[styles.charCount, charCount &lt; 20 && styles.charCountWarning]}&gt;
                {charCount}/20 min
              &lt;/Text&gt;
            &lt;/View&gt;
            &lt;TextInput
              style={[styles.input, styles.textArea, errors.message && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              placeholder="Your message..."
              multiline
              numberOfLines={5}
              textAlignVertical="top"
            /&gt;
            {errors.message && &lt;Text style={styles.error}&gt;{errors.message.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Pressable
        style={[styles.button, isSubmitting && styles.buttonDisabled]}
        onPress={handleSubmit(onSubmit)}
        disabled={isSubmitting}
      &gt;
        &lt;Text style={styles.buttonText}&gt;
          {isSubmitting ? 'Sending...' : 'Send Message'}
        &lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { padding: 20 },
  field: { marginBottom: 16 },
  labelRow: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  label: { fontSize: 14, fontWeight: '600', marginBottom: 6, color: '#333' },
  charCount: { fontSize: 12, color: '#4CAF50' },
  charCountWarning: { color: '#f44336' },
  input: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 12, fontSize: 16 },
  inputError: { borderColor: '#f44336', borderWidth: 2 },
  textArea: { height: 120 },
  error: { color: '#f44336', fontSize: 12, marginTop: 4 },
  button: { backgroundColor: '#667eea', padding: 16, borderRadius: 8, alignItems: 'center' },
  buttonDisabled: { backgroundColor: '#bbb' },
  buttonText: { color: 'white', fontSize: 16, fontWeight: '600' },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Payment Form with Card Validation</h3>
                    <p>Create a credit card payment form with proper formatting and validation.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Card number: 16 digits, formatted as XXXX XXXX XXXX XXXX</li>
                        <li>Expiry: MM/YY format, must be future date</li>
                        <li>CVV: 3-4 digits</li>
                        <li>Cardholder name: Required</li>
                        <li>Auto-format inputs as user types</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use a custom <code>onChangeText</code> that formats the value before passing to React Hook Form's <code>onChange</code>. For card number: <code>value.replace(/\s/g, '').replace(/(.{4})/g, '$1 ').trim()</code></p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { View, Text, TextInput, Pressable, StyleSheet } from 'react-native';

const paymentSchema = z.object({
  cardNumber: z
    .string()
    .min(1, 'Card number is required')
    .refine(val => val.replace(/\s/g, '').length === 16, 'Must be 16 digits'),
  expiry: z
    .string()
    .min(1, 'Expiry is required')
    .regex(/^\d{2}\/\d{2}$/, 'Format: MM/YY')
    .refine(val => {
      const [month, year] = val.split('/').map(Number);
      const now = new Date();
      const expiry = new Date(2000 + year, month - 1);
      return expiry > now;
    }, 'Card has expired'),
  cvv: z
    .string()
    .min(3, 'CVV must be 3-4 digits')
    .max(4, 'CVV must be 3-4 digits')
    .regex(/^\d+$/, 'Must be numbers only'),
  name: z.string().min(1, 'Cardholder name is required'),
});

type PaymentFormData = z.infer&lt;typeof paymentSchema&gt;;

// Formatting functions
const formatCardNumber = (value: string) => {
  const digits = value.replace(/\D/g, '').slice(0, 16);
  return digits.replace(/(.{4})/g, '$1 ').trim();
};

const formatExpiry = (value: string) => {
  const digits = value.replace(/\D/g, '').slice(0, 4);
  if (digits.length >= 2) {
    return digits.slice(0, 2) + '/' + digits.slice(2);
  }
  return digits;
};

export default function PaymentForm() {
  const { control, handleSubmit, formState: { errors, isSubmitting } } = useForm&lt;PaymentFormData&gt;({
    resolver: zodResolver(paymentSchema),
    defaultValues: { cardNumber: '', expiry: '', cvv: '', name: '' },
  });

  const onSubmit = async (data: PaymentFormData) => {
    console.log('Payment:', data);
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;üí≥ Payment Details&lt;/Text&gt;

      &lt;Controller
        control={control}
        name="cardNumber"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Card Number&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.cardNumber && styles.inputError]}
              onBlur={onBlur}
              onChangeText={(text) => onChange(formatCardNumber(text))}
              value={value}
              placeholder="1234 5678 9012 3456"
              keyboardType="number-pad"
              maxLength={19}
            /&gt;
            {errors.cardNumber && &lt;Text style={styles.error}&gt;{errors.cardNumber.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;View style={styles.row}&gt;
        &lt;Controller
          control={control}
          name="expiry"
          render={({ field: { onChange, onBlur, value } }) =&gt; (
            &lt;View style={[styles.field, styles.halfField]}&gt;
              &lt;Text style={styles.label}&gt;Expiry&lt;/Text&gt;
              &lt;TextInput
                style={[styles.input, errors.expiry && styles.inputError]}
                onBlur={onBlur}
                onChangeText={(text) => onChange(formatExpiry(text))}
                value={value}
                placeholder="MM/YY"
                keyboardType="number-pad"
                maxLength={5}
              /&gt;
              {errors.expiry && &lt;Text style={styles.error}&gt;{errors.expiry.message}&lt;/Text&gt;}
            &lt;/View&gt;
          )}
        /&gt;

        &lt;Controller
          control={control}
          name="cvv"
          render={({ field: { onChange, onBlur, value } }) =&gt; (
            &lt;View style={[styles.field, styles.halfField]}&gt;
              &lt;Text style={styles.label}&gt;CVV&lt;/Text&gt;
              &lt;TextInput
                style={[styles.input, errors.cvv && styles.inputError]}
                onBlur={onBlur}
                onChangeText={(text) => onChange(text.replace(/\D/g, '').slice(0, 4))}
                value={value}
                placeholder="123"
                keyboardType="number-pad"
                secureTextEntry
                maxLength={4}
              /&gt;
              {errors.cvv && &lt;Text style={styles.error}&gt;{errors.cvv.message}&lt;/Text&gt;}
            &lt;/View&gt;
          )}
        /&gt;
      &lt;/View&gt;

      &lt;Controller
        control={control}
        name="name"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Cardholder Name&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.name && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              placeholder="John Doe"
              autoCapitalize="words"
            /&gt;
            {errors.name && &lt;Text style={styles.error}&gt;{errors.name.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Pressable
        style={[styles.button, isSubmitting && styles.buttonDisabled]}
        onPress={handleSubmit(onSubmit)}
        disabled={isSubmitting}
      &gt;
        &lt;Text style={styles.buttonText}&gt;{isSubmitting ? 'Processing...' : 'Pay Now'}&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { padding: 20 },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20 },
  field: { marginBottom: 16 },
  row: { flexDirection: 'row', gap: 12 },
  halfField: { flex: 1 },
  label: { fontSize: 14, fontWeight: '600', marginBottom: 6, color: '#333' },
  input: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 12, fontSize: 16 },
  inputError: { borderColor: '#f44336', borderWidth: 2 },
  error: { color: '#f44336', fontSize: 12, marginTop: 4 },
  button: { backgroundColor: '#667eea', padding: 16, borderRadius: 8, alignItems: 'center', marginTop: 8 },
  buttonDisabled: { backgroundColor: '#bbb' },
  buttonText: { color: 'white', fontSize: 16, fontWeight: '600' },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Profile Edit with Pre-filled Data</h3>
                    <p>Build a profile edit form that loads existing user data and tracks changes.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Load user data from a mock API on mount</li>
                        <li>Pre-fill the form with existing values</li>
                        <li>Show "Save" button only if form is dirty (has changes)</li>
                        <li>Show loading state while fetching initial data</li>
                        <li>Reset changes with a "Cancel" button</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use <code>reset()</code> from useForm to set values after fetching. Check <code>formState.isDirty</code> to conditionally show the save button. Call <code>reset(getValues())</code> after successful save to mark form as clean.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useEffect, useState } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { View, Text, TextInput, Pressable, ActivityIndicator, StyleSheet } from 'react-native';

interface UserProfile {
  name: string;
  email: string;
  bio: string;
  website: string;
}

// Mock API
const fetchProfile = async (): Promise&lt;UserProfile&gt; => {
  await new Promise(r => setTimeout(r, 1000));
  return {
    name: 'John Doe',
    email: 'john@example.com',
    bio: 'React Native developer',
    website: 'https://johndoe.dev',
  };
};

export default function ProfileEditForm() {
  const [isLoading, setIsLoading] = useState(true);

  const {
    control,
    handleSubmit,
    reset,
    formState: { errors, isDirty, isSubmitting },
  } = useForm&lt;UserProfile&gt;({
    defaultValues: { name: '', email: '', bio: '', website: '' },
  });

  // Fetch and populate form
  useEffect(() => {
    const loadProfile = async () => {
      const profile = await fetchProfile();
      reset(profile); // Pre-fill with fetched data
      setIsLoading(false);
    };
    loadProfile();
  }, [reset]);

  const onSubmit = async (data: UserProfile) => {
    await new Promise(r => setTimeout(r, 1000));
    console.log('Saved:', data);
    reset(data); // Mark form as clean after save
    alert('Profile saved!');
  };

  const handleCancel = () => {
    reset(); // Reset to last saved values
  };

  if (isLoading) {
    return (
      &lt;View style={styles.loading}&gt;
        &lt;ActivityIndicator size="large" color="#667eea" /&gt;
        &lt;Text&gt;Loading profile...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Edit Profile&lt;/Text&gt;

      &lt;Controller
        control={control}
        name="name"
        rules={{ required: 'Name is required' }}
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Name&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.name && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
            /&gt;
            {errors.name && &lt;Text style={styles.error}&gt;{errors.name.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Controller
        control={control}
        name="email"
        rules={{ required: 'Email is required' }}
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Email&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, errors.email && styles.inputError]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              keyboardType="email-address"
              autoCapitalize="none"
            /&gt;
            {errors.email && &lt;Text style={styles.error}&gt;{errors.email.message}&lt;/Text&gt;}
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Controller
        control={control}
        name="bio"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Bio&lt;/Text&gt;
            &lt;TextInput
              style={[styles.input, styles.textArea]}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              multiline
              numberOfLines={3}
            /&gt;
          &lt;/View&gt;
        )}
      /&gt;

      &lt;Controller
        control={control}
        name="website"
        render={({ field: { onChange, onBlur, value } }) =&gt; (
          &lt;View style={styles.field}&gt;
            &lt;Text style={styles.label}&gt;Website&lt;/Text&gt;
            &lt;TextInput
              style={styles.input}
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              keyboardType="url"
              autoCapitalize="none"
            /&gt;
          &lt;/View&gt;
        )}
      /&gt;

      {isDirty && (
        &lt;View style={styles.buttonRow}&gt;
          &lt;Pressable style={styles.cancelButton} onPress={handleCancel}&gt;
            &lt;Text style={styles.cancelButtonText}&gt;Cancel&lt;/Text&gt;
          &lt;/Pressable&gt;
          &lt;Pressable
            style={[styles.saveButton, isSubmitting && styles.buttonDisabled]}
            onPress={handleSubmit(onSubmit)}
            disabled={isSubmitting}
          &gt;
            &lt;Text style={styles.saveButtonText}&gt;
              {isSubmitting ? 'Saving...' : 'Save Changes'}
            &lt;/Text&gt;
          &lt;/Pressable&gt;
        &lt;/View&gt;
      )}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { padding: 20 },
  loading: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20 },
  field: { marginBottom: 16 },
  label: { fontSize: 14, fontWeight: '600', marginBottom: 6 },
  input: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 12, fontSize: 16 },
  inputError: { borderColor: '#f44336' },
  textArea: { height: 80, textAlignVertical: 'top' },
  error: { color: '#f44336', fontSize: 12, marginTop: 4 },
  buttonRow: { flexDirection: 'row', gap: 12, marginTop: 8 },
  cancelButton: { flex: 1, padding: 16, borderRadius: 8, backgroundColor: '#f5f5f5', alignItems: 'center' },
  cancelButtonText: { color: '#666', fontWeight: '600' },
  saveButton: { flex: 2, padding: 16, borderRadius: 8, backgroundColor: '#667eea', alignItems: 'center' },
  saveButtonText: { color: 'white', fontWeight: '600' },
  buttonDisabled: { backgroundColor: '#bbb' },
});</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>Forms are a critical part of most mobile apps. Using the right tools and patterns makes them easier to build and maintain, while providing a great user experience.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>React Hook Form</strong> minimizes re-renders and reduces boilerplate</li>
                        <li><strong>Controller component</strong> is required for React Native TextInputs</li>
                        <li><strong>Zod</strong> provides type-safe validation with automatic TypeScript inference</li>
                        <li><strong>KeyboardAvoidingView</strong> prevents the keyboard from covering inputs</li>
                        <li><strong>keyboardShouldPersistTaps="handled"</strong> allows tapping buttons while keyboard is open</li>
                        <li><strong>Use refs and onSubmitEditing</strong> to move between fields</li>
                        <li><strong>Build reusable FormInput components</strong> to reduce repetition</li>
                        <li><strong>Use formState.isDirty</strong> to track if form has been modified</li>
                        <li><strong>FormProvider</strong> enables multi-step forms with shared state</li>
                    </ul>
                </div>

                <p>This completes our Data Management and Networking module. You now have a comprehensive toolkit for managing data in React Native apps‚Äîfrom fetching server data to storing it locally, managing complex state, and building user-friendly forms.</p>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m07_l04_state_management_at_scale.html" class="prev-link">‚Üê Previous: State Management at Scale</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m08_l01_native_device_features.html" class="next-link">Next: Module 8 - Native Device Features ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
