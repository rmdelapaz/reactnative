<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Basics | React Native & Expo Course</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="stylesheet" href="styles/main.css">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <header class="top-nav">
        <div class="nav-container">
            <a href="index.html" class="logo" aria-label="Course Home">
                <span class="logo-react">‚öõÔ∏è</span> RN
            </a>
            <nav class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="appendix_c_component_reference.html">Reference</a>
            </nav>
            <button class="mobile-menu-toggle" id="mobile-menu-toggle" aria-label="Toggle menu" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </header>

    <nav class="breadcrumb" aria-label="Breadcrumb">
        <div class="container">
            <a href="index.html">Home</a>
            <span aria-hidden="true">‚Ä∫</span>
            <a href="index.html#module4">Module 4</a>
            <span aria-hidden="true">‚Ä∫</span>
            <span aria-current="page">Animation Basics</span>
        </div>
    </nav>

    <main id="main-content">
        <article class="lesson-container">
            <header class="lesson-header">
                <div class="module-badge">Module 4: StyleSheet Deep Dive</div>
                <h1>Animation Basics</h1>
                <p class="lesson-subtitle">Bring your UI to life with smooth, performant animations</p>
            </header>

            <details class="toc-container" id="toc">
                <summary>Table of Contents</summary>
                <nav class="toc-nav" aria-label="Table of Contents">
                    <ul>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#animated-api">The Animated API</a></li>
                        <li><a href="#animated-value">Animated.Value</a></li>
                        <li><a href="#animation-types">Animation Types</a></li>
                        <li><a href="#interpolation">Interpolation</a></li>
                        <li><a href="#combining-animations">Combining Animations</a></li>
                        <li><a href="#common-patterns">Common Animation Patterns</a></li>
                        <li><a href="#performance">Performance Tips</a></li>
                        <li><a href="#useAnimatedValue">The useAnimatedValue Hook</a></li>
                        <li><a href="#hands-on">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </nav>
            </details>

            <div class="learning-objectives card">
                <h2>üéØ Learning Objectives</h2>
                <ul>
                    <li>Understand the Animated API architecture and why it's performant</li>
                    <li>Create and manage Animated.Value for animatable properties</li>
                    <li>Use timing, spring, and decay animations appropriately</li>
                    <li>Transform animated values with interpolation</li>
                    <li>Combine multiple animations with sequence, parallel, and stagger</li>
                    <li>Implement common animation patterns: fade, slide, scale, rotate</li>
                    <li>Optimize animations for 60fps performance</li>
                </ul>
            </div>

            <section id="introduction">
                <h2>Introduction</h2>

                <p>Animation transforms static interfaces into dynamic, engaging experiences. A well-placed animation can guide attention, provide feedback, create delight, and make your app feel polished and professional.</p>

                <p>React Native's Animated API is designed from the ground up for performance. Unlike web animations that often cause layout thrashing, React Native animations can run entirely on the native UI thread, achieving smooth 60fps even on lower-end devices.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>‚ú® Why Animation Matters</h4>
                    <p style="color: white;">Users perceive animated interfaces as faster, more responsive, and more premium. A 200ms fade transition feels instant, while an abrupt change feels jarring. Animation isn't decoration ‚Äî it's communication.</p>
                </div>

                <h3>Animation Options in React Native</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background: #e3f2fd;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">API</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">Best For</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;"><strong>Animated API</strong></td>
                            <td style="padding: 12px;">Most animations, this lesson's focus</td>
                            <td style="padding: 12px;">Medium</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;"><strong>LayoutAnimation</strong></td>
                            <td style="padding: 12px;">Automatic layout transitions</td>
                            <td style="padding: 12px;">Low</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px;"><strong>Reanimated</strong></td>
                            <td style="padding: 12px;">Complex gestures, worklets</td>
                            <td style="padding: 12px;">High</td>
                        </tr>
                    </tbody>
                </table>

                <p>This lesson focuses on the built-in Animated API. It's powerful enough for most use cases and requires no additional dependencies. We'll cover Reanimated in a later module for advanced scenarios.</p>

                <pre class="mermaid">
flowchart LR
    subgraph JS["JavaScript Thread"]
        AV["Animated.Value"]
        Config["Animation Config"]
    end
    
    subgraph Native["Native UI Thread"]
        Driver["Native Driver"]
        UI["UI Updates"]
    end
    
    AV --> Config
    Config -->|"useNativeDriver: true"| Driver
    Driver --> UI
    
    style JS fill:#e3f2fd
    style Native fill:#e8f5e9
                </pre>
            </section>

            <section id="animated-api">
                <h2>The Animated API</h2>

                <p>The Animated API consists of three main parts: animated values that store animation state, animation functions that change those values over time, and animated components that render the values.</p>

                <h3>Core Concepts</h3>

<pre><code class="language-typescript">import { Animated } from 'react-native';

// 1. Animated Value - stores the animation state
const opacity = new Animated.Value(0);

// 2. Animation Function - changes the value over time
Animated.timing(opacity, {
  toValue: 1,
  duration: 300,
  useNativeDriver: true,
}).start();

// 3. Animated Component - renders the animated value
&lt;Animated.View style={{ opacity }}&gt;
  &lt;Text&gt;I fade in!&lt;/Text&gt;
&lt;/Animated.View&gt;</code></pre>

                <h3>Animated Components</h3>

                <p>React Native provides pre-wrapped animated versions of common components:</p>

<pre><code class="language-typescript">// Built-in animated components
Animated.View      // Most common, for containers
Animated.Text      // For text animations
Animated.Image     // For image animations
Animated.ScrollView // For scroll-linked animations
Animated.FlatList  // For list animations

// Create custom animated components
const AnimatedPressable = Animated.createAnimatedComponent(Pressable);</code></pre>

                <h3>What Can Be Animated?</h3>

                <p>Not all style properties support animation. Here's what works:</p>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                    <div class="card" style="margin: 0; background: #e8f5e9;">
                        <h4>‚úÖ Native Driver Compatible</h4>
                        <ul>
                            <li><code>opacity</code></li>
                            <li><code>transform</code> (translateX/Y, scale, rotate)</li>
                        </ul>
                        <p><small>Run on UI thread, best performance</small></p>
                    </div>
                    <div class="card" style="margin: 0; background: #fff3e0;">
                        <h4>‚ö†Ô∏è JS Thread Only</h4>
                        <ul>
                            <li><code>width</code>, <code>height</code></li>
                            <li><code>backgroundColor</code></li>
                            <li><code>margin</code>, <code>padding</code></li>
                            <li><code>borderRadius</code></li>
                        </ul>
                        <p><small>Require useNativeDriver: false</small></p>
                    </div>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practice: Use Native Driver</h4>
                    <p>Always use <code>useNativeDriver: true</code> when animating <code>opacity</code> or <code>transform</code>. This runs the animation entirely on the native thread, ensuring smooth 60fps regardless of JavaScript thread activity.</p>
                </div>
            </section>

            <section id="animated-value">
                <h2>Animated.Value</h2>

                <p><code>Animated.Value</code> is the foundation of all animations. It holds a single numeric value that can change over time.</p>

                <h3>Creating Animated Values</h3>

<pre><code class="language-typescript">import { useRef } from 'react';
import { Animated } from 'react-native';

function MyComponent() {
  // Create animated value with useRef to persist across renders
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(-100)).current;
  const scaleAnim = useRef(new Animated.Value(0.5)).current;
  
  // Initial values represent starting state:
  // fadeAnim: 0 = fully transparent
  // slideAnim: -100 = 100 units off-screen left
  // scaleAnim: 0.5 = half size
}</code></pre>

                <h3>Reading and Setting Values</h3>

<pre><code class="language-typescript">const animValue = useRef(new Animated.Value(0)).current;

// Set value immediately (no animation)
animValue.setValue(100);

// Read current value (async, for debugging)
animValue.addListener(({ value }) => {
  console.log('Current value:', value);
});

// Remove listener when done
animValue.removeAllListeners();</code></pre>

                <h3>Animated.ValueXY for 2D</h3>

                <p>For animations involving both X and Y coordinates (like drag gestures), use <code>Animated.ValueXY</code>:</p>

<pre><code class="language-typescript">const position = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;

// Animate to new position
Animated.spring(position, {
  toValue: { x: 100, y: 200 },
  useNativeDriver: true,
}).start();

// Use in styles
&lt;Animated.View
  style={{
    transform: position.getTranslateTransform(),
    // Equivalent to:
    // transform: [
    //   { translateX: position.x },
    //   { translateY: position.y },
    // ],
  }}
/&gt;</code></pre>

                <h3>Using Animated Values in Styles</h3>

<pre><code class="language-typescript">function FadeInView({ children }) {
  const opacity = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(opacity, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start();
  }, []);
  
  return (
    &lt;Animated.View style={{ opacity }}&gt;
      {children}
    &lt;/Animated.View&gt;
  );
}

// For transform animations
function SlideInView({ children }) {
  const translateX = useRef(new Animated.Value(-300)).current;
  
  useEffect(() => {
    Animated.spring(translateX, {
      toValue: 0,
      useNativeDriver: true,
    }).start();
  }, []);
  
  return (
    &lt;Animated.View 
      style={{
        transform: [{ translateX }],
      }}
    &gt;
      {children}
    &lt;/Animated.View&gt;
  );
}</code></pre>
            </section>

            <section id="animation-types">
                <h2>Animation Types</h2>

                <p>React Native provides three animation functions, each with different characteristics.</p>

                <h3>Animated.timing()</h3>

                <p>The most common animation type. Animates a value over a specified duration using an easing function.</p>

<pre><code class="language-typescript">import { Animated, Easing } from 'react-native';

Animated.timing(animatedValue, {
  toValue: 1,                    // Target value
  duration: 300,                 // Duration in milliseconds
  delay: 0,                      // Delay before starting
  easing: Easing.ease,           // Easing function
  useNativeDriver: true,         // Use native driver
}).start((finished) => {
  // Callback when animation completes
  if (finished) {
    console.log('Animation finished!');
  }
});</code></pre>

                <h4>Easing Functions</h4>

<pre><code class="language-typescript">import { Easing } from 'react-native';

// Built-in easing functions
Easing.linear        // Constant speed
Easing.ease          // Gentle acceleration and deceleration
Easing.quad          // Quadratic (power of 2)
Easing.cubic         // Cubic (power of 3)
Easing.sin           // Sinusoidal
Easing.exp           // Exponential
Easing.circle        // Circular
Easing.bounce        // Bouncy ending

// Modifiers
Easing.in(Easing.quad)     // Accelerate
Easing.out(Easing.quad)    // Decelerate
Easing.inOut(Easing.quad)  // Both

// Bezier curves (like CSS)
Easing.bezier(0.25, 0.1, 0.25, 1)  // Custom curve</code></pre>

                <svg viewBox="0 0 600 200" style="width: 100%; max-width: 600px; margin: 20px auto; display: block;">
                    <!-- Linear -->
                    <g transform="translate(30, 30)">
                        <text x="50" y="-10" text-anchor="middle" font-size="11" fill="#666">linear</text>
                        <rect x="0" y="0" width="100" height="100" fill="none" stroke="#e0e0e0"/>
                        <line x1="0" y1="100" x2="100" y2="0" stroke="#2196F3" stroke-width="2"/>
                    </g>
                    
                    <!-- Ease -->
                    <g transform="translate(160, 30)">
                        <text x="50" y="-10" text-anchor="middle" font-size="11" fill="#666">ease</text>
                        <rect x="0" y="0" width="100" height="100" fill="none" stroke="#e0e0e0"/>
                        <path d="M0,100 C25,100 25,0 100,0" fill="none" stroke="#4CAF50" stroke-width="2"/>
                    </g>
                    
                    <!-- Ease-in -->
                    <g transform="translate(290, 30)">
                        <text x="50" y="-10" text-anchor="middle" font-size="11" fill="#666">easeIn</text>
                        <rect x="0" y="0" width="100" height="100" fill="none" stroke="#e0e0e0"/>
                        <path d="M0,100 C60,100 100,60 100,0" fill="none" stroke="#FF9800" stroke-width="2"/>
                    </g>
                    
                    <!-- Ease-out -->
                    <g transform="translate(420, 30)">
                        <text x="50" y="-10" text-anchor="middle" font-size="11" fill="#666">easeOut</text>
                        <rect x="0" y="0" width="100" height="100" fill="none" stroke="#e0e0e0"/>
                        <path d="M0,100 C0,40 40,0 100,0" fill="none" stroke="#9C27B0" stroke-width="2"/>
                    </g>
                    
                    <!-- Legend -->
                    <text x="300" y="170" text-anchor="middle" font-size="11" fill="#999">X = time, Y = progress</text>
                </svg>

                <h3>Animated.spring()</h3>

                <p>Creates natural, physics-based animations. Great for elements that should feel like they have mass.</p>

<pre><code class="language-typescript">Animated.spring(animatedValue, {
  toValue: 1,
  
  // Physics configuration (choose one approach):
  
  // Approach 1: Bounciness and Speed
  friction: 7,        // Controls bounce (lower = more bouncy)
  tension: 40,        // Controls speed (higher = faster)
  
  // Approach 2: Spring physics
  // stiffness: 100,   // Spring stiffness
  // damping: 10,      // Friction force
  // mass: 1,          // Object mass
  
  // Approach 3: Timing-based
  // speed: 12,        // Animation speed
  // bounciness: 8,    // Bounce amount
  
  useNativeDriver: true,
}).start();</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use Spring</h4>
                    <ul>
                        <li>Button press feedback</li>
                        <li>Modal/sheet presentations</li>
                        <li>Drag and release</li>
                        <li>Pull to refresh</li>
                        <li>Anything that should feel "physical"</li>
                    </ul>
                </div>

                <h3>Animated.decay()</h3>

                <p>Animates a value from an initial velocity, gradually slowing to a stop. Perfect for scroll-like momentum.</p>

<pre><code class="language-typescript">Animated.decay(animatedValue, {
  velocity: 0.5,           // Initial velocity
  deceleration: 0.997,     // Rate of slowdown (0.997 is default)
  useNativeDriver: true,
}).start();</code></pre>

                <h3>Comparison</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background: #e3f2fd;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">Type</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">Use Case</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">Duration</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;"><code>timing</code></td>
                            <td style="padding: 12px;">Precise, timed animations</td>
                            <td style="padding: 12px;">Fixed (you specify)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;"><code>spring</code></td>
                            <td style="padding: 12px;">Natural, physical feel</td>
                            <td style="padding: 12px;">Dynamic (physics-based)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px;"><code>decay</code></td>
                            <td style="padding: 12px;">Momentum/inertia</td>
                            <td style="padding: 12px;">Dynamic (velocity-based)</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="interpolation">
                <h2>Interpolation</h2>

                <p>Interpolation transforms an animated value from one range to another. It's incredibly powerful for creating complex animations from a single animated value.</p>

                <h3>Basic Interpolation</h3>

<pre><code class="language-typescript">const animValue = useRef(new Animated.Value(0)).current;

// Map 0-1 to 0-100
const translateX = animValue.interpolate({
  inputRange: [0, 1],
  outputRange: [0, 100],
});

// As animValue goes 0 ‚Üí 1, translateX goes 0 ‚Üí 100</code></pre>

                <h3>Multiple Segments</h3>

<pre><code class="language-typescript">const progress = useRef(new Animated.Value(0)).current;

// Create a multi-stage animation
const opacity = progress.interpolate({
  inputRange: [0, 0.5, 1],
  outputRange: [0, 1, 0],  // Fade in, then fade out
});

// Scale up quickly, then slowly
const scale = progress.interpolate({
  inputRange: [0, 0.3, 1],
  outputRange: [0, 1, 1.2],
});

// Animate progress from 0 to 1
Animated.timing(progress, {
  toValue: 1,
  duration: 1000,
  useNativeDriver: true,
}).start();</code></pre>

                <svg viewBox="0 0 500 200" style="width: 100%; max-width: 500px; margin: 20px auto; display: block;">
                    <text x="250" y="20" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Interpolation: One Value ‚Üí Multiple Outputs</text>
                    
                    <!-- Input -->
                    <g transform="translate(50, 60)">
                        <rect x="0" y="0" width="100" height="40" rx="6" fill="#e3f2fd" stroke="#2196F3"/>
                        <text x="50" y="25" text-anchor="middle" font-size="12" fill="#1976D2">progress: 0‚Üí1</text>
                    </g>
                    
                    <!-- Arrow -->
                    <path d="M160,80 L200,80 M195,75 L200,80 L195,85" fill="none" stroke="#666" stroke-width="2"/>
                    
                    <!-- Outputs -->
                    <g transform="translate(220, 40)">
                        <rect x="0" y="0" width="120" height="30" rx="4" fill="#e8f5e9" stroke="#4CAF50"/>
                        <text x="60" y="20" text-anchor="middle" font-size="11" fill="#388E3C">opacity: 0‚Üí1‚Üí0</text>
                    </g>
                    <g transform="translate(220, 80)">
                        <rect x="0" y="0" width="120" height="30" rx="4" fill="#fff3e0" stroke="#FF9800"/>
                        <text x="60" y="20" text-anchor="middle" font-size="11" fill="#F57C00">scale: 0‚Üí1‚Üí1.2</text>
                    </g>
                    <g transform="translate(220, 120)">
                        <rect x="0" y="0" width="120" height="30" rx="4" fill="#fce4ec" stroke="#E91E63"/>
                        <text x="60" y="20" text-anchor="middle" font-size="11" fill="#C2185B">rotate: 0‚Üí360deg</text>
                    </g>
                    
                    <text x="250" y="180" text-anchor="middle" font-size="11" fill="#666">Single animated value drives multiple style properties</text>
                </svg>

                <h3>String Output Values</h3>

                <p>Interpolation can output strings for properties like colors and rotation:</p>

<pre><code class="language-typescript">const animValue = useRef(new Animated.Value(0)).current;

// Rotation (degrees)
const rotate = animValue.interpolate({
  inputRange: [0, 1],
  outputRange: ['0deg', '360deg'],
});

// Colors
const backgroundColor = animValue.interpolate({
  inputRange: [0, 1],
  outputRange: ['#ff0000', '#00ff00'],
});
// Note: Color interpolation requires useNativeDriver: false

// Usage
&lt;Animated.View
  style={{
    transform: [{ rotate }],
    backgroundColor, // Only with useNativeDriver: false
  }}
/&gt;</code></pre>

                <h3>Extrapolation</h3>

                <p>Control what happens when the input value goes outside the defined range:</p>

<pre><code class="language-typescript">const animValue = useRef(new Animated.Value(0)).current;

const clamped = animValue.interpolate({
  inputRange: [0, 1],
  outputRange: [0, 100],
  extrapolate: 'clamp',  // Stay at boundaries
});

const extended = animValue.interpolate({
  inputRange: [0, 1],
  outputRange: [0, 100],
  extrapolate: 'extend', // Continue beyond (default)
});

// If animValue = 1.5:
// clamped = 100 (stopped at max)
// extended = 150 (continued past max)

// Mixed extrapolation
const mixed = animValue.interpolate({
  inputRange: [0, 1],
  outputRange: [0, 100],
  extrapolateLeft: 'clamp',   // Clamp below 0
  extrapolateRight: 'extend', // Extend above 1
});</code></pre>
            </section>
            <section id="combining-animations">
                <h2>Combining Animations</h2>

                <p>Complex animations often require multiple animated values working together. React Native provides composition functions to orchestrate them.</p>

                <h3>Animated.parallel()</h3>

                <p>Runs multiple animations simultaneously. All animations start at the same time.</p>

<pre><code class="language-typescript">const opacity = useRef(new Animated.Value(0)).current;
const translateY = useRef(new Animated.Value(50)).current;
const scale = useRef(new Animated.Value(0.8)).current;

function fadeInUp() {
  Animated.parallel([
    Animated.timing(opacity, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }),
    Animated.timing(translateY, {
      toValue: 0,
      duration: 300,
      useNativeDriver: true,
    }),
    Animated.spring(scale, {
      toValue: 1,
      useNativeDriver: true,
    }),
  ]).start();
}

// Usage
&lt;Animated.View
  style={{
    opacity,
    transform: [{ translateY }, { scale }],
  }}
&gt;
  &lt;Content /&gt;
&lt;/Animated.View&gt;</code></pre>

                <h3>Animated.sequence()</h3>

                <p>Runs animations one after another. Each animation starts when the previous one finishes.</p>

<pre><code class="language-typescript">const step1 = useRef(new Animated.Value(0)).current;
const step2 = useRef(new Animated.Value(0)).current;
const step3 = useRef(new Animated.Value(0)).current;

function runSequence() {
  Animated.sequence([
    // First: fade in
    Animated.timing(step1, {
      toValue: 1,
      duration: 200,
      useNativeDriver: true,
    }),
    // Then: slide
    Animated.timing(step2, {
      toValue: 1,
      duration: 200,
      useNativeDriver: true,
    }),
    // Finally: scale
    Animated.spring(step3, {
      toValue: 1,
      useNativeDriver: true,
    }),
  ]).start();
}</code></pre>

                <h3>Animated.stagger()</h3>

                <p>Starts animations in parallel but with a delay between each start. Perfect for list item animations.</p>

<pre><code class="language-typescript">function StaggeredList({ items }) {
  // Create an animated value for each item
  const animValues = useRef(
    items.map(() => new Animated.Value(0))
  ).current;
  
  useEffect(() => {
    // Stagger animations with 100ms delay between each
    Animated.stagger(
      100, // Delay between each animation start
      animValues.map(anim =>
        Animated.spring(anim, {
          toValue: 1,
          useNativeDriver: true,
        })
      )
    ).start();
  }, []);
  
  return (
    &lt;View&gt;
      {items.map((item, index) => (
        &lt;Animated.View
          key={item.id}
          style={{
            opacity: animValues[index],
            transform: [{
              translateX: animValues[index].interpolate({
                inputRange: [0, 1],
                outputRange: [-50, 0],
              }),
            }],
          }}
        &gt;
          &lt;ItemCard item={item} /&gt;
        &lt;/Animated.View&gt;
      ))}
    &lt;/View&gt;
  );
}</code></pre>

                <svg viewBox="0 0 600 200" style="width: 100%; max-width: 600px; margin: 20px auto; display: block;">
                    <!-- Parallel -->
                    <g transform="translate(30, 40)">
                        <text x="60" y="-15" text-anchor="middle" font-size="12" font-weight="bold" fill="#333">parallel()</text>
                        <rect x="0" y="0" width="120" height="20" fill="#2196F3" rx="4"/>
                        <rect x="0" y="25" width="120" height="20" fill="#4CAF50" rx="4"/>
                        <rect x="0" y="50" width="120" height="20" fill="#FF9800" rx="4"/>
                        <text x="60" y="95" text-anchor="middle" font-size="10" fill="#666">All start together</text>
                    </g>
                    
                    <!-- Sequence -->
                    <g transform="translate(200, 40)">
                        <text x="90" y="-15" text-anchor="middle" font-size="12" font-weight="bold" fill="#333">sequence()</text>
                        <rect x="0" y="0" width="60" height="20" fill="#2196F3" rx="4"/>
                        <rect x="60" y="25" width="60" height="20" fill="#4CAF50" rx="4"/>
                        <rect x="120" y="50" width="60" height="20" fill="#FF9800" rx="4"/>
                        <text x="90" y="95" text-anchor="middle" font-size="10" fill="#666">One after another</text>
                    </g>
                    
                    <!-- Stagger -->
                    <g transform="translate(400, 40)">
                        <text x="80" y="-15" text-anchor="middle" font-size="12" font-weight="bold" fill="#333">stagger(100)</text>
                        <rect x="0" y="0" width="100" height="20" fill="#2196F3" rx="4"/>
                        <rect x="25" y="25" width="100" height="20" fill="#4CAF50" rx="4"/>
                        <rect x="50" y="50" width="100" height="20" fill="#FF9800" rx="4"/>
                        <text x="80" y="95" text-anchor="middle" font-size="10" fill="#666">Offset starts by delay</text>
                    </g>
                    
                    <!-- Time axis -->
                    <line x1="30" y1="150" x2="570" y2="150" stroke="#e0e0e0" stroke-width="1"/>
                    <text x="300" y="170" text-anchor="middle" font-size="10" fill="#999">Time ‚Üí</text>
                </svg>

                <h3>Animated.loop()</h3>

                <p>Repeats an animation continuously. Great for loading indicators and attention-grabbing animations.</p>

<pre><code class="language-typescript">const rotation = useRef(new Animated.Value(0)).current;

useEffect(() => {
  const animation = Animated.loop(
    Animated.timing(rotation, {
      toValue: 1,
      duration: 1000,
      easing: Easing.linear,
      useNativeDriver: true,
    })
  );
  
  animation.start();
  
  // Cleanup
  return () => animation.stop();
}, []);

const rotate = rotation.interpolate({
  inputRange: [0, 1],
  outputRange: ['0deg', '360deg'],
});

// Spinning loader
&lt;Animated.View style={{ transform: [{ rotate }] }}&gt;
  &lt;LoaderIcon /&gt;
&lt;/Animated.View&gt;</code></pre>

                <h3>Loop with Iterations</h3>

<pre><code class="language-typescript">// Loop a specific number of times
Animated.loop(
  Animated.sequence([
    Animated.timing(scale, {
      toValue: 1.2,
      duration: 200,
      useNativeDriver: true,
    }),
    Animated.timing(scale, {
      toValue: 1,
      duration: 200,
      useNativeDriver: true,
    }),
  ]),
  { iterations: 3 } // Bounce 3 times, then stop
).start();</code></pre>

                <h3>Combining Parallel and Sequence</h3>

<pre><code class="language-typescript">// Complex animation: slide in while fading, then pulse
Animated.sequence([
  // Phase 1: Enter
  Animated.parallel([
    Animated.timing(opacity, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }),
    Animated.spring(translateY, {
      toValue: 0,
      useNativeDriver: true,
    }),
  ]),
  // Phase 2: Attention pulse
  Animated.sequence([
    Animated.timing(scale, {
      toValue: 1.1,
      duration: 150,
      useNativeDriver: true,
    }),
    Animated.timing(scale, {
      toValue: 1,
      duration: 150,
      useNativeDriver: true,
    }),
  ]),
]).start();</code></pre>
            </section>

            <section id="common-patterns">
                <h2>Common Animation Patterns</h2>

                <p>Here are production-ready implementations of the most common animations.</p>

                <h3>Pattern: Fade In</h3>

<pre><code class="language-typescript">function FadeIn({ 
  children, 
  duration = 300, 
  delay = 0 
}: { 
  children: ReactNode; 
  duration?: number; 
  delay?: number;
}) {
  const opacity = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(opacity, {
      toValue: 1,
      duration,
      delay,
      useNativeDriver: true,
    }).start();
  }, []);
  
  return (
    &lt;Animated.View style={{ opacity }}&gt;
      {children}
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Pattern: Slide In</h3>

<pre><code class="language-typescript">type Direction = 'left' | 'right' | 'up' | 'down';

function SlideIn({ 
  children, 
  direction = 'up',
  distance = 50,
}: { 
  children: ReactNode; 
  direction?: Direction;
  distance?: number;
}) {
  const animValue = useRef(new Animated.Value(0)).current;
  
  const getTransform = () => {
    const axis = direction === 'left' || direction === 'right' 
      ? 'translateX' 
      : 'translateY';
    const start = direction === 'right' || direction === 'down' 
      ? distance 
      : -distance;
    
    return {
      [axis]: animValue.interpolate({
        inputRange: [0, 1],
        outputRange: [start, 0],
      }),
    };
  };
  
  useEffect(() => {
    Animated.spring(animValue, {
      toValue: 1,
      useNativeDriver: true,
    }).start();
  }, []);
  
  return (
    &lt;Animated.View
      style={{
        opacity: animValue,
        transform: [getTransform()],
      }}
    &gt;
      {children}
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Pattern: Scale Press Feedback</h3>

<pre><code class="language-typescript">function ScaleButton({ onPress, children }) {
  const scale = useRef(new Animated.Value(1)).current;
  
  const handlePressIn = () => {
    Animated.spring(scale, {
      toValue: 0.95,
      useNativeDriver: true,
    }).start();
  };
  
  const handlePressOut = () => {
    Animated.spring(scale, {
      toValue: 1,
      friction: 3,
      tension: 40,
      useNativeDriver: true,
    }).start();
  };
  
  return (
    &lt;Pressable
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      onPress={onPress}
    &gt;
      &lt;Animated.View style={{ transform: [{ scale }] }}&gt;
        {children}
      &lt;/Animated.View&gt;
    &lt;/Pressable&gt;
  );
}</code></pre>

                <h3>Pattern: Shake Animation</h3>

<pre><code class="language-typescript">function useShake() {
  const shakeAnim = useRef(new Animated.Value(0)).current;
  
  const shake = () => {
    Animated.sequence([
      Animated.timing(shakeAnim, { toValue: 10, duration: 50, useNativeDriver: true }),
      Animated.timing(shakeAnim, { toValue: -10, duration: 50, useNativeDriver: true }),
      Animated.timing(shakeAnim, { toValue: 10, duration: 50, useNativeDriver: true }),
      Animated.timing(shakeAnim, { toValue: -10, duration: 50, useNativeDriver: true }),
      Animated.timing(shakeAnim, { toValue: 0, duration: 50, useNativeDriver: true }),
    ]).start();
  };
  
  return { 
    shakeStyle: { transform: [{ translateX: shakeAnim }] }, 
    shake 
  };
}

// Usage
function ShakingInput() {
  const { shakeStyle, shake } = useShake();
  
  const handleError = () => {
    shake(); // Shake on validation error
  };
  
  return (
    &lt;Animated.View style={shakeStyle}&gt;
      &lt;TextInput /&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Pattern: Pulse Animation</h3>

<pre><code class="language-typescript">function PulsingDot() {
  const scale = useRef(new Animated.Value(1)).current;
  const opacity = useRef(new Animated.Value(1)).current;
  
  useEffect(() => {
    const animation = Animated.loop(
      Animated.parallel([
        Animated.sequence([
          Animated.timing(scale, {
            toValue: 1.5,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(scale, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true,
          }),
        ]),
        Animated.sequence([
          Animated.timing(opacity, {
            toValue: 0.5,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(opacity, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true,
          }),
        ]),
      ])
    );
    
    animation.start();
    return () => animation.stop();
  }, []);
  
  return (
    &lt;Animated.View
      style={[
        styles.dot,
        { transform: [{ scale }], opacity },
      ]}
    /&gt;
  );
}</code></pre>

                <h3>Pattern: Expandable/Collapsible</h3>

<pre><code class="language-typescript">function Expandable({ title, children }) {
  const [expanded, setExpanded] = useState(false);
  const animation = useRef(new Animated.Value(0)).current;
  
  const toggleExpand = () => {
    Animated.timing(animation, {
      toValue: expanded ? 0 : 1,
      duration: 300,
      useNativeDriver: false, // Height animation needs JS driver
    }).start();
    setExpanded(!expanded);
  };
  
  const heightInterpolate = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 200], // Max height
  });
  
  const rotateInterpolate = animation.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '180deg'],
  });
  
  return (
    &lt;View&gt;
      &lt;Pressable onPress={toggleExpand} style={styles.header}&gt;
        &lt;Text&gt;{title}&lt;/Text&gt;
        &lt;Animated.Text style={{ transform: [{ rotate: rotateInterpolate }] }}&gt;
          ‚ñº
        &lt;/Animated.Text&gt;
      &lt;/Pressable&gt;
      
      &lt;Animated.View style={{ height: heightInterpolate, overflow: 'hidden' }}&gt;
        {children}
      &lt;/Animated.View&gt;
    &lt;/View&gt;
  );
}</code></pre>
            </section>

            <section id="performance">
                <h2>Performance Tips</h2>

                <p>Animations can make or break your app's perceived performance. Here's how to ensure smooth 60fps animations.</p>

                <h3>1. Always Use Native Driver When Possible</h3>

<pre><code class="language-typescript">// ‚úÖ Good - runs on native thread
Animated.timing(opacity, {
  toValue: 1,
  duration: 300,
  useNativeDriver: true, // 60fps guaranteed
}).start();

// ‚ö†Ô∏è Less optimal - runs on JS thread
Animated.timing(width, {
  toValue: 200,
  duration: 300,
  useNativeDriver: false, // Can drop frames if JS is busy
}).start();</code></pre>

                <h3>2. Use useRef for Animated Values</h3>

<pre><code class="language-typescript">// ‚úÖ Good - value persists across renders
const opacity = useRef(new Animated.Value(0)).current;

// ‚ùå Bad - creates new value every render
const opacity = new Animated.Value(0);</code></pre>

                <h3>3. Avoid Animating Layout Properties</h3>

<pre><code class="language-typescript">// ‚úÖ Good - use transform for movement
style={{ transform: [{ translateX: animValue }] }}

// ‚ö†Ô∏è Avoid - triggers layout recalculation
style={{ marginLeft: animValue }}

// ‚úÖ Good - use transform for size
style={{ transform: [{ scale: animValue }] }}

// ‚ö†Ô∏è Avoid - triggers layout recalculation  
style={{ width: animValue, height: animValue }}</code></pre>

                <h3>4. Clean Up Animations</h3>

<pre><code class="language-typescript">useEffect(() => {
  const animation = Animated.timing(opacity, {
    toValue: 1,
    duration: 1000,
    useNativeDriver: true,
  });
  
  animation.start();
  
  // Clean up on unmount
  return () => animation.stop();
}, []);</code></pre>

                <h3>5. Avoid Many Simultaneous Animations</h3>

<pre><code class="language-typescript">// ‚úÖ Good - single value with interpolation
const progress = useRef(new Animated.Value(0)).current;

const opacity = progress.interpolate({ inputRange: [0, 1], outputRange: [0, 1] });
const translateY = progress.interpolate({ inputRange: [0, 1], outputRange: [50, 0] });
const scale = progress.interpolate({ inputRange: [0, 1], outputRange: [0.8, 1] });

// One animation drives all properties
Animated.timing(progress, { toValue: 1, useNativeDriver: true }).start();

// ‚ö†Ô∏è Less efficient - three separate animations
Animated.parallel([
  Animated.timing(opacity, { toValue: 1, useNativeDriver: true }),
  Animated.timing(translateY, { toValue: 0, useNativeDriver: true }),
  Animated.timing(scale, { toValue: 1, useNativeDriver: true }),
]).start();</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üéØ Performance Checklist</h4>
                    <ul style="color: white;">
                        <li>‚òê Using <code>useNativeDriver: true</code> for opacity/transform</li>
                        <li>‚òê Animated values created with <code>useRef</code></li>
                        <li>‚òê Using transform instead of layout properties</li>
                        <li>‚òê Single value with interpolation when possible</li>
                        <li>‚òê Animations cleaned up on unmount</li>
                        <li>‚òê Tested on low-end devices</li>
                    </ul>
                </div>
            </section>
            <section id="useAnimatedValue">
                <h2>The useAnimatedValue Hook</h2>

                <p>React Native 0.71+ provides <code>useAnimatedValue</code>, a cleaner way to create animated values. Let's also build our own custom hooks for reusable animation patterns.</p>

                <h3>Built-in useAnimatedValue</h3>

<pre><code class="language-typescript">import { Animated, useAnimatedValue } from 'react-native';

function FadeComponent() {
  // Cleaner than useRef pattern
  const opacity = useAnimatedValue(0);
  
  useEffect(() => {
    Animated.timing(opacity, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, []);
  
  return (
    &lt;Animated.View style={{ opacity }}&gt;
      &lt;Text&gt;Fading in...&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Custom Animation Hooks</h3>

                <p>Create reusable hooks for common animation patterns:</p>

<pre><code class="language-typescript">// hooks/useAnimation.ts
import { useRef, useCallback } from 'react';
import { Animated, Easing } from 'react-native';

export function useFadeAnimation(initialValue = 0) {
  const opacity = useRef(new Animated.Value(initialValue)).current;
  
  const fadeIn = useCallback((duration = 300) => {
    return new Promise&lt;void&gt;((resolve) => {
      Animated.timing(opacity, {
        toValue: 1,
        duration,
        useNativeDriver: true,
      }).start(() => resolve());
    });
  }, [opacity]);
  
  const fadeOut = useCallback((duration = 300) => {
    return new Promise&lt;void&gt;((resolve) => {
      Animated.timing(opacity, {
        toValue: 0,
        duration,
        useNativeDriver: true,
      }).start(() => resolve());
    });
  }, [opacity]);
  
  return { opacity, fadeIn, fadeOut };
}

// Usage
function FadeExample() {
  const { opacity, fadeIn, fadeOut } = useFadeAnimation(0);
  
  const handleToggle = async () => {
    await fadeOut();
    // Do something
    await fadeIn();
  };
  
  return (
    &lt;Animated.View style={{ opacity }}&gt;
      &lt;Button title="Toggle" onPress={handleToggle} /&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>useSpringAnimation Hook</h3>

<pre><code class="language-typescript">export function useSpringAnimation(initialValue = 0) {
  const value = useRef(new Animated.Value(initialValue)).current;
  
  const springTo = useCallback((toValue: number, config = {}) => {
    return new Promise&lt;void&gt;((resolve) => {
      Animated.spring(value, {
        toValue,
        useNativeDriver: true,
        ...config,
      }).start(() => resolve());
    });
  }, [value]);
  
  const reset = useCallback(() => {
    value.setValue(initialValue);
  }, [value, initialValue]);
  
  return { value, springTo, reset };
}

// Usage for press feedback
function SpringButton({ onPress, children }) {
  const { value, springTo } = useSpringAnimation(1);
  
  return (
    &lt;Pressable
      onPressIn={() => springTo(0.95)}
      onPressOut={() => springTo(1)}
      onPress={onPress}
    >
      &lt;Animated.View style={{ transform: [{ scale: value }] }}&gt;
        {children}
      &lt;/Animated.View&gt;
    &lt;/Pressable&gt;
  );
}</code></pre>

                <h3>useEntranceAnimation Hook</h3>

<pre><code class="language-typescript">type EntranceType = 'fade' | 'slideUp' | 'slideDown' | 'slideLeft' | 'slideRight' | 'scale';

interface EntranceConfig {
  type?: EntranceType;
  duration?: number;
  delay?: number;
}

export function useEntranceAnimation({
  type = 'fade',
  duration = 400,
  delay = 0,
}: EntranceConfig = {}) {
  const animValue = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(animValue, {
      toValue: 1,
      duration,
      delay,
      useNativeDriver: true,
    }).start();
  }, []);
  
  const getStyle = () => {
    const opacity = animValue;
    
    switch (type) {
      case 'fade':
        return { opacity };
        
      case 'slideUp':
        return {
          opacity,
          transform: [{
            translateY: animValue.interpolate({
              inputRange: [0, 1],
              outputRange: [30, 0],
            }),
          }],
        };
        
      case 'slideDown':
        return {
          opacity,
          transform: [{
            translateY: animValue.interpolate({
              inputRange: [0, 1],
              outputRange: [-30, 0],
            }),
          }],
        };
        
      case 'slideLeft':
        return {
          opacity,
          transform: [{
            translateX: animValue.interpolate({
              inputRange: [0, 1],
              outputRange: [30, 0],
            }),
          }],
        };
        
      case 'slideRight':
        return {
          opacity,
          transform: [{
            translateX: animValue.interpolate({
              inputRange: [0, 1],
              outputRange: [-30, 0],
            }),
          }],
        };
        
      case 'scale':
        return {
          opacity,
          transform: [{
            scale: animValue.interpolate({
              inputRange: [0, 1],
              outputRange: [0.8, 1],
            }),
          }],
        };
        
      default:
        return { opacity };
    }
  };
  
  return getStyle();
}

// Usage
function AnimatedCard() {
  const entranceStyle = useEntranceAnimation({ 
    type: 'slideUp', 
    delay: 200 
  });
  
  return (
    &lt;Animated.View style={[styles.card, entranceStyle]}&gt;
      &lt;Text&gt;I slide up!&lt;/Text&gt;
    &lt;/Animated.View&gt;
  );
}</code></pre>

                <h3>Complete Animation Hook Library</h3>

<pre><code class="language-typescript">// hooks/animations/index.ts
export { useFadeAnimation } from './useFadeAnimation';
export { useSpringAnimation } from './useSpringAnimation';
export { useEntranceAnimation } from './useEntranceAnimation';
export { useShakeAnimation } from './useShakeAnimation';
export { usePulseAnimation } from './usePulseAnimation';

// Example implementations for the others:

export function useShakeAnimation() {
  const translateX = useRef(new Animated.Value(0)).current;
  
  const shake = useCallback(() => {
    Animated.sequence([
      Animated.timing(translateX, { toValue: 10, duration: 50, useNativeDriver: true }),
      Animated.timing(translateX, { toValue: -10, duration: 50, useNativeDriver: true }),
      Animated.timing(translateX, { toValue: 10, duration: 50, useNativeDriver: true }),
      Animated.timing(translateX, { toValue: -10, duration: 50, useNativeDriver: true }),
      Animated.timing(translateX, { toValue: 0, duration: 50, useNativeDriver: true }),
    ]).start();
  }, [translateX]);
  
  return {
    style: { transform: [{ translateX }] },
    shake,
  };
}

export function usePulseAnimation(active = true) {
  const scale = useRef(new Animated.Value(1)).current;
  const animationRef = useRef&lt;Animated.CompositeAnimation&gt;();
  
  useEffect(() => {
    if (active) {
      animationRef.current = Animated.loop(
        Animated.sequence([
          Animated.timing(scale, {
            toValue: 1.1,
            duration: 500,
            useNativeDriver: true,
          }),
          Animated.timing(scale, {
            toValue: 1,
            duration: 500,
            useNativeDriver: true,
          }),
        ])
      );
      animationRef.current.start();
    } else {
      animationRef.current?.stop();
      scale.setValue(1);
    }
    
    return () => animationRef.current?.stop();
  }, [active, scale]);
  
  return { transform: [{ scale }] };
}</code></pre>
            </section>

            <section id="hands-on">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-container">
                    <h3>Exercise 1: Animated Button with Press Feedback</h3>
                    <p>Create a button that scales down when pressed and springs back when released.</p>

                    <details>
                        <summary>Show Solution</summary>
<pre><code class="language-typescript">import { useRef } from 'react';
import { Animated, Pressable, Text, StyleSheet } from 'react-native';

function AnimatedButton({ title, onPress }) {
  const scale = useRef(new Animated.Value(1)).current;
  
  const handlePressIn = () => {
    Animated.spring(scale, {
      toValue: 0.92,
      useNativeDriver: true,
    }).start();
  };
  
  const handlePressOut = () => {
    Animated.spring(scale, {
      toValue: 1,
      friction: 3,
      useNativeDriver: true,
    }).start();
  };
  
  return (
    &lt;Pressable
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      onPress={onPress}
    &gt;
      &lt;Animated.View 
        style={[
          styles.button,
          { transform: [{ scale }] }
        ]}
      &gt;
        &lt;Text style={styles.buttonText}&gt;{title}&lt;/Text&gt;
      &lt;/Animated.View&gt;
    &lt;/Pressable&gt;
  );
}

const styles = StyleSheet.create({
  button: {
    backgroundColor: '#2196F3',
    paddingVertical: 14,
    paddingHorizontal: 28,
    borderRadius: 8,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-container">
                    <h3>Exercise 2: Staggered List Animation</h3>
                    <p>Create a list where items fade in and slide up one after another with a 100ms delay between each.</p>

                    <details>
                        <summary>Show Solution</summary>
<pre><code class="language-typescript">import { useRef, useEffect } from 'react';
import { Animated, View, Text, StyleSheet } from 'react-native';

interface Item {
  id: string;
  title: string;
}

function StaggeredList({ items }: { items: Item[] }) {
  const animatedValues = useRef(
    items.map(() => new Animated.Value(0))
  ).current;
  
  useEffect(() => {
    const animations = animatedValues.map((anim) =>
      Animated.timing(anim, {
        toValue: 1,
        duration: 400,
        useNativeDriver: true,
      })
    );
    
    Animated.stagger(100, animations).start();
  }, []);
  
  return (
    &lt;View style={styles.list}&gt;
      {items.map((item, index) =&gt; {
        const opacity = animatedValues[index];
        const translateY = animatedValues[index].interpolate({
          inputRange: [0, 1],
          outputRange: [30, 0],
        });
        
        return (
          &lt;Animated.View
            key={item.id}
            style={[
              styles.item,
              {
                opacity,
                transform: [{ translateY }],
              },
            ]}
          &gt;
            &lt;Text style={styles.itemText}&gt;{item.title}&lt;/Text&gt;
          &lt;/Animated.View&gt;
        );
      })}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  list: {
    padding: 16,
  },
  item: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  itemText: {
    fontSize: 16,
    color: '#333',
  },
});</code></pre>
                    </details>
                </div>

                <div class="exercise-container">
                    <h3>Exercise 3: Loading Spinner</h3>
                    <p>Create a continuously rotating loading spinner using Animated.loop.</p>

                    <details>
                        <summary>Show Solution</summary>
<pre><code class="language-typescript">import { useRef, useEffect } from 'react';
import { Animated, Easing, View, StyleSheet } from 'react-native';

function LoadingSpinner({ size = 40, color = '#2196F3' }) {
  const rotation = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    const animation = Animated.loop(
      Animated.timing(rotation, {
        toValue: 1,
        duration: 1000,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    );
    
    animation.start();
    
    return () => animation.stop();
  }, [rotation]);
  
  const rotate = rotation.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  
  return (
    &lt;Animated.View
      style={[
        styles.spinner,
        {
          width: size,
          height: size,
          borderColor: color,
          borderTopColor: 'transparent',
          transform: [{ rotate }],
        },
      ]}
    /&gt;
  );
}

const styles = StyleSheet.create({
  spinner: {
    borderWidth: 3,
    borderRadius: 100,
  },
});

// Usage
function LoadingScreen() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;LoadingSpinner size={50} color="#6200EE" /&gt;
      &lt;Text style={styles.text}&gt;Loading...&lt;/Text&gt;
    &lt;/View&gt;
  );
}</code></pre>
                    </details>
                </div>
            </section>

            <section id="summary">
                <h2>Summary</h2>

                <p>You now have a solid foundation in React Native animations. These techniques cover the vast majority of animation needs in production apps.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>Animated.Value</strong> stores numeric values that change over time</li>
                        <li><strong>timing()</strong> for precise, timed animations with easing</li>
                        <li><strong>spring()</strong> for natural, physics-based motion</li>
                        <li><strong>interpolate()</strong> transforms one value into multiple outputs</li>
                        <li><strong>parallel/sequence/stagger</strong> compose multiple animations</li>
                        <li><strong>useNativeDriver: true</strong> is essential for 60fps performance</li>
                        <li><strong>Custom hooks</strong> make animations reusable across components</li>
                    </ul>
                </div>

                <h3>Quick Reference</h3>

<pre><code class="language-typescript">import { Animated, Easing } from 'react-native';

// Create value (in component)
const anim = useRef(new Animated.Value(0)).current;

// Timing animation
Animated.timing(anim, {
  toValue: 1,
  duration: 300,
  easing: Easing.ease,
  useNativeDriver: true,
}).start();

// Spring animation
Animated.spring(anim, {
  toValue: 1,
  friction: 7,
  tension: 40,
  useNativeDriver: true,
}).start();

// Interpolation
const opacity = anim.interpolate({
  inputRange: [0, 1],
  outputRange: [0, 1],
});

// Composition
Animated.parallel([anim1, anim2]).start();
Animated.sequence([anim1, anim2]).start();
Animated.stagger(100, [anim1, anim2, anim3]).start();
Animated.loop(animation).start();

// Usage
&lt;Animated.View style={{ opacity, transform: [{ scale: anim }] }}&gt;</code></pre>

                <h3>When to Use What</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background: #e3f2fd;">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">Scenario</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #2196F3;">Recommended Approach</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;">Fade in/out</td>
                            <td style="padding: 12px;"><code>timing</code> with 200-300ms</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;">Button press</td>
                            <td style="padding: 12px;"><code>spring</code> with scale transform</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;">Modal/sheet appear</td>
                            <td style="padding: 12px;"><code>spring</code> for natural feel</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;">List items entering</td>
                            <td style="padding: 12px;"><code>stagger</code> + <code>spring</code></td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 12px;">Loading spinner</td>
                            <td style="padding: 12px;"><code>loop</code> + <code>timing</code> (linear)</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px;">Error shake</td>
                            <td style="padding: 12px;"><code>sequence</code> of quick <code>timing</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Coming Up Next</h3>

                <p>In the next lesson, we'll explore <strong>Theming and Dark Mode</strong>. You'll learn how to create a complete theming system and support light/dark mode throughout your app.</p>
            </section>

            <nav class="lesson-nav">
                <a href="m04_l05_platform_specific_styles.html" class="prev-link">‚Üê Previous: Platform-Specific Styles</a>
                <a href="index.html" class="home-link">Course Home</a>
                <a href="m04_l07_theming_and_dark_mode.html" class="next-link">Next: Theming and Dark Mode ‚Üí</a>
            </nav>
        </article>
    </main>

    <footer class="main-footer">
        <div class="container">
            <p>React Native & Expo Course ¬© 2025</p>
        </div>
    </footer>

    <script>
        const toggle = document.getElementById('mobile-menu-toggle');
        const navLinks = document.getElementById('nav-links');
        
        toggle?.addEventListener('click', () => {
            const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
            toggle.setAttribute('aria-expanded', !isExpanded);
            navLinks?.classList.toggle('active');
        });

        document.querySelectorAll('.toc-nav a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').slice(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                    const toc = document.getElementById('toc');
                    if (toc && window.innerWidth < 768) {
                        toc.removeAttribute('open');
                    }
                }
            });
        });
    </script>
</body>
</html>
