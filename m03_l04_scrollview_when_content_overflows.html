<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn how to use ScrollView in React Native to handle content that exceeds screen boundaries">
    <meta name="author" content="React Native Course">
    <title>ScrollView: When Content Overflows - React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#e3f2fd',
                primaryTextColor: '#1565c0',
                primaryBorderColor: '#1976d2',
                lineColor: '#64b5f6'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN & Expo Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 3</a></li>
            <li aria-current="page">Lesson 3.4: ScrollView ‚Äî When Content Overflows</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üìú ScrollView: When Content Overflows</h1>
                <p class="lead" style="text-align: center; font-size: 1.1rem; margin-bottom: 2rem;">
                    Making content scrollable when it exceeds the screen
                </p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand why View doesn't scroll and when to use ScrollView</li>
                        <li>Implement vertical and horizontal scrolling</li>
                        <li>Configure scroll behavior with key props</li>
                        <li>Handle scroll events programmatically</li>
                        <li>Build common UI patterns like pull-to-refresh</li>
                        <li>Recognize when ScrollView is NOT the right choice</li>
                    </ul>
                    <p><strong>‚è±Ô∏è Estimated Time:</strong> 25-35 minutes</p>
                </div>
            </header>

            <!-- Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--secondary-color); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    üìë In This Lesson
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#why-scrollview">Why ScrollView?</a></li>
                        <li><a href="#basic-usage">Basic Usage</a></li>
                        <li><a href="#horizontal-scroll">Horizontal Scrolling</a></li>
                        <li><a href="#key-props">Key Props</a></li>
                        <li><a href="#scroll-events">Scroll Events</a></li>
                        <li><a href="#pull-to-refresh">Pull-to-Refresh</a></li>
                        <li><a href="#keyboard-handling">Keyboard Handling</a></li>
                        <li><a href="#when-not-to-use">When NOT to Use ScrollView</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Why ScrollView -->
            <section id="why-scrollview" class="lesson-section">
                <h2>Why ScrollView?</h2>
                
                <p>In React Native, <code>View</code> components don't scroll. If content exceeds the container's bounds, it simply gets clipped ‚Äî users can't see it, and there's no way to scroll to it.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Key Difference from Web</h4>
                    <p style="color: white;">On the web, you can make any element scrollable with <code>overflow: scroll</code>. In React Native, scrolling requires a dedicated component ‚Äî <code>ScrollView</code>.</p>
                </div>

                <h3>The Problem</h3>

                <pre><code class="language-tsx">// ‚ùå Content is clipped, not scrollable
&lt;View style={{ height: 300 }}&gt;
  &lt;Text&gt;Paragraph 1...&lt;/Text&gt;
  &lt;Text&gt;Paragraph 2...&lt;/Text&gt;
  &lt;Text&gt;Paragraph 3...&lt;/Text&gt;
  {/* If this exceeds 300px, users can't see the rest! */}
&lt;/View&gt;</code></pre>

                <h3>The Solution</h3>

                <pre><code class="language-tsx">// ‚úÖ Content scrolls when it exceeds bounds
&lt;ScrollView style={{ height: 300 }}&gt;
  &lt;Text&gt;Paragraph 1...&lt;/Text&gt;
  &lt;Text&gt;Paragraph 2...&lt;/Text&gt;
  &lt;Text&gt;Paragraph 3...&lt;/Text&gt;
  {/* Users can scroll to see all content */}
&lt;/ScrollView&gt;</code></pre>

                <!-- SVG: View vs ScrollView -->
                <svg viewBox="0 0 700 280" style="width: 100%; max-width: 700px; margin: 2rem auto; display: block;">
                    <!-- Background -->
                    <rect x="0" y="0" width="700" height="280" fill="#f8f9fa" rx="10"/>
                    
                    <!-- Title -->
                    <text x="350" y="30" text-anchor="middle" font-weight="bold" font-size="16" fill="#333">View vs ScrollView</text>
                    
                    <!-- View example -->
                    <g transform="translate(100, 50)">
                        <text x="75" y="0" text-anchor="middle" font-weight="bold" font-size="13" fill="#f44336">View (No Scroll)</text>
                        
                        <!-- Container outline -->
                        <rect x="0" y="15" width="150" height="180" rx="8" fill="none" stroke="#f44336" stroke-width="2" stroke-dasharray="5,5"/>
                        
                        <!-- Visible content -->
                        <rect x="10" y="25" width="130" height="35" rx="4" fill="#ffcdd2"/>
                        <text x="75" y="48" text-anchor="middle" font-size="11" fill="#c62828">Item 1 ‚úì</text>
                        
                        <rect x="10" y="65" width="130" height="35" rx="4" fill="#ffcdd2"/>
                        <text x="75" y="88" text-anchor="middle" font-size="11" fill="#c62828">Item 2 ‚úì</text>
                        
                        <rect x="10" y="105" width="130" height="35" rx="4" fill="#ffcdd2"/>
                        <text x="75" y="128" text-anchor="middle" font-size="11" fill="#c62828">Item 3 ‚úì</text>
                        
                        <!-- Clipped content indicator -->
                        <rect x="10" y="145" width="130" height="35" rx="4" fill="#ffcdd2" opacity="0.3"/>
                        <text x="75" y="168" text-anchor="middle" font-size="11" fill="#c62828" opacity="0.5">Item 4 ‚úó (clipped)</text>
                        
                        <text x="75" y="215" text-anchor="middle" font-size="10" fill="#666">Content cut off!</text>
                    </g>
                    
                    <!-- ScrollView example -->
                    <g transform="translate(400, 50)">
                        <text x="75" y="0" text-anchor="middle" font-weight="bold" font-size="13" fill="#4caf50">ScrollView</text>
                        
                        <!-- Container outline -->
                        <rect x="0" y="15" width="150" height="180" rx="8" fill="none" stroke="#4caf50" stroke-width="2"/>
                        
                        <!-- Visible content -->
                        <rect x="10" y="25" width="130" height="35" rx="4" fill="#c8e6c9"/>
                        <text x="75" y="48" text-anchor="middle" font-size="11" fill="#2e7d32">Item 1 ‚úì</text>
                        
                        <rect x="10" y="65" width="130" height="35" rx="4" fill="#c8e6c9"/>
                        <text x="75" y="88" text-anchor="middle" font-size="11" fill="#2e7d32">Item 2 ‚úì</text>
                        
                        <rect x="10" y="105" width="130" height="35" rx="4" fill="#c8e6c9"/>
                        <text x="75" y="128" text-anchor="middle" font-size="11" fill="#2e7d32">Item 3 ‚úì</text>
                        
                        <rect x="10" y="145" width="130" height="35" rx="4" fill="#c8e6c9"/>
                        <text x="75" y="168" text-anchor="middle" font-size="11" fill="#2e7d32">Item 4 ‚úì</text>
                        
                        <!-- Scroll indicator -->
                        <rect x="155" y="30" width="6" height="50" rx="3" fill="#81c784"/>
                        
                        <text x="75" y="215" text-anchor="middle" font-size="10" fill="#666">Scroll to see all ‚Üï</text>
                    </g>
                </svg>
                <p class="caption"><em>View clips overflow content; ScrollView makes it accessible through scrolling</em></p>

                <h3>What ScrollView Does</h3>

                <p>ScrollView creates a scrollable container that:</p>

                <ul>
                    <li>Renders all its children immediately</li>
                    <li>Allows users to scroll vertically (default) or horizontally</li>
                    <li>Bounces at the edges (iOS) for a native feel</li>
                    <li>Supports momentum scrolling</li>
                    <li>Can respond to scroll events programmatically</li>
                </ul>

            </section>

            <!-- Section 2: Basic Usage -->
            <section id="basic-usage" class="lesson-section">
                <h2>Basic Usage</h2>

                <p>Using ScrollView is straightforward ‚Äî wrap your content and you're scrolling:</p>

                <pre><code class="language-tsx">import { ScrollView, View, Text, StyleSheet } from 'react-native';

export default function ArticleScreen() {
  return (
    &lt;ScrollView style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Article Title&lt;/Text&gt;
      &lt;Text style={styles.body}&gt;
        {longArticleText}
      &lt;/Text&gt;
      &lt;View style={styles.spacer} /&gt;
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    padding: 16,
  },
  body: {
    fontSize: 16,
    lineHeight: 24,
    padding: 16,
  },
  spacer: {
    height: 40,  // Extra space at bottom
  },
});</code></pre>

                <h3>style vs contentContainerStyle</h3>

                <p>ScrollView has two style props that serve different purposes:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Prop</th>
                            <th>What It Styles</th>
                            <th>Common Uses</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>style</code></td>
                            <td>The ScrollView container itself</td>
                            <td>Background color, flex, margins</td>
                        </tr>
                        <tr>
                            <td><code>contentContainerStyle</code></td>
                            <td>The inner content wrapper</td>
                            <td>Padding, alignment, gap</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-tsx">&lt;ScrollView 
  style={styles.scrollView}           // Outer container
  contentContainerStyle={styles.content}  // Inner content
&gt;
  {children}
&lt;/ScrollView&gt;

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    padding: 20,
    gap: 16,
    // For centering content vertically when it's shorter than screen:
    // flexGrow: 1,
    // justifyContent: 'center',
  },
});</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake: flex: 1 on contentContainerStyle</h4>
                    <p>Don't use <code>flex: 1</code> on contentContainerStyle ‚Äî it can prevent scrolling by collapsing the content height. Use <code>flexGrow: 1</code> instead if you need the content to expand:</p>
                    <pre><code class="language-tsx">// ‚ùå Can break scrolling
contentContainerStyle={{ flex: 1 }}

// ‚úÖ Allows content to grow but still scroll
contentContainerStyle={{ flexGrow: 1 }}</code></pre>
                </div>

                <!-- SVG: style vs contentContainerStyle -->
                <svg viewBox="0 0 600 220" style="width: 100%; max-width: 600px; margin: 2rem auto; display: block;">
                    <!-- Background -->
                    <rect x="0" y="0" width="600" height="220" fill="#f8f9fa" rx="10"/>
                    
                    <!-- Title -->
                    <text x="300" y="25" text-anchor="middle" font-weight="bold" font-size="14" fill="#333">style vs contentContainerStyle</text>
                    
                    <!-- Outer container (style) -->
                    <rect x="150" y="45" width="300" height="160" rx="10" fill="none" stroke="#2196F3" stroke-width="3"/>
                    <text x="165" y="65" font-size="11" fill="#1565c0" font-weight="bold">style</text>
                    <text x="165" y="80" font-size="9" fill="#666">backgroundColor, flex</text>
                    
                    <!-- Inner container (contentContainerStyle) -->
                    <rect x="170" y="90" width="260" height="100" rx="6" fill="none" stroke="#4caf50" stroke-width="2" stroke-dasharray="5,5"/>
                    <text x="185" y="108" font-size="11" fill="#2e7d32" font-weight="bold">contentContainerStyle</text>
                    <text x="185" y="123" font-size="9" fill="#666">padding, gap, alignItems</text>
                    
                    <!-- Content blocks -->
                    <rect x="190" y="135" width="100" height="20" rx="3" fill="#e0e0e0"/>
                    <rect x="190" y="160" width="80" height="20" rx="3" fill="#e0e0e0"/>
                    
                    <!-- Scroll indicator -->
                    <rect x="435" y="95" width="6" height="40" rx="3" fill="#bdbdbd"/>
                    
                    <!-- Labels -->
                    <line x1="460" y1="75" x2="500" y2="55" stroke="#2196F3" stroke-width="1"/>
                    <text x="505" y="55" font-size="10" fill="#1565c0">ScrollView frame</text>
                    
                    <line x1="435" y1="170" x2="500" y2="180" stroke="#4caf50" stroke-width="1"/>
                    <text x="505" y="185" font-size="10" fill="#2e7d32">Content wrapper</text>
                </svg>
                <p class="caption"><em>style affects the outer frame; contentContainerStyle affects the scrollable content area</em></p>

            </section>

            <!-- Section 3: Horizontal Scrolling -->
            <section id="horizontal-scroll" class="lesson-section">
                <h2>Horizontal Scrolling</h2>

                <p>By default, ScrollView scrolls vertically. Add the <code>horizontal</code> prop for horizontal scrolling:</p>

                <pre><code class="language-tsx">import { ScrollView, View, Text, StyleSheet } from 'react-native';

function CategoryPills({ categories }) {
  return (
    &lt;ScrollView 
      horizontal
      showsHorizontalScrollIndicator={false}
      contentContainerStyle={styles.pillContainer}
    &gt;
      {categories.map((category) => (
        &lt;View key={category.id} style={styles.pill}&gt;
          &lt;Text style={styles.pillText}&gt;{category.name}&lt;/Text&gt;
        &lt;/View&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  pillContainer: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    gap: 8,
  },
  pill: {
    backgroundColor: '#e3f2fd',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
  },
  pillText: {
    color: '#1976d2',
    fontWeight: '500',
  },
});</code></pre>

                <h3>Horizontal Image Gallery</h3>

                <pre><code class="language-tsx">function ImageGallery({ images }) {
  return (
    &lt;ScrollView 
      horizontal
      pagingEnabled  // Snap to each image
      showsHorizontalScrollIndicator={false}
    &gt;
      {images.map((image, index) => (
        &lt;Image 
          key={index}
          source={{ uri: image.url }}
          style={styles.galleryImage}
          resizeMode="cover"
        /&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  galleryImage: {
    width: Dimensions.get('window').width,  // Full screen width
    height: 300,
  },
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: pagingEnabled</h4>
                    <p>Use <code>pagingEnabled</code> to create a carousel or paging effect. The ScrollView will snap to multiples of its width, making each "page" stop exactly in view.</p>
                </div>

                <h3>Horizontal + Vertical Scrolling</h3>

                <p>You can nest ScrollViews for both directions:</p>

                <pre><code class="language-tsx">// Vertical main scroll, with horizontal rows inside
&lt;ScrollView style={styles.container}&gt;
  &lt;Text style={styles.sectionTitle}&gt;Trending&lt;/Text&gt;
  &lt;ScrollView horizontal showsHorizontalScrollIndicator={false}&gt;
    {trendingItems.map(item => &lt;Card key={item.id} {...item} /&gt;)}
  &lt;/ScrollView&gt;
  
  &lt;Text style={styles.sectionTitle}&gt;New Releases&lt;/Text&gt;
  &lt;ScrollView horizontal showsHorizontalScrollIndicator={false}&gt;
    {newReleases.map(item => &lt;Card key={item.id} {...item} /&gt;)}
  &lt;/ScrollView&gt;
&lt;/ScrollView&gt;</code></pre>

            </section>

            <!-- Section 4: Key Props -->
            <section id="key-props" class="lesson-section">
                <h2>Key Props</h2>

                <p>ScrollView has many props to customize its behavior. Here are the most important ones:</p>

                <h3>Scroll Behavior Props</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Prop</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>horizontal</code></td>
                            <td>boolean</td>
                            <td>Scroll horizontally instead of vertically</td>
                        </tr>
                        <tr>
                            <td><code>pagingEnabled</code></td>
                            <td>boolean</td>
                            <td>Snap to pages (multiples of scroll view size)</td>
                        </tr>
                        <tr>
                            <td><code>scrollEnabled</code></td>
                            <td>boolean</td>
                            <td>Enable/disable scrolling (default: true)</td>
                        </tr>
                        <tr>
                            <td><code>bounces</code></td>
                            <td>boolean</td>
                            <td>iOS: Bounce at edges (default: true)</td>
                        </tr>
                        <tr>
                            <td><code>overScrollMode</code></td>
                            <td>string</td>
                            <td>Android: 'auto', 'always', 'never'</td>
                        </tr>
                        <tr>
                            <td><code>scrollEventThrottle</code></td>
                            <td>number</td>
                            <td>How often onScroll fires (ms)</td>
                        </tr>
                        <tr>
                            <td><code>decelerationRate</code></td>
                            <td>'normal' | 'fast' | number</td>
                            <td>How quickly scrolling decelerates</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Visual Props</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Prop</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>showsVerticalScrollIndicator</code></td>
                            <td>boolean</td>
                            <td>Show vertical scrollbar (default: true)</td>
                        </tr>
                        <tr>
                            <td><code>showsHorizontalScrollIndicator</code></td>
                            <td>boolean</td>
                            <td>Show horizontal scrollbar (default: true)</td>
                        </tr>
                        <tr>
                            <td><code>indicatorStyle</code></td>
                            <td>'default' | 'black' | 'white'</td>
                            <td>iOS: Scrollbar color</td>
                        </tr>
                        <tr>
                            <td><code>contentInset</code></td>
                            <td>object</td>
                            <td>iOS: Inset from edges {top, left, bottom, right}</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Configurations</h3>

                <pre><code class="language-tsx">// Standard vertical scroll (article, settings)
&lt;ScrollView
  style={{ flex: 1 }}
  contentContainerStyle={{ padding: 16 }}
  showsVerticalScrollIndicator={true}
&gt;

// Horizontal carousel with paging
&lt;ScrollView
  horizontal
  pagingEnabled
  showsHorizontalScrollIndicator={false}
  decelerationRate="fast"
&gt;

// Modal content with bounce disabled
&lt;ScrollView
  bounces={false}
  showsVerticalScrollIndicator={false}
  contentContainerStyle={{ padding: 20 }}
&gt;

// Form with keyboard handling
&lt;ScrollView
  keyboardShouldPersistTaps="handled"
  keyboardDismissMode="on-drag"
  contentContainerStyle={{ padding: 16 }}
&gt;</code></pre>

            </section>

            <!-- Section 5: Scroll Events -->
            <section id="scroll-events" class="lesson-section">
                <h2>Scroll Events</h2>

                <p>ScrollView provides callbacks to respond to scroll actions. This enables features like scroll-based animations, lazy loading, and scroll position tracking.</p>

                <h3>Basic onScroll</h3>

                <pre><code class="language-tsx">import { ScrollView, NativeSyntheticEvent, NativeScrollEvent } from 'react-native';

function ScrollTracker() {
  const handleScroll = (event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) => {
    const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent;
    
    console.log('Scroll position:', contentOffset.y);
    console.log('Content height:', contentSize.height);
    console.log('Visible height:', layoutMeasurement.height);
    
    // Calculate scroll percentage
    const scrollPercentage = 
      contentOffset.y / (contentSize.height - layoutMeasurement.height);
    console.log('Scroll %:', Math.round(scrollPercentage * 100));
  };

  return (
    &lt;ScrollView 
      onScroll={handleScroll}
      scrollEventThrottle={16}  // ~60fps for smooth tracking
    &gt;
      {/* Content */}
    &lt;/ScrollView&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° scrollEventThrottle</h4>
                    <p>The <code>scrollEventThrottle</code> prop controls how often <code>onScroll</code> fires. Lower values = more frequent updates:</p>
                    <ul>
                        <li><strong>16ms</strong> ‚Äî ~60fps, smoothest but most CPU intensive</li>
                        <li><strong>100ms</strong> ‚Äî Good balance for most use cases</li>
                        <li><strong>Not set</strong> ‚Äî Only fires once at end of scroll (iOS)</li>
                    </ul>
                </div>

                <h3>Scroll Event Data</h3>

                <p>The scroll event provides these useful values:</p>

                <pre><code class="language-tsx">event.nativeEvent = {
  contentOffset: {
    x: number,  // Horizontal scroll position
    y: number,  // Vertical scroll position
  },
  contentSize: {
    width: number,   // Total content width
    height: number,  // Total content height
  },
  layoutMeasurement: {
    width: number,   // Visible viewport width
    height: number,  // Visible viewport height
  },
  // Plus velocity, zoomScale, etc.
}</code></pre>

                <!-- SVG: Scroll event visualization -->
                <svg viewBox="0 0 500 300" style="width: 100%; max-width: 500px; margin: 2rem auto; display: block;">
                    <!-- Background -->
                    <rect x="0" y="0" width="500" height="300" fill="#f8f9fa" rx="10"/>
                    
                    <!-- Title -->
                    <text x="250" y="25" text-anchor="middle" font-weight="bold" font-size="14" fill="#333">Scroll Event Values</text>
                    
                    <!-- Full content area -->
                    <rect x="150" y="45" width="150" height="240" rx="5" fill="#fff3e0" stroke="#ff9800" stroke-width="1"/>
                    <text x="225" y="280" text-anchor="middle" font-size="10" fill="#e65100">contentSize.height</text>
                    
                    <!-- Viewport -->
                    <rect x="150" y="95" width="150" height="100" rx="0" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
                    <text x="225" y="150" text-anchor="middle" font-size="11" fill="#1565c0">Viewport</text>
                    <text x="225" y="165" text-anchor="middle" font-size="9" fill="#666">layoutMeasurement.height</text>
                    
                    <!-- Content offset arrow -->
                    <line x1="130" y1="45" x2="130" y2="95" stroke="#4caf50" stroke-width="2" marker-end="url(#arrowGreen)"/>
                    <defs>
                        <marker id="arrowGreen" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#4caf50"/>
                        </marker>
                    </defs>
                    <text x="80" y="75" font-size="10" fill="#2e7d32">contentOffset.y</text>
                    
                    <!-- Labels -->
                    <rect x="320" y="60" width="160" height="80" rx="5" fill="#fff" stroke="#ddd"/>
                    <text x="330" y="80" font-size="10" fill="#333" font-weight="bold">event.nativeEvent:</text>
                    <text x="330" y="100" font-size="9" fill="#666">‚Ä¢ contentOffset.y = 50</text>
                    <text x="330" y="115" font-size="9" fill="#666">‚Ä¢ contentSize.height = 240</text>
                    <text x="330" y="130" font-size="9" fill="#666">‚Ä¢ layoutMeasurement = 100</text>
                </svg>
                <p class="caption"><em>Scroll events provide position, content size, and viewport measurements</em></p>

                <h3>Other Scroll Callbacks</h3>

                <pre><code class="language-tsx">&lt;ScrollView
  // Fired when scrolling starts
  onScrollBeginDrag={() => console.log('Started scrolling')}
  
  // Fired when user lifts finger (momentum may continue)
  onScrollEndDrag={() => console.log('Finger lifted')}
  
  // Fired when scroll completely stops (including momentum)
  onMomentumScrollEnd={() => console.log('Scroll finished')}
  
  // Fired when momentum scrolling begins
  onMomentumScrollBegin={() => console.log('Momentum started')}
&gt;</code></pre>

                <h3>Programmatic Scrolling</h3>

                <p>You can scroll to specific positions using refs:</p>

                <pre><code class="language-tsx">import { useRef } from 'react';
import { ScrollView, Button, View } from 'react-native';

function ScrollableContent() {
  const scrollViewRef = useRef&lt;ScrollView&gt;(null);

  const scrollToTop = () => {
    scrollViewRef.current?.scrollTo({ y: 0, animated: true });
  };

  const scrollToBottom = () => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  };

  const scrollToPosition = () => {
    scrollViewRef.current?.scrollTo({ y: 500, animated: true });
  };

  return (
    &lt;View style={{ flex: 1 }}&gt;
      &lt;View style={styles.buttons}&gt;
        &lt;Button title="Top" onPress={scrollToTop} /&gt;
        &lt;Button title="Bottom" onPress={scrollToBottom} /&gt;
      &lt;/View&gt;
      
      &lt;ScrollView ref={scrollViewRef}&gt;
        {/* Long content */}
      &lt;/ScrollView&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>Detecting End of Scroll</h3>

                <p>Useful for infinite scrolling or "load more" patterns:</p>

                <pre><code class="language-tsx">const isCloseToBottom = ({ layoutMeasurement, contentOffset, contentSize }) => {
  const paddingToBottom = 20;
  return layoutMeasurement.height + contentOffset.y >= 
         contentSize.height - paddingToBottom;
};

&lt;ScrollView
  onScroll={({ nativeEvent }) => {
    if (isCloseToBottom(nativeEvent)) {
      console.log('Near bottom - load more!');
      loadMoreContent();
    }
  }}
  scrollEventThrottle={400}
&gt;</code></pre>

            </section>

            <!-- Section 6: Pull-to-Refresh -->
            <section id="pull-to-refresh" class="lesson-section">
                <h2>Pull-to-Refresh</h2>

                <p>Pull-to-refresh is a common mobile pattern where users pull down at the top of a list to refresh content. ScrollView supports this natively through the <code>RefreshControl</code> component.</p>

                <h3>Basic Implementation</h3>

                <pre><code class="language-tsx">import { useState, useCallback } from 'react';
import { ScrollView, RefreshControl, Text, StyleSheet } from 'react-native';

function RefreshableList() {
  const [refreshing, setRefreshing] = useState(false);
  const [data, setData] = useState(['Item 1', 'Item 2', 'Item 3']);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Update data
      setData(prev => [`New Item ${Date.now()}`, ...prev]);
    } finally {
      setRefreshing(false);
    }
  }, []);

  return (
    &lt;ScrollView
      contentContainerStyle={styles.container}
      refreshControl={
        &lt;RefreshControl 
          refreshing={refreshing} 
          onRefresh={onRefresh}
        /&gt;
      }
    &gt;
      {data.map((item, index) => (
        &lt;Text key={index} style={styles.item}&gt;{item}&lt;/Text&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
  item: {
    padding: 16,
    backgroundColor: '#f5f5f5',
    marginBottom: 8,
    borderRadius: 8,
  },
});</code></pre>

                <h3>Customizing RefreshControl</h3>

                <pre><code class="language-tsx">&lt;RefreshControl
  refreshing={refreshing}
  onRefresh={onRefresh}
  
  // Colors
  colors={['#2196F3', '#4caf50', '#ff9800']}  // Android: rotating colors
  tintColor="#2196F3"  // iOS: spinner color
  
  // Title (iOS only)
  title="Pull to refresh"
  titleColor="#666"
  
  // Progress position (Android)
  progressBackgroundColor="#fff"
  progressViewOffset={20}
/&gt;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practices for Pull-to-Refresh</h4>
                    <ul>
                        <li>Always provide visual feedback (the spinner) during refresh</li>
                        <li>Set <code>refreshing</code> to false when done, even on error</li>
                        <li>Use <code>useCallback</code> to prevent unnecessary re-renders</li>
                        <li>Consider showing a toast or message after successful refresh</li>
                        <li>Add optimistic updates for better perceived performance</li>
                    </ul>
                </div>

            </section>

            <!-- Section 7: Keyboard Handling -->
            <section id="keyboard-handling" class="lesson-section">
                <h2>Keyboard Handling</h2>

                <p>When forms are inside a ScrollView, you need to handle the keyboard properly to ensure inputs remain visible.</p>

                <h3>keyboardDismissMode</h3>

                <p>Controls when the keyboard dismisses during scrolling:</p>

                <pre><code class="language-tsx">&lt;ScrollView 
  keyboardDismissMode="on-drag"  // Dismiss when user starts scrolling
&gt;
  {/* Form inputs */}
&lt;/ScrollView&gt;</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Value</th>
                            <th>Behavior</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>'none'</code></td>
                            <td>Keyboard stays open during scroll (default)</td>
                        </tr>
                        <tr>
                            <td><code>'on-drag'</code></td>
                            <td>Dismiss when scrolling starts</td>
                        </tr>
                        <tr>
                            <td><code>'interactive'</code></td>
                            <td>iOS: Drag down to dismiss interactively</td>
                        </tr>
                    </tbody>
                </table>

                <h3>keyboardShouldPersistTaps</h3>

                <p>Controls whether tapping outside an input dismisses the keyboard or activates the tapped element:</p>

                <pre><code class="language-tsx">&lt;ScrollView 
  keyboardShouldPersistTaps="handled"
&gt;
  &lt;TextInput placeholder="Name" /&gt;
  &lt;TextInput placeholder="Email" /&gt;
  &lt;Button title="Submit" onPress={handleSubmit} /&gt;
&lt;/ScrollView&gt;</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Value</th>
                            <th>Behavior</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>'never'</code></td>
                            <td>Tapping outside dismisses keyboard; tap is ignored (default)</td>
                        </tr>
                        <tr>
                            <td><code>'always'</code></td>
                            <td>Keyboard stays; tap activates the element</td>
                        </tr>
                        <tr>
                            <td><code>'handled'</code></td>
                            <td>If tap is on a Pressable/Button, activate it; otherwise dismiss</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Recommended for Forms</h4>
                    <p>For most forms, use this combination:</p>
                    <pre><code class="language-tsx">&lt;ScrollView
  keyboardShouldPersistTaps="handled"
  keyboardDismissMode="on-drag"
&gt;</code></pre>
                    <p>This lets users tap buttons while keyboard is open, but also dismiss by scrolling.</p>
                </div>

                <h3>KeyboardAvoidingView</h3>

                <p>For forms near the bottom of the screen, wrap ScrollView in <code>KeyboardAvoidingView</code>:</p>

                <pre><code class="language-tsx">import { KeyboardAvoidingView, ScrollView, Platform } from 'react-native';

function FormScreen() {
  return (
    &lt;KeyboardAvoidingView 
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    &gt;
      &lt;ScrollView
        contentContainerStyle={{ padding: 16 }}
        keyboardShouldPersistTaps="handled"
      &gt;
        &lt;TextInput placeholder="Field 1" /&gt;
        &lt;TextInput placeholder="Field 2" /&gt;
        &lt;TextInput placeholder="Field 3" /&gt;
        {/* More fields... */}
      &lt;/ScrollView&gt;
    &lt;/KeyboardAvoidingView&gt;
  );
}</code></pre>

            </section>

            <!-- Section 8: When NOT to Use ScrollView -->
            <section id="when-not-to-use" class="lesson-section">
                <h2>When NOT to Use ScrollView</h2>

                <p>ScrollView has a critical limitation: <strong>it renders all children at once</strong>. For long lists, this creates serious performance problems.</p>

                <div class="card" style="background: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Don't Use ScrollView For Long Lists</h4>
                    <pre><code class="language-tsx">// ‚ùå BAD - Renders ALL 1000 items immediately
&lt;ScrollView&gt;
  {items.map(item => (
    &lt;ListItem key={item.id} data={item} /&gt;
  ))}
&lt;/ScrollView&gt;</code></pre>
                    <p>If you have 1000 items, ScrollView creates 1000 component instances at once, consuming massive memory and causing significant lag.</p>
                </div>

                <h3>The Problem Visualized</h3>

                <pre class="mermaid">
flowchart LR
    subgraph ScrollView["ScrollView (All at once)"]
        A["Render Item 1"] --> B["Render Item 2"]
        B --> C["Render Item 3"]
        C --> D["..."]
        D --> E["Render Item 1000"]
    end
    
    subgraph FlatList["FlatList (Windowed)"]
        F["Render visible items only"]
        G["~10-20 items in memory"]
    end
    
    ScrollView --> H["‚ö†Ô∏è 1000 items in memory"]
    FlatList --> I["‚úì ~20 items in memory"]
    
    style H fill:#ffebee,stroke:#f44336
    style I fill:#e8f5e9,stroke:#4caf50
                </pre>
                <p class="caption"><em>ScrollView vs FlatList memory usage for large lists</em></p>

                <h3>Use FlatList Instead</h3>

                <pre><code class="language-tsx">import { FlatList } from 'react-native';

// ‚úÖ GOOD - Only renders visible items
&lt;FlatList
  data={items}
  keyExtractor={(item) => item.id}
  renderItem={({ item }) => &lt;ListItem data={item} /&gt;}
/&gt;</code></pre>

                <h3>When to Use Each</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Use ScrollView When:</th>
                            <th>Use FlatList/SectionList When:</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Content is short/limited (settings, forms)</td>
                            <td>Lists with many items (feeds, search results)</td>
                        </tr>
                        <tr>
                            <td>Mixed content types (article with images)</td>
                            <td>Homogeneous list items</td>
                        </tr>
                        <tr>
                            <td>Known, small number of children</td>
                            <td>Dynamic or large data sets</td>
                        </tr>
                        <tr>
                            <td>Horizontal carousels with few items</td>
                            <td>Infinite scroll / pagination</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Rule of Thumb</h4>
                    <ul>
                        <li><strong>Under 20-30 items:</strong> ScrollView is fine</li>
                        <li><strong>30+ items or dynamic list:</strong> Use FlatList</li>
                        <li><strong>Grouped data:</strong> Use SectionList</li>
                    </ul>
                    <p>We'll cover FlatList in detail in Module 5: Lists and Performance.</p>
                </div>

            </section>

            <!-- Section 9: Exercises -->
            <section id="exercises" class="lesson-section">
                <h2>Hands-On Exercises</h2>

                <p>Practice makes perfect! These exercises will help you master ScrollView.</p>

                <h3>Exercise 1: Settings Screen</h3>

                <div class="card">
                    <p><strong>Goal:</strong> Create a scrollable settings screen with sections.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Full-screen ScrollView with light gray background</li>
                        <li>Multiple sections: "Account", "Notifications", "Privacy"</li>
                        <li>Each section has a title and 3-4 setting rows</li>
                        <li>Setting rows should have white background with subtle borders</li>
                        <li>Proper padding and spacing throughout</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>contentContainerStyle</code> for padding. Create reusable SettingRow and SectionTitle components for consistency.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-tsx">import { ScrollView, View, Text, StyleSheet } from 'react-native';

function SectionTitle({ title }: { title: string }) {
  return &lt;Text style={styles.sectionTitle}&gt;{title}&lt;/Text&gt;;
}

function SettingRow({ label }: { label: string }) {
  return (
    &lt;View style={styles.settingRow}&gt;
      &lt;Text style={styles.settingLabel}&gt;{label}&lt;/Text&gt;
      &lt;Text style={styles.chevron}&gt;‚Ä∫&lt;/Text&gt;
    &lt;/View&gt;
  );
}

export default function SettingsScreen() {
  return (
    &lt;ScrollView 
      style={styles.container}
      contentContainerStyle={styles.content}
    &gt;
      &lt;SectionTitle title="Account" /&gt;
      &lt;View style={styles.section}&gt;
        &lt;SettingRow label="Profile" /&gt;
        &lt;SettingRow label="Email" /&gt;
        &lt;SettingRow label="Password" /&gt;
        &lt;SettingRow label="Linked Accounts" /&gt;
      &lt;/View&gt;

      &lt;SectionTitle title="Notifications" /&gt;
      &lt;View style={styles.section}&gt;
        &lt;SettingRow label="Push Notifications" /&gt;
        &lt;SettingRow label="Email Notifications" /&gt;
        &lt;SettingRow label="SMS Alerts" /&gt;
      &lt;/View&gt;

      &lt;SectionTitle title="Privacy" /&gt;
      &lt;View style={styles.section}&gt;
        &lt;SettingRow label="Data Sharing" /&gt;
        &lt;SettingRow label="Analytics" /&gt;
        &lt;SettingRow label="Delete Account" /&gt;
      &lt;/View&gt;
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    paddingVertical: 20,
  },
  sectionTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: '#666',
    textTransform: 'uppercase',
    marginHorizontal: 16,
    marginTop: 20,
    marginBottom: 8,
  },
  section: {
    backgroundColor: 'white',
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: '#e0e0e0',
  },
  settingRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  settingLabel: {
    fontSize: 16,
    color: '#333',
  },
  chevron: {
    fontSize: 20,
    color: '#ccc',
  },
});</code></pre>
                    </details>
                </div>

                <h3>Exercise 2: Horizontal Category Picker</h3>

                <div class="card">
                    <p><strong>Goal:</strong> Create a horizontal scrolling category picker.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Horizontal ScrollView that doesn't show the scroll indicator</li>
                        <li>Array of category buttons (pills)</li>
                        <li>One category is "selected" with different styling</li>
                        <li>Tapping a category selects it</li>
                        <li>Padding on the sides so first/last items aren't flush with edges</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>useState</code> to track the selected category. Use <code>Pressable</code> for the pills. Apply different styles based on whether the item is selected.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-tsx">import { useState } from 'react';
import { ScrollView, Pressable, Text, StyleSheet } from 'react-native';

const CATEGORIES = [
  'All', 'Technology', 'Design', 'Business', 
  'Science', 'Health', 'Sports', 'Entertainment'
];

export default function CategoryPicker() {
  const [selected, setSelected] = useState('All');

  return (
    &lt;ScrollView
      horizontal
      showsHorizontalScrollIndicator={false}
      contentContainerStyle={styles.container}
    &gt;
      {CATEGORIES.map((category) => (
        &lt;Pressable
          key={category}
          onPress={() => setSelected(category)}
          style={[
            styles.pill,
            selected === category && styles.pillSelected,
          ]}
        &gt;
          &lt;Text 
            style={[
              styles.pillText,
              selected === category && styles.pillTextSelected,
            ]}
          &gt;
            {category}
          &lt;/Text&gt;
        &lt;/Pressable&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    gap: 8,
  },
  pill: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#f0f0f0',
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  pillSelected: {
    backgroundColor: '#2196F3',
    borderColor: '#2196F3',
  },
  pillText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#666',
  },
  pillTextSelected: {
    color: 'white',
  },
});</code></pre>
                    </details>
                </div>

                <h3>Exercise 3: Pull-to-Refresh Feed</h3>

                <div class="card">
                    <p><strong>Goal:</strong> Create a simple feed with pull-to-refresh functionality.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>ScrollView with RefreshControl</li>
                        <li>Display a list of "posts" (simple cards with title and timestamp)</li>
                        <li>Pulling down triggers a refresh with 1.5 second delay</li>
                        <li>After refresh, add a new post at the top</li>
                        <li>Show the refresh spinner while loading</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>useState</code> for both the posts array and the refreshing state. Use <code>useCallback</code> for the refresh handler. Generate a timestamp with <code>new Date().toLocaleTimeString()</code>.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-tsx">import { useState, useCallback } from 'react';
import { 
  ScrollView, RefreshControl, View, Text, StyleSheet 
} from 'react-native';

interface Post {
  id: number;
  title: string;
  timestamp: string;
}

const initialPosts: Post[] = [
  { id: 1, title: 'Welcome to the feed!', timestamp: '10:00 AM' },
  { id: 2, title: 'This is a sample post', timestamp: '9:45 AM' },
  { id: 3, title: 'Pull down to refresh', timestamp: '9:30 AM' },
];

export default function RefreshableFeed() {
  const [posts, setPosts] = useState&lt;Post[]&gt;(initialPosts);
  const [refreshing, setRefreshing] = useState(false);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Add new post at the top
    const newPost: Post = {
      id: Date.now(),
      title: `New post #${posts.length + 1}`,
      timestamp: new Date().toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
    };
    
    setPosts(prev => [newPost, ...prev]);
    setRefreshing(false);
  }, [posts.length]);

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.content}
      refreshControl={
        &lt;RefreshControl
          refreshing={refreshing}
          onRefresh={onRefresh}
          tintColor="#2196F3"
          colors={['#2196F3']}
        /&gt;
      }
    &gt;
      {posts.map((post) => (
        &lt;View key={post.id} style={styles.card}&gt;
          &lt;Text style={styles.title}&gt;{post.title}&lt;/Text&gt;
          &lt;Text style={styles.timestamp}&gt;{post.timestamp}&lt;/Text&gt;
        &lt;/View&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    padding: 16,
  },
  card: {
    backgroundColor: 'white',
    padding: 16,
    borderRadius: 12,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  timestamp: {
    fontSize: 12,
    color: '#999',
  },
});</code></pre>
                    </details>
                </div>

                <h3>Challenge: Scroll-to-Section Navigation</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üèÜ Bonus Challenge</h4>
                    <p style="color: white;"><strong>Goal:</strong> Create a scrollable page with section navigation that scrolls to each section when tapped.</p>
                    
                    <p style="color: white;"><strong>Features:</strong></p>
                    <ul style="color: white;">
                        <li>Horizontal navigation bar at the top with section names</li>
                        <li>Vertical ScrollView with multiple content sections</li>
                        <li>Tapping a nav item scrolls to that section smoothly</li>
                        <li>Use <code>scrollTo</code> and measure section positions with <code>onLayout</code></li>
                    </ul>
                    
                    <details>
                        <summary style="color: white; cursor: pointer;">‚úÖ Solution</summary>
                        <div style="background: rgba(0,0,0,0.2); padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                        <pre><code class="language-tsx">import { useRef, useState } from 'react';
import { 
  ScrollView, View, Text, Pressable, StyleSheet 
} from 'react-native';

const SECTIONS = ['Overview', 'Features', 'Pricing', 'FAQ'];

export default function ScrollToSectionDemo() {
  const scrollViewRef = useRef&lt;ScrollView&gt;(null);
  const [sectionPositions, setSectionPositions] = useState&lt;number[]&gt;([]);

  const handleSectionLayout = (index: number, y: number) => {
    setSectionPositions(prev => {
      const newPositions = [...prev];
      newPositions[index] = y;
      return newPositions;
    });
  };

  const scrollToSection = (index: number) => {
    const y = sectionPositions[index];
    if (y !== undefined) {
      scrollViewRef.current?.scrollTo({ y, animated: true });
    }
  };

  return (
    &lt;View style={styles.container}&gt;
      {/* Navigation */}
      &lt;ScrollView 
        horizontal 
        showsHorizontalScrollIndicator={false}
        style={styles.nav}
        contentContainerStyle={styles.navContent}
      &gt;
        {SECTIONS.map((section, index) => (
          &lt;Pressable
            key={section}
            onPress={() => scrollToSection(index)}
            style={styles.navItem}
          &gt;
            &lt;Text style={styles.navText}&gt;{section}&lt;/Text&gt;
          &lt;/Pressable&gt;
        ))}
      &lt;/ScrollView&gt;

      {/* Content */}
      &lt;ScrollView 
        ref={scrollViewRef}
        style={styles.content}
      &gt;
        {SECTIONS.map((section, index) => (
          &lt;View
            key={section}
            onLayout={(e) => handleSectionLayout(index, e.nativeEvent.layout.y)}
            style={styles.section}
          &gt;
            &lt;Text style={styles.sectionTitle}&gt;{section}&lt;/Text&gt;
            &lt;Text style={styles.sectionContent}&gt;
              Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
              Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
              {'\n\n'}
              Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris.
            &lt;/Text&gt;
          &lt;/View&gt;
        ))}
        &lt;View style={{ height: 100 }} /&gt;
      &lt;/ScrollView&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  nav: {
    maxHeight: 50,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  navContent: {
    paddingHorizontal: 16,
    alignItems: 'center',
    gap: 8,
  },
  navItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  navText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#2196F3',
  },
  content: {
    flex: 1,
  },
  section: {
    padding: 20,
    minHeight: 300,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 16,
  },
  sectionContent: {
    fontSize: 16,
    lineHeight: 24,
    color: '#666',
  },
});</code></pre>
                        </div>
                    </details>
                </div>

            </section>

            <!-- Section 10: Summary -->
            <section id="summary" class="lesson-section">
                <h2>Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>View doesn't scroll</strong> ‚Äî use ScrollView for scrollable content</li>
                        <li><strong>style vs contentContainerStyle</strong> ‚Äî style affects the frame; contentContainerStyle affects content</li>
                        <li><strong>horizontal prop</strong> ‚Äî enables horizontal scrolling</li>
                        <li><strong>pagingEnabled</strong> ‚Äî snaps to page boundaries (great for carousels)</li>
                        <li><strong>onScroll + scrollEventThrottle</strong> ‚Äî track scroll position (16ms for smooth animations)</li>
                        <li><strong>RefreshControl</strong> ‚Äî enables pull-to-refresh pattern</li>
                        <li><strong>Keyboard props</strong> ‚Äî keyboardDismissMode and keyboardShouldPersistTaps for forms</li>
                        <li><strong>Don't use for long lists</strong> ‚Äî ScrollView renders all children at once; use FlatList instead</li>
                    </ul>
                </div>
                
                <h3>Quick Reference</h3>

                <pre><code class="language-tsx">import { ScrollView, RefreshControl } from 'react-native';

// Basic vertical scroll
&lt;ScrollView 
  style={{ flex: 1 }}
  contentContainerStyle={{ padding: 16 }}
&gt;

// Horizontal with paging
&lt;ScrollView 
  horizontal 
  pagingEnabled
  showsHorizontalScrollIndicator={false}
&gt;

// With pull-to-refresh
&lt;ScrollView
  refreshControl={
    &lt;RefreshControl refreshing={isRefreshing} onRefresh={handleRefresh} /&gt;
  }
&gt;

// For forms
&lt;ScrollView
  keyboardShouldPersistTaps="handled"
  keyboardDismissMode="on-drag"
&gt;

// Scroll programmatically
const ref = useRef&lt;ScrollView&gt;(null);
ref.current?.scrollTo({ y: 0, animated: true });
ref.current?.scrollToEnd({ animated: true });</code></pre>

                <h3>üöÄ What's Next?</h3>
                <p>Now that you understand scrolling, we'll explore <strong>SafeAreaView</strong> ‚Äî how to respect device boundaries like notches, home indicators, and status bars for proper content positioning.</p>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üìú Scrolling Mastered!</h3>
                    <p style="color: white;">You now know how to create scrollable interfaces, handle pull-to-refresh, work with keyboards, and when to choose ScrollView vs FlatList. Smooth scrolling ahead!</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="m03_l03_image_displaying_visual_content.html" class="prev-lesson">‚Üê Previous: Image ‚Äî Displaying Visual Content</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="m03_l05_safeareaview_respecting_device_boundaries.html" class="next-lesson">Next: SafeAreaView ‚Äî Respecting Device Boundaries ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-color); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2025 React Native & Expo Mastery Course. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Building the next generation of mobile developers.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
