<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn local storage options in React Native: AsyncStorage for general data, SecureStore for sensitive information, and MMKV for high-performance needs">
    <meta name="author" content="React Native & Expo Course">
    <title>Local Storage Options | Module 7: Data Management and Networking | React Native & Expo Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">üì± RN Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#modules">Modules</a>
                <a href="index.html#appendices">Appendices</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <div class="breadcrumb">
        <div class="container">
            <a href="index.html">Home</a> &gt;
            <a href="index.html#modules">Modules</a> &gt;
            <a href="m07_l01_fetching_data.html">Module 7</a> &gt;
            <span>Lesson 7.3</span>
        </div>
    </div>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <p class="module-tag">Module 7: Data Management and Networking</p>
                <h1>Local Storage Options</h1>
                <p class="lesson-subtitle">Persisting data on the device for offline access and faster app startup</p>
            </header>

            <!-- Learning Objectives -->
            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h2 style="color: white; border: none; margin-top: 0;">üéØ Learning Objectives</h2>
                <ul style="color: white;">
                    <li>Understand when and why to use local storage in mobile apps</li>
                    <li>Use AsyncStorage for general-purpose key-value storage</li>
                    <li>Secure sensitive data with expo-secure-store</li>
                    <li>Achieve high-performance storage with react-native-mmkv</li>
                    <li>Choose the right storage solution for different use cases</li>
                    <li>Implement storage abstractions for cleaner code</li>
                    <li>Handle storage migrations when data structures change</li>
                </ul>
            </div>

            <!-- Table of Contents -->
            <div class="toc-container">
                <details class="toc-details" open>
                    <summary>üìë Table of Contents</summary>
                    <ul class="toc-list">
                        <li><a href="#why-local-storage">Why Local Storage?</a></li>
                        <li><a href="#storage-landscape">The Storage Landscape</a></li>
                        <li><a href="#async-storage">AsyncStorage: The Standard Choice</a></li>
                        <li><a href="#secure-store">SecureStore: For Sensitive Data</a></li>
                        <li><a href="#mmkv">MMKV: High-Performance Storage</a></li>
                        <li><a href="#comparison">Comparing Storage Options</a></li>
                        <li><a href="#abstractions">Building Storage Abstractions</a></li>
                        <li><a href="#tanstack-persistence">Persisting React Query Cache</a></li>
                        <li><a href="#exercises">Hands-On Exercises</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ul>
                </details>
            </div>

            <!-- Why Local Storage? -->
            <section id="why-local-storage">
                <h2>Why Local Storage?</h2>

                <p>Mobile apps need local storage for many reasons. Unlike web apps where you might rely on server-side sessions and localStorage for simple things, mobile apps often need to work offline, start quickly, and remember user preferences across sessions.</p>

                <div class="card">
                    <h4>üì± Common Use Cases for Local Storage</h4>
                    <ul>
                        <li><strong>Authentication tokens</strong> ‚Äî Keep users logged in between app launches</li>
                        <li><strong>User preferences</strong> ‚Äî Theme, language, notification settings</li>
                        <li><strong>Cached data</strong> ‚Äî Show content immediately while fetching updates</li>
                        <li><strong>Offline data</strong> ‚Äî Let users work without internet connectivity</li>
                        <li><strong>Draft content</strong> ‚Äî Save unsent messages or unfinished forms</li>
                        <li><strong>Onboarding state</strong> ‚Äî Track if user has completed tutorial</li>
                        <li><strong>App state</strong> ‚Äî Restore user's position after app restart</li>
                    </ul>
                </div>

                <p>The key question isn't whether you need local storage‚Äîyou almost certainly do. The question is which storage solution fits your specific needs.</p>

                <!-- SVG: Local Storage Benefits -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 300" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="300" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="350" y="25" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">Benefits of Local Storage</text>
                        
                        <!-- Center: Device -->
                        <rect x="280" y="100" width="140" height="140" fill="#667eea" stroke="#5a67d8" stroke-width="2" rx="12"/>
                        <text x="350" y="165" text-anchor="middle" font-size="12" font-weight="bold" fill="white">üì± Device</text>
                        <text x="350" y="185" text-anchor="middle" font-size="10" fill="rgba(255,255,255,0.9)">Local Storage</text>
                        
                        <!-- Benefit 1: Speed -->
                        <circle cx="100" cy="100" r="40" fill="#e8f5e9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="100" y="95" text-anchor="middle" font-size="20">‚ö°</text>
                        <text x="100" y="115" text-anchor="middle" font-size="9" fill="#2e7d32">Instant</text>
                        <line x1="140" y1="100" x2="280" y2="140" stroke="#4CAF50" stroke-width="2" stroke-dasharray="5,3"/>
                        
                        <!-- Benefit 2: Offline -->
                        <circle cx="100" cy="200" r="40" fill="#e3f2fd" stroke="#2196F3" stroke-width="2"/>
                        <text x="100" y="195" text-anchor="middle" font-size="20">üì¥</text>
                        <text x="100" y="215" text-anchor="middle" font-size="9" fill="#1976D2">Offline</text>
                        <line x1="140" y1="200" x2="280" y2="180" stroke="#2196F3" stroke-width="2" stroke-dasharray="5,3"/>
                        
                        <!-- Benefit 3: Persistent -->
                        <circle cx="600" cy="100" r="40" fill="#fff3e0" stroke="#FF9800" stroke-width="2"/>
                        <text x="600" y="95" text-anchor="middle" font-size="20">üíæ</text>
                        <text x="600" y="115" text-anchor="middle" font-size="9" fill="#e65100">Persistent</text>
                        <line x1="420" y1="140" x2="560" y2="100" stroke="#FF9800" stroke-width="2" stroke-dasharray="5,3"/>
                        
                        <!-- Benefit 4: Secure -->
                        <circle cx="600" cy="200" r="40" fill="#fce4ec" stroke="#E91E63" stroke-width="2"/>
                        <text x="600" y="195" text-anchor="middle" font-size="20">üîí</text>
                        <text x="600" y="215" text-anchor="middle" font-size="9" fill="#c2185b">Secure</text>
                        <line x1="420" y1="180" x2="560" y2="200" stroke="#E91E63" stroke-width="2" stroke-dasharray="5,3"/>
                        
                        <!-- Bottom labels -->
                        <text x="100" y="270" text-anchor="middle" font-size="10" fill="#666">No network</text>
                        <text x="100" y="285" text-anchor="middle" font-size="10" fill="#666">latency</text>
                        
                        <text x="350" y="270" text-anchor="middle" font-size="10" fill="#666">Data survives</text>
                        <text x="350" y="285" text-anchor="middle" font-size="10" fill="#666">app restarts</text>
                        
                        <text x="600" y="270" text-anchor="middle" font-size="10" fill="#666">Encrypted</text>
                        <text x="600" y="285" text-anchor="middle" font-size="10" fill="#666">options available</text>
                    </svg>
                </div>
            </section>

            <!-- The Storage Landscape -->
            <section id="storage-landscape">
                <h2>The Storage Landscape</h2>

                <p>React Native offers several storage options, each with different tradeoffs. Here's the landscape:</p>

                <!-- Mermaid: Storage Options Overview -->
                <pre class="mermaid">
flowchart TB
    subgraph options["Storage Options"]
        AS["AsyncStorage<br/>General purpose"]
        SS["SecureStore<br/>Sensitive data"]
        MMKV["MMKV<br/>High performance"]
        SQLite["SQLite<br/>Relational data"]
        FS["FileSystem<br/>Large files"]
    end
    
    subgraph usecases["Use Cases"]
        U1["Settings, preferences"]
        U2["Auth tokens, passwords"]
        U3["Frequently accessed data"]
        U4["Complex queries"]
        U5["Images, documents"]
    end
    
    AS --> U1
    SS --> U2
    MMKV --> U3
    SQLite --> U4
    FS --> U5
    
    style AS fill:#e3f2fd,stroke:#2196F3
    style SS fill:#fce4ec,stroke:#E91E63
    style MMKV fill:#fff3e0,stroke:#FF9800
    style SQLite fill:#e8f5e9,stroke:#4CAF50
    style FS fill:#f3e5f5,stroke:#9C27B0
                </pre>

                <p>In this lesson, we'll focus on the three most common options for key-value storage: AsyncStorage, SecureStore, and MMKV. SQLite and FileSystem are covered in other lessons.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Key-Value Storage</h4>
                    <p style="color: white;">All three options we'll cover are <strong>key-value stores</strong>‚Äîthey save data as string keys mapped to string values. Think of them like a persistent JavaScript object or a simple database with just two columns: key and value.</p>
                </div>
            </section>

            <!-- AsyncStorage -->
            <section id="async-storage">
                <h2>AsyncStorage: The Standard Choice</h2>

                <p>AsyncStorage is the go-to storage solution for React Native apps. It's simple, well-documented, and works for most use cases. Think of it as localStorage for mobile, but asynchronous.</p>

                <h3>Installation</h3>

                <pre><code>npx expo install @react-native-async-storage/async-storage</code></pre>

                <h3>Basic Operations</h3>

                <pre><code>import AsyncStorage from '@react-native-async-storage/async-storage';

// ============= STORING DATA =============

// Store a string
await AsyncStorage.setItem('username', 'john_doe');

// Store an object (must stringify!)
const user = { id: 1, name: 'John', email: 'john@example.com' };
await AsyncStorage.setItem('user', JSON.stringify(user));

// Store multiple items at once (more efficient)
await AsyncStorage.multiSet([
  ['theme', 'dark'],
  ['language', 'en'],
  ['notifications', 'true'],
]);


// ============= RETRIEVING DATA =============

// Get a string
const username = await AsyncStorage.getItem('username');
console.log(username); // 'john_doe' or null if not found

// Get and parse an object
const userJson = await AsyncStorage.getItem('user');
const user = userJson ? JSON.parse(userJson) : null;

// Get multiple items at once
const values = await AsyncStorage.multiGet(['theme', 'language']);
// Returns: [['theme', 'dark'], ['language', 'en']]

// Convert to object for easier access
const settings = Object.fromEntries(values);
// { theme: 'dark', language: 'en' }


// ============= REMOVING DATA =============

// Remove a single item
await AsyncStorage.removeItem('username');

// Remove multiple items
await AsyncStorage.multiRemove(['theme', 'language', 'notifications']);

// Clear ALL storage (use carefully!)
await AsyncStorage.clear();


// ============= OTHER OPERATIONS =============

// Get all keys
const allKeys = await AsyncStorage.getAllKeys();
// ['user', 'theme', 'language', ...]

// Merge object (useful for partial updates)
// Existing: { name: 'John', email: 'john@example.com' }
await AsyncStorage.mergeItem('user', JSON.stringify({ email: 'newemail@example.com' }));
// Result: { name: 'John', email: 'newemail@example.com' }</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Always Handle Errors</h4>
                    <p>AsyncStorage operations can fail (storage full, corrupted data, etc.). Always wrap in try-catch:</p>
                    <pre><code>try {
  await AsyncStorage.setItem('key', 'value');
} catch (error) {
  console.error('Failed to save:', error);
}</code></pre>
                </div>

                <h3>Creating a Type-Safe Storage Hook</h3>

                <p>Raw AsyncStorage is verbose. Let's create a hook that handles JSON serialization and provides better TypeScript support:</p>

                <pre><code>import { useState, useEffect, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Generic hook for any stored value
export function useAsyncStorage&lt;T&gt;(
  key: string,
  initialValue: T
): [T, (value: T) => Promise&lt;void&gt;, boolean] {
  const [storedValue, setStoredValue] = useState&lt;T&gt;(initialValue);
  const [isLoading, setIsLoading] = useState(true);

  // Load value on mount
  useEffect(() => {
    const loadValue = async () => {
      try {
        const item = await AsyncStorage.getItem(key);
        if (item !== null) {
          setStoredValue(JSON.parse(item));
        }
      } catch (error) {
        console.error(`Error loading ${key}:`, error);
      } finally {
        setIsLoading(false);
      }
    };

    loadValue();
  }, [key]);

  // Save value
  const setValue = useCallback(async (value: T) => {
    try {
      setStoredValue(value);
      await AsyncStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Error saving ${key}:`, error);
      throw error;
    }
  }, [key]);

  return [storedValue, setValue, isLoading];
}

// Usage
function SettingsScreen() {
  const [theme, setTheme, isLoading] = useAsyncStorage&lt;'light' | 'dark'&gt;(
    'theme',
    'light'
  );

  if (isLoading) {
    return &lt;ActivityIndicator /&gt;;
  }

  return (
    &lt;View&gt;
      &lt;Text&gt;Current theme: {theme}&lt;/Text&gt;
      &lt;Button
        title="Toggle Theme"
        onPress={() => setTheme(theme === 'light' ? 'dark' : 'light')}
      /&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <h3>AsyncStorage Limitations</h3>

                <div class="card">
                    <h4>üìã Know the Limits</h4>
                    <ul>
                        <li><strong>Performance:</strong> Slower than MMKV, especially for frequent reads/writes</li>
                        <li><strong>Size limit:</strong> ~6MB on Android by default (can be increased)</li>
                        <li><strong>Strings only:</strong> Must serialize/deserialize objects manually</li>
                        <li><strong>No encryption:</strong> Data is stored in plain text</li>
                        <li><strong>Async only:</strong> No synchronous access (can complicate app initialization)</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use AsyncStorage</h4>
                    <ul>
                        <li>User preferences and settings</li>
                        <li>Non-sensitive cached data</li>
                        <li>Onboarding/tutorial completion flags</li>
                        <li>Simple app state that doesn't need encryption</li>
                        <li>When you need a simple, well-supported solution</li>
                    </ul>
                </div>
            </section>

            <!-- SecureStore -->
            <section id="secure-store">
                <h2>SecureStore: For Sensitive Data</h2>

                <p>When you're storing sensitive information‚Äîauthentication tokens, passwords, API keys‚Äîyou need encryption. <code>expo-secure-store</code> uses the device's secure hardware to encrypt data.</p>

                <h3>How It Works</h3>

                <!-- SVG: SecureStore Architecture -->
                <div class="svg-container" style="text-align: center; margin: 2rem 0;">
                    <svg viewBox="0 0 700 250" style="max-width: 100%; height: auto; font-family: system-ui, sans-serif;">
                        <!-- Background -->
                        <rect width="700" height="250" fill="#f8f9fa"/>
                        
                        <!-- Title -->
                        <text x="350" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">SecureStore: Hardware-Backed Encryption</text>
                        
                        <!-- Your App -->
                        <rect x="50" y="80" width="120" height="80" fill="#667eea" stroke="#5a67d8" stroke-width="2" rx="8"/>
                        <text x="110" y="115" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Your App</text>
                        <text x="110" y="135" text-anchor="middle" font-size="10" fill="rgba(255,255,255,0.9)">"password123"</text>
                        
                        <!-- Arrow 1 -->
                        <path d="M170,120 L230,120" stroke="#333" stroke-width="2" marker-end="url(#arrowBlack)"/>
                        <text x="200" y="110" text-anchor="middle" font-size="9" fill="#666">setItemAsync</text>
                        
                        <!-- SecureStore API -->
                        <rect x="230" y="80" width="120" height="80" fill="#E91E63" stroke="#C2185B" stroke-width="2" rx="8"/>
                        <text x="290" y="115" text-anchor="middle" font-size="11" font-weight="bold" fill="white">SecureStore</text>
                        <text x="290" y="135" text-anchor="middle" font-size="10" fill="rgba(255,255,255,0.9)">API</text>
                        
                        <!-- Arrow 2 -->
                        <path d="M350,120 L410,120" stroke="#333" stroke-width="2" marker-end="url(#arrowBlack)"/>
                        <text x="380" y="110" text-anchor="middle" font-size="9" fill="#666">encrypt</text>
                        
                        <!-- Keychain/Keystore -->
                        <rect x="410" y="60" width="140" height="120" fill="#4CAF50" stroke="#388E3C" stroke-width="2" rx="8"/>
                        <text x="480" y="95" text-anchor="middle" font-size="11" font-weight="bold" fill="white">iOS: Keychain</text>
                        <text x="480" y="115" text-anchor="middle" font-size="11" font-weight="bold" fill="white">Android: Keystore</text>
                        <text x="480" y="145" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">üîê Hardware</text>
                        <text x="480" y="162" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.9)">Encryption</text>
                        
                        <!-- Arrow 3 -->
                        <path d="M550,120 L610,120" stroke="#333" stroke-width="2" marker-end="url(#arrowBlack)"/>
                        
                        <!-- Storage -->
                        <rect x="610" y="80" width="70" height="80" fill="#333" stroke="#000" stroke-width="2" rx="8"/>
                        <text x="645" y="115" text-anchor="middle" font-size="9" fill="white">Encrypted</text>
                        <text x="645" y="130" text-anchor="middle" font-size="9" fill="white">Storage</text>
                        <text x="645" y="150" text-anchor="middle" font-size="16" fill="white">üîí</text>
                        
                        <!-- Bottom note -->
                        <text x="350" y="220" text-anchor="middle" font-size="11" fill="#666">Data is encrypted using device-specific keys stored in secure hardware</text>
                        <text x="350" y="238" text-anchor="middle" font-size="10" fill="#999">Even if device is compromised, keys remain protected</text>
                        
                        <defs>
                            <marker id="arrowBlack" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
                            </marker>
                        </defs>
                    </svg>
                </div>

                <h3>Installation</h3>

                <pre><code>npx expo install expo-secure-store</code></pre>

                <h3>Basic Operations</h3>

                <pre><code>import * as SecureStore from 'expo-secure-store';

// ============= STORING DATA =============

// Store a string (automatically encrypted)
await SecureStore.setItemAsync('authToken', 'eyJhbGciOiJIUzI1...');

// Store with options
await SecureStore.setItemAsync('refreshToken', 'abc123', {
  // Require device authentication (FaceID/TouchID/PIN) to access
  requireAuthentication: true,
  // Custom prompt for biometric auth
  authenticationPrompt: 'Authenticate to access your account',
});


// ============= RETRIEVING DATA =============

// Get a value
const token = await SecureStore.getItemAsync('authToken');
// Returns string or null if not found

// Will prompt for biometric auth if requireAuthentication was true
const refreshToken = await SecureStore.getItemAsync('refreshToken');


// ============= REMOVING DATA =============

await SecureStore.deleteItemAsync('authToken');


// ============= CHECKING AVAILABILITY =============

// Check if SecureStore is available on this device
const isAvailable = await SecureStore.isAvailableAsync();
if (!isAvailable) {
  // Fall back to AsyncStorage with warning
  console.warn('SecureStore not available, using AsyncStorage');
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è SecureStore Limitations</h4>
                    <ul>
                        <li><strong>Size limit:</strong> Values must be ‚â§ 2048 bytes</li>
                        <li><strong>Strings only:</strong> No objects (must stringify small objects)</li>
                        <li><strong>Key restrictions:</strong> Keys can only contain alphanumeric characters, <code>.</code>, <code>-</code>, and <code>_</code></li>
                        <li><strong>Not for large data:</strong> Designed for tokens and credentials, not cached API responses</li>
                    </ul>
                </div>

                <h3>Authentication Token Management</h3>

                <p>Here's a complete example of managing auth tokens with SecureStore:</p>

                <pre><code>import * as SecureStore from 'expo-secure-store';

const TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';

interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}

class TokenStorage {
  // Save tokens after login
  static async saveTokens(tokens: AuthTokens): Promise&lt;void&gt; {
    await Promise.all([
      SecureStore.setItemAsync(TOKEN_KEY, tokens.accessToken),
      SecureStore.setItemAsync(REFRESH_TOKEN_KEY, tokens.refreshToken),
    ]);
  }

  // Get access token
  static async getAccessToken(): Promise&lt;string | null&gt; {
    return SecureStore.getItemAsync(TOKEN_KEY);
  }

  // Get refresh token
  static async getRefreshToken(): Promise&lt;string | null&gt; {
    return SecureStore.getItemAsync(REFRESH_TOKEN_KEY);
  }

  // Get both tokens
  static async getTokens(): Promise&lt;AuthTokens | null&gt; {
    const [accessToken, refreshToken] = await Promise.all([
      SecureStore.getItemAsync(TOKEN_KEY),
      SecureStore.getItemAsync(REFRESH_TOKEN_KEY),
    ]);

    if (!accessToken || !refreshToken) {
      return null;
    }

    return { accessToken, refreshToken };
  }

  // Clear tokens on logout
  static async clearTokens(): Promise&lt;void&gt; {
    await Promise.all([
      SecureStore.deleteItemAsync(TOKEN_KEY),
      SecureStore.deleteItemAsync(REFRESH_TOKEN_KEY),
    ]);
  }

  // Check if user is logged in
  static async isAuthenticated(): Promise&lt;boolean&gt; {
    const token = await SecureStore.getItemAsync(TOKEN_KEY);
    return token !== null;
  }
}

// Usage in auth context
async function login(email: string, password: string) {
  const response = await api.post('/auth/login', { email, password });
  const { accessToken, refreshToken } = response.data;
  
  await TokenStorage.saveTokens({ accessToken, refreshToken });
  
  // Update auth state
  setIsAuthenticated(true);
}

async function logout() {
  await TokenStorage.clearTokens();
  setIsAuthenticated(false);
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use SecureStore</h4>
                    <ul>
                        <li>Authentication tokens (access tokens, refresh tokens)</li>
                        <li>API keys that must remain secret</li>
                        <li>User credentials (if storing locally is necessary)</li>
                        <li>Encryption keys for other data</li>
                        <li>Any small piece of sensitive information</li>
                    </ul>
                </div>
            </section>

            <!-- MMKV -->
            <section id="mmkv">
                <h2>MMKV: High-Performance Storage</h2>

                <p>MMKV is a key-value storage library developed by WeChat. It's significantly faster than AsyncStorage‚Äîup to 30x faster for some operations. If your app does frequent storage operations, MMKV can make a noticeable difference.</p>

                <h3>Why MMKV is Faster</h3>

                <div class="card">
                    <h4>üöÄ MMKV Performance Advantages</h4>
                    <ul>
                        <li><strong>Memory-mapped files:</strong> Uses mmap for direct memory access instead of file I/O</li>
                        <li><strong>Synchronous API:</strong> No async overhead‚Äîreads/writes complete immediately</li>
                        <li><strong>Protobuf encoding:</strong> More efficient than JSON serialization</li>
                        <li><strong>Incremental updates:</strong> Only writes changes, not entire file</li>
                        <li><strong>Native implementation:</strong> Written in C++ for maximum speed</li>
                    </ul>
                </div>

                <h3>Installation</h3>

                <pre><code># For Expo with development build
npx expo install react-native-mmkv

# Requires a development build (won't work in Expo Go)
npx expo prebuild
npx expo run:ios  # or run:android</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Requires Development Build</h4>
                    <p>MMKV includes native code and won't work in Expo Go. You'll need to create a development build. This is usually fine for production apps but adds complexity during development.</p>
                </div>

                <h3>Basic Operations</h3>

                <pre><code>import { MMKV } from 'react-native-mmkv';

// Create a storage instance
const storage = new MMKV();

// Or with custom ID (for multiple instances)
const userStorage = new MMKV({ id: 'user-storage' });

// Or with encryption
const secureStorage = new MMKV({
  id: 'secure-storage',
  encryptionKey: 'your-encryption-key',
});


// ============= STORING DATA =============

// Strings - synchronous!
storage.set('username', 'john_doe');

// Numbers
storage.set('loginCount', 42);

// Booleans
storage.set('isPremium', true);

// Objects (must stringify)
const user = { id: 1, name: 'John' };
storage.set('user', JSON.stringify(user));


// ============= RETRIEVING DATA =============

// Strings
const username = storage.getString('username');  // 'john_doe' or undefined

// Numbers
const count = storage.getNumber('loginCount');  // 42 or undefined

// Booleans
const isPremium = storage.getBoolean('isPremium');  // true or undefined

// Objects
const userJson = storage.getString('user');
const user = userJson ? JSON.parse(userJson) : null;


// ============= OTHER OPERATIONS =============

// Check if key exists
const hasUser = storage.contains('user');

// Delete a key
storage.delete('username');

// Get all keys
const allKeys = storage.getAllKeys();  // ['user', 'loginCount', ...]

// Clear everything
storage.clearAll();


// ============= LISTENERS =============

// Listen for changes (great for syncing UI)
const listener = storage.addOnValueChangedListener((key) => {
  console.log(`Value changed for key: ${key}`);
  const newValue = storage.getString(key);
  // Update UI...
});

// Remove listener when done
listener.remove();</code></pre>

                <h3>Creating a React Hook for MMKV</h3>

                <pre><code>import { useCallback, useSyncExternalStore } from 'react';
import { MMKV } from 'react-native-mmkv';

const storage = new MMKV();

// Hook for string values
export function useMMKVString(key: string) {
  const subscribe = useCallback(
    (callback: () => void) => {
      const listener = storage.addOnValueChangedListener((changedKey) => {
        if (changedKey === key) callback();
      });
      return () => listener.remove();
    },
    [key]
  );

  const getSnapshot = useCallback(() => {
    return storage.getString(key);
  }, [key]);

  const value = useSyncExternalStore(subscribe, getSnapshot);

  const setValue = useCallback(
    (newValue: string | undefined) => {
      if (newValue === undefined) {
        storage.delete(key);
      } else {
        storage.set(key, newValue);
      }
    },
    [key]
  );

  return [value, setValue] as const;
}

// Hook for objects
export function useMMKVObject&lt;T&gt;(key: string) {
  const [json, setJson] = useMMKVString(key);

  const value = json ? (JSON.parse(json) as T) : undefined;

  const setValue = useCallback(
    (newValue: T | undefined) => {
      setJson(newValue === undefined ? undefined : JSON.stringify(newValue));
    },
    [setJson]
  );

  return [value, setValue] as const;
}

// Usage
function UserProfile() {
  const [user, setUser] = useMMKVObject&lt;User&gt;('user');

  return (
    &lt;View&gt;
      &lt;Text&gt;{user?.name ?? 'Not logged in'}&lt;/Text&gt;
      &lt;Button
        title="Update Name"
        onPress={() => setUser({ ...user!, name: 'New Name' })}
      /&gt;
    &lt;/View&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use MMKV</h4>
                    <ul>
                        <li>Frequently accessed data (read/write many times per session)</li>
                        <li>App state that needs to persist (e.g., Redux/Zustand persistence)</li>
                        <li>When you need synchronous access (app initialization)</li>
                        <li>Large amounts of cached data</li>
                        <li>Performance-critical applications</li>
                    </ul>
                </div>
            </section>

            <!-- Comparing Storage Options -->
            <section id="comparison">
                <h2>Comparing Storage Options</h2>

                <p>Here's a comprehensive comparison to help you choose:</p>

                <div class="card">
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; min-width: 600px;">
                            <thead>
                                <tr style="background: #f5f5f5;">
                                    <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Feature</th>
                                    <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">AsyncStorage</th>
                                    <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">SecureStore</th>
                                    <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">MMKV</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Performance</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚≠ê‚≠ê Slow</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚≠ê‚≠ê Slow</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Fast</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Encryption</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚ùå None</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ Hardware-backed</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ Optional</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Size Limit</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">~6MB (configurable)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">2KB per value</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">No practical limit</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Sync/Async</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">Async only</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">Async only</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">Sync</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Expo Go</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ Works</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚úÖ Works</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">‚ùå Dev build only</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Data Types</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">Strings only</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">Strings only</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">String, Number, Boolean</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;"><strong>Best For</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">General storage</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">Sensitive data</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #eee;">High-performance needs</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Mermaid: Decision Tree -->
                <pre class="mermaid">
flowchart TD
    A[Need to store data locally?] --> B{Is it sensitive?}
    B -->|Yes| C{Size > 2KB?}
    B -->|No| D{Need high performance?}
    
    C -->|Yes| E[MMKV with encryption]
    C -->|No| F[SecureStore]
    
    D -->|Yes| G{Using Expo Go?}
    D -->|No| H[AsyncStorage]
    
    G -->|Yes| H
    G -->|No| I[MMKV]
    
    style F fill:#fce4ec,stroke:#E91E63
    style E fill:#fff3e0,stroke:#FF9800
    style H fill:#e3f2fd,stroke:#2196F3
    style I fill:#fff3e0,stroke:#FF9800
                </pre>
            </section>
            <!-- Building Storage Abstractions -->
            <section id="abstractions">
                <h2>Building Storage Abstractions</h2>

                <p>In a real app, you might want to use different storage backends for different data types. A clean abstraction layer lets you swap implementations without changing your app code.</p>

                <h3>Unified Storage Interface</h3>

                <pre><code>// storage/types.ts
export interface Storage {
  get&lt;T&gt;(key: string): Promise&lt;T | null&gt;;
  set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt;;
  remove(key: string): Promise&lt;void&gt;;
  clear(): Promise&lt;void&gt;;
}

// storage/asyncStorage.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import type { Storage } from './types';

export const asyncStorage: Storage = {
  async get&lt;T&gt;(key: string): Promise&lt;T | null&gt; {
    const value = await AsyncStorage.getItem(key);
    return value ? JSON.parse(value) : null;
  },

  async set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt; {
    await AsyncStorage.setItem(key, JSON.stringify(value));
  },

  async remove(key: string): Promise&lt;void&gt; {
    await AsyncStorage.removeItem(key);
  },

  async clear(): Promise&lt;void&gt; {
    await AsyncStorage.clear();
  },
};

// storage/secureStorage.ts
import * as SecureStore from 'expo-secure-store';
import type { Storage } from './types';

export const secureStorage: Storage = {
  async get&lt;T&gt;(key: string): Promise&lt;T | null&gt; {
    const value = await SecureStore.getItemAsync(key);
    return value ? JSON.parse(value) : null;
  },

  async set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt; {
    await SecureStore.setItemAsync(key, JSON.stringify(value));
  },

  async remove(key: string): Promise&lt;void&gt; {
    await SecureStore.deleteItemAsync(key);
  },

  async clear(): Promise&lt;void&gt; {
    // SecureStore doesn't have clear, so we'd need to track keys
    console.warn('SecureStore clear not implemented');
  },
};

// storage/mmkvStorage.ts (for dev builds)
import { MMKV } from 'react-native-mmkv';
import type { Storage } from './types';

const mmkv = new MMKV();

export const mmkvStorage: Storage = {
  async get&lt;T&gt;(key: string): Promise&lt;T | null&gt; {
    const value = mmkv.getString(key);
    return value ? JSON.parse(value) : null;
  },

  async set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt; {
    mmkv.set(key, JSON.stringify(value));
  },

  async remove(key: string): Promise&lt;void&gt; {
    mmkv.delete(key);
  },

  async clear(): Promise&lt;void&gt; {
    mmkv.clearAll();
  },
};</code></pre>

                <h3>Domain-Specific Storage Classes</h3>

                <p>Build higher-level storage classes for specific domains:</p>

                <pre><code>// storage/userStorage.ts
import { secureStorage } from './secureStorage';
import { asyncStorage } from './asyncStorage';

interface UserTokens {
  accessToken: string;
  refreshToken: string;
  expiresAt: number;
}

interface UserPreferences {
  theme: 'light' | 'dark' | 'system';
  language: string;
  notifications: boolean;
}

interface UserProfile {
  id: string;
  name: string;
  email: string;
  avatarUrl?: string;
}

class UserStorage {
  private static readonly KEYS = {
    TOKENS: 'user_tokens',
    PREFERENCES: 'user_preferences',
    PROFILE: 'user_profile',
    ONBOARDING_COMPLETE: 'onboarding_complete',
  };

  // Tokens - use secure storage
  static async getTokens(): Promise&lt;UserTokens | null&gt; {
    return secureStorage.get&lt;UserTokens&gt;(this.KEYS.TOKENS);
  }

  static async setTokens(tokens: UserTokens): Promise&lt;void&gt; {
    return secureStorage.set(this.KEYS.TOKENS, tokens);
  }

  static async clearTokens(): Promise&lt;void&gt; {
    return secureStorage.remove(this.KEYS.TOKENS);
  }

  static async isTokenExpired(): Promise&lt;boolean&gt; {
    const tokens = await this.getTokens();
    if (!tokens) return true;
    return Date.now() >= tokens.expiresAt;
  }

  // Preferences - use async storage (not sensitive)
  static async getPreferences(): Promise&lt;UserPreferences&gt; {
    const prefs = await asyncStorage.get&lt;UserPreferences&gt;(this.KEYS.PREFERENCES);
    return prefs ?? {
      theme: 'system',
      language: 'en',
      notifications: true,
    };
  }

  static async setPreferences(prefs: Partial&lt;UserPreferences&gt;): Promise&lt;void&gt; {
    const current = await this.getPreferences();
    return asyncStorage.set(this.KEYS.PREFERENCES, { ...current, ...prefs });
  }

  // Profile - use async storage
  static async getProfile(): Promise&lt;UserProfile | null&gt; {
    return asyncStorage.get&lt;UserProfile&gt;(this.KEYS.PROFILE);
  }

  static async setProfile(profile: UserProfile): Promise&lt;void&gt; {
    return asyncStorage.set(this.KEYS.PROFILE, profile);
  }

  // Onboarding state
  static async isOnboardingComplete(): Promise&lt;boolean&gt; {
    const complete = await asyncStorage.get&lt;boolean&gt;(this.KEYS.ONBOARDING_COMPLETE);
    return complete ?? false;
  }

  static async setOnboardingComplete(): Promise&lt;void&gt; {
    return asyncStorage.set(this.KEYS.ONBOARDING_COMPLETE, true);
  }

  // Clear all user data (logout)
  static async clearAll(): Promise&lt;void&gt; {
    await Promise.all([
      secureStorage.remove(this.KEYS.TOKENS),
      asyncStorage.remove(this.KEYS.PROFILE),
      // Keep preferences on logout
    ]);
  }
}

export default UserStorage;

// Usage in components
async function handleLogout() {
  await UserStorage.clearAll();
  router.replace('/login');
}

async function checkAuth() {
  const tokens = await UserStorage.getTokens();
  if (!tokens) return false;
  
  const expired = await UserStorage.isTokenExpired();
  if (expired) {
    // Try to refresh...
  }
  
  return true;
}</code></pre>

                <h3>Storage with Migrations</h3>

                <p>When your app evolves, stored data structures might need to change. Here's a pattern for handling migrations:</p>

                <pre><code>// storage/migrations.ts
import AsyncStorage from '@react-native-async-storage/async-storage';

const STORAGE_VERSION_KEY = 'storage_version';
const CURRENT_VERSION = 3;

interface Migration {
  version: number;
  migrate: () => Promise&lt;void&gt;;
}

const migrations: Migration[] = [
  {
    version: 1,
    migrate: async () => {
      // v1: Initial structure - nothing to do
    },
  },
  {
    version: 2,
    migrate: async () => {
      // v2: Rename 'user' key to 'user_profile'
      const oldUser = await AsyncStorage.getItem('user');
      if (oldUser) {
        await AsyncStorage.setItem('user_profile', oldUser);
        await AsyncStorage.removeItem('user');
      }
    },
  },
  {
    version: 3,
    migrate: async () => {
      // v3: Add 'notifications' to preferences
      const prefsJson = await AsyncStorage.getItem('user_preferences');
      if (prefsJson) {
        const prefs = JSON.parse(prefsJson);
        if (prefs.notifications === undefined) {
          prefs.notifications = true;  // Default value
          await AsyncStorage.setItem('user_preferences', JSON.stringify(prefs));
        }
      }
    },
  },
];

export async function runMigrations(): Promise&lt;void&gt; {
  const versionStr = await AsyncStorage.getItem(STORAGE_VERSION_KEY);
  const currentVersion = versionStr ? parseInt(versionStr, 10) : 0;

  if (currentVersion >= CURRENT_VERSION) {
    return; // Already up to date
  }

  console.log(`Running storage migrations from v${currentVersion} to v${CURRENT_VERSION}`);

  // Run all migrations newer than current version
  for (const migration of migrations) {
    if (migration.version > currentVersion) {
      console.log(`Running migration v${migration.version}`);
      try {
        await migration.migrate();
      } catch (error) {
        console.error(`Migration v${migration.version} failed:`, error);
        throw error;
      }
    }
  }

  // Update version
  await AsyncStorage.setItem(STORAGE_VERSION_KEY, CURRENT_VERSION.toString());
  console.log('Migrations complete');
}

// Run at app startup (in _layout.tsx or App.tsx)
// useEffect(() => {
//   runMigrations().catch(console.error);
// }, []);</code></pre>
            </section>

            <!-- Persisting React Query Cache -->
            <section id="tanstack-persistence">
                <h2>Persisting React Query Cache</h2>

                <p>One powerful use of local storage is persisting your React Query cache. This means your app can show cached data immediately on startup, even before network requests complete.</p>

                <h3>Installation</h3>

                <pre><code>npx expo install @tanstack/query-async-storage-persister @tanstack/react-query-persist-client</code></pre>

                <h3>Setup with AsyncStorage</h3>

                <pre><code>// app/_layout.tsx
import { Stack } from 'expo-router';
import { QueryClient } from '@tanstack/react-query';
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Create persister
const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
  key: 'REACT_QUERY_CACHE',
});

// Create query client with longer cache time for persistence
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
      staleTime: 1000 * 60 * 5,    // 5 minutes
    },
  },
});

export default function RootLayout() {
  return (
    &lt;PersistQueryClientProvider
      client={queryClient}
      persistOptions={{
        persister: asyncStoragePersister,
        maxAge: 1000 * 60 * 60 * 24, // 24 hours
        dehydrateOptions: {
          shouldDehydrateQuery: (query) => {
            // Only persist successful queries
            return query.state.status === 'success';
          },
        },
      }}
    &gt;
      &lt;Stack /&gt;
    &lt;/PersistQueryClientProvider&gt;
  );
}</code></pre>

                <h3>Setup with MMKV (Higher Performance)</h3>

                <pre><code>// storage/queryPersister.ts
import { MMKV } from 'react-native-mmkv';
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';

const queryStorage = new MMKV({ id: 'query-cache' });

// MMKV-compatible storage interface
const mmkvStorageInterface = {
  getItem: (key: string) => {
    const value = queryStorage.getString(key);
    return value ?? null;
  },
  setItem: (key: string, value: string) => {
    queryStorage.set(key, value);
  },
  removeItem: (key: string) => {
    queryStorage.delete(key);
  },
};

export const mmkvPersister = createSyncStoragePersister({
  storage: mmkvStorageInterface,
  key: 'REACT_QUERY_CACHE',
});

// app/_layout.tsx
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client';
import { mmkvPersister } from '../storage/queryPersister';

export default function RootLayout() {
  return (
    &lt;PersistQueryClientProvider
      client={queryClient}
      persistOptions={{
        persister: mmkvPersister,
        maxAge: 1000 * 60 * 60 * 24,
      }}
    &gt;
      &lt;Stack /&gt;
    &lt;/PersistQueryClientProvider&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Cache Persistence</h4>
                    <ul>
                        <li><strong>Instant app startup:</strong> Show cached data immediately</li>
                        <li><strong>Offline support:</strong> App works (read-only) without network</li>
                        <li><strong>Reduced API calls:</strong> Fresh-enough data doesn't need refetching</li>
                        <li><strong>Better UX:</strong> No loading spinners for returning users</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è What NOT to Persist</h4>
                    <p>Some queries shouldn't be persisted:</p>
                    <ul>
                        <li>Real-time data (stock prices, live scores)</li>
                        <li>User-specific data that shouldn't survive logout</li>
                        <li>Large datasets that would bloat storage</li>
                    </ul>
                    <p>Use <code>shouldDehydrateQuery</code> to filter what gets cached.</p>
                </div>
            </section>

            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>Hands-On Exercises</h2>

                <div class="exercise-card">
                    <h3>Exercise 1: Theme Persistence with AsyncStorage</h3>
                    <p>Create a theme toggle that persists the user's preference using AsyncStorage.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Create a custom <code>useTheme</code> hook</li>
                        <li>Load saved theme on app startup</li>
                        <li>Save theme changes to AsyncStorage</li>
                        <li>Show a loading state while initial theme is loading</li>
                        <li>Apply the theme to the UI</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use <code>useState</code> for the theme value and <code>isLoading</code>. In a <code>useEffect</code>, load the saved theme from AsyncStorage. Create a <code>setTheme</code> function that updates both state and storage.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>// hooks/useTheme.ts
import { useState, useEffect, useCallback, createContext, useContext } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

type Theme = 'light' | 'dark';

interface ThemeContext {
  theme: Theme;
  setTheme: (theme: Theme) => Promise&lt;void&gt;;
  toggleTheme: () => Promise&lt;void&gt;;
  isLoading: boolean;
}

const ThemeContext = createContext&lt;ThemeContext | null&gt;(null);

const THEME_KEY = 'app_theme';

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setThemeState] = useState&lt;Theme&gt;('light');
  const [isLoading, setIsLoading] = useState(true);

  // Load theme on mount
  useEffect(() => {
    const loadTheme = async () => {
      try {
        const savedTheme = await AsyncStorage.getItem(THEME_KEY);
        if (savedTheme === 'light' || savedTheme === 'dark') {
          setThemeState(savedTheme);
        }
      } catch (error) {
        console.error('Failed to load theme:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadTheme();
  }, []);

  const setTheme = useCallback(async (newTheme: Theme) => {
    try {
      setThemeState(newTheme);
      await AsyncStorage.setItem(THEME_KEY, newTheme);
    } catch (error) {
      console.error('Failed to save theme:', error);
    }
  }, []);

  const toggleTheme = useCallback(async () => {
    const newTheme = theme === 'light' ? 'dark' : 'light';
    await setTheme(newTheme);
  }, [theme, setTheme]);

  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme, toggleTheme, isLoading }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Usage in component
function SettingsScreen() {
  const { theme, toggleTheme, isLoading } = useTheme();

  if (isLoading) {
    return &lt;ActivityIndicator /&gt;;
  }

  return (
    &lt;View style={[styles.container, theme === 'dark' && styles.darkContainer]}&gt;
      &lt;Text style={theme === 'dark' ? styles.darkText : styles.lightText}&gt;
        Current theme: {theme}
      &lt;/Text&gt;
      &lt;Switch
        value={theme === 'dark'}
        onValueChange={toggleTheme}
      /&gt;
    &lt;/View&gt;
  );
}</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 2: Secure Token Storage</h3>
                    <p>Implement a secure authentication token manager using SecureStore.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Create a <code>TokenManager</code> class with <code>save</code>, <code>get</code>, <code>clear</code> methods</li>
                        <li>Store both access and refresh tokens</li>
                        <li>Include token expiration handling</li>
                        <li>Create a hook that provides the current auth state</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Store tokens as a JSON object with <code>accessToken</code>, <code>refreshToken</code>, and <code>expiresAt</code> fields. Create a method to check if the token is expired by comparing <code>expiresAt</code> with <code>Date.now()</code>.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>// auth/tokenManager.ts
import * as SecureStore from 'expo-secure-store';

const TOKEN_KEY = 'auth_tokens';

interface Tokens {
  accessToken: string;
  refreshToken: string;
  expiresAt: number; // Unix timestamp
}

class TokenManager {
  static async save(
    accessToken: string,
    refreshToken: string,
    expiresInSeconds: number
  ): Promise&lt;void&gt; {
    const tokens: Tokens = {
      accessToken,
      refreshToken,
      expiresAt: Date.now() + expiresInSeconds * 1000,
    };
    await SecureStore.setItemAsync(TOKEN_KEY, JSON.stringify(tokens));
  }

  static async get(): Promise&lt;Tokens | null&gt; {
    const json = await SecureStore.getItemAsync(TOKEN_KEY);
    return json ? JSON.parse(json) : null;
  }

  static async getAccessToken(): Promise&lt;string | null&gt; {
    const tokens = await this.get();
    return tokens?.accessToken ?? null;
  }

  static async getRefreshToken(): Promise&lt;string | null&gt; {
    const tokens = await this.get();
    return tokens?.refreshToken ?? null;
  }

  static async isExpired(): Promise&lt;boolean&gt; {
    const tokens = await this.get();
    if (!tokens) return true;
    // Add 60 second buffer
    return Date.now() >= tokens.expiresAt - 60000;
  }

  static async clear(): Promise&lt;void&gt; {
    await SecureStore.deleteItemAsync(TOKEN_KEY);
  }
}

// hooks/useAuth.ts
import { useState, useEffect, useCallback } from 'react';

interface AuthState {
  isAuthenticated: boolean;
  isLoading: boolean;
  accessToken: string | null;
}

export function useAuth() {
  const [state, setState] = useState&lt;AuthState&gt;({
    isAuthenticated: false,
    isLoading: true,
    accessToken: null,
  });

  // Check auth on mount
  useEffect(() => {
    const checkAuth = async () => {
      try {
        const tokens = await TokenManager.get();
        const expired = await TokenManager.isExpired();
        
        setState({
          isAuthenticated: !!tokens && !expired,
          isLoading: false,
          accessToken: !expired ? tokens?.accessToken ?? null : null,
        });
      } catch (error) {
        setState({ isAuthenticated: false, isLoading: false, accessToken: null });
      }
    };

    checkAuth();
  }, []);

  const login = useCallback(async (
    accessToken: string,
    refreshToken: string,
    expiresIn: number
  ) => {
    await TokenManager.save(accessToken, refreshToken, expiresIn);
    setState({
      isAuthenticated: true,
      isLoading: false,
      accessToken,
    });
  }, []);

  const logout = useCallback(async () => {
    await TokenManager.clear();
    setState({
      isAuthenticated: false,
      isLoading: false,
      accessToken: null,
    });
  }, []);

  return { ...state, login, logout };
}</code></pre>
                    </details>
                </div>

                <div class="exercise-card">
                    <h3>Exercise 3: Draft Message Auto-Save</h3>
                    <p>Build a text input that auto-saves drafts to storage as the user types.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Save the draft after 500ms of no typing (debounce)</li>
                        <li>Load any saved draft when the component mounts</li>
                        <li>Clear the draft when the message is sent</li>
                        <li>Show a "Draft saved" indicator</li>
                    </ul>

                    <details>
                        <summary>Show Hint</summary>
                        <p>Use <code>setTimeout</code> to debounce saves. Clear the previous timeout when the user types again. Store the draft keyed by conversation/screen ID if needed.</p>
                    </details>

                    <details>
                        <summary>Show Solution</summary>
                        <pre><code>import { useState, useEffect, useRef } from 'react';
import { View, TextInput, Pressable, Text, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

interface MessageComposerProps {
  conversationId: string;
  onSend: (message: string) => void;
}

export function MessageComposer({ conversationId, onSend }: MessageComposerProps) {
  const [text, setText] = useState('');
  const [isSaved, setIsSaved] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const saveTimeoutRef = useRef&lt;NodeJS.Timeout&gt;();

  const draftKey = `draft_${conversationId}`;

  // Load draft on mount
  useEffect(() => {
    const loadDraft = async () => {
      try {
        const draft = await AsyncStorage.getItem(draftKey);
        if (draft) {
          setText(draft);
        }
      } catch (error) {
        console.error('Failed to load draft:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadDraft();
  }, [draftKey]);

  // Debounced save
  useEffect(() => {
    if (isLoading) return; // Don't save during initial load

    setIsSaved(false);

    // Clear previous timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    // Save after 500ms of no typing
    saveTimeoutRef.current = setTimeout(async () => {
      try {
        if (text.trim()) {
          await AsyncStorage.setItem(draftKey, text);
          setIsSaved(true);
        } else {
          await AsyncStorage.removeItem(draftKey);
        }
      } catch (error) {
        console.error('Failed to save draft:', error);
      }
    }, 500);

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [text, draftKey, isLoading]);

  const handleSend = async () => {
    if (!text.trim()) return;

    onSend(text);
    setText('');

    // Clear the draft
    try {
      await AsyncStorage.removeItem(draftKey);
    } catch (error) {
      console.error('Failed to clear draft:', error);
    }
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.inputContainer}&gt;
        &lt;TextInput
          style={styles.input}
          value={text}
          onChangeText={setText}
          placeholder="Type a message..."
          multiline
        /&gt;
        {isSaved && (
          &lt;Text style={styles.savedIndicator}&gt;Draft saved&lt;/Text&gt;
        )}
      &lt;/View&gt;
      &lt;Pressable
        style={[styles.sendButton, !text.trim() && styles.sendButtonDisabled]}
        onPress={handleSend}
        disabled={!text.trim()}
      &gt;
        &lt;Text style={styles.sendButtonText}&gt;Send&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    alignItems: 'flex-end',
  },
  inputContainer: {
    flex: 1,
    marginRight: 12,
  },
  input: {
    backgroundColor: '#f5f5f5',
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 10,
    maxHeight: 100,
    fontSize: 16,
  },
  savedIndicator: {
    fontSize: 10,
    color: '#999',
    marginTop: 4,
    marginLeft: 16,
  },
  sendButton: {
    backgroundColor: '#667eea',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 20,
  },
  sendButtonDisabled: {
    backgroundColor: '#ccc',
  },
  sendButtonText: {
    color: 'white',
    fontWeight: '600',
  },
});</code></pre>
                    </details>
                </div>
            </section>

            <!-- Summary -->
            <section id="summary">
                <h2>Summary</h2>

                <p>Local storage is essential for building mobile apps that feel fast, work offline, and remember user preferences. Choosing the right storage solution depends on your data's sensitivity, size, and access patterns.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Key Takeaways</h4>
                    <ul style="color: white;">
                        <li><strong>AsyncStorage</strong> is the standard choice for general-purpose storage‚Äîsimple, reliable, and works everywhere</li>
                        <li><strong>SecureStore</strong> encrypts data using device hardware‚Äîessential for tokens, passwords, and secrets</li>
                        <li><strong>MMKV</strong> provides synchronous, high-performance storage‚Äîgreat for frequently accessed data</li>
                        <li><strong>Build abstractions</strong> that combine different storage backends based on data sensitivity</li>
                        <li><strong>Handle migrations</strong> when your data structures evolve</li>
                        <li><strong>Persist React Query cache</strong> for instant app startup and offline support</li>
                        <li><strong>Always stringify objects</strong> before storing and parse when retrieving</li>
                        <li><strong>Handle errors</strong>‚Äîstorage operations can fail</li>
                    </ul>
                </div>

                <p>In the next lesson, we'll explore state management at scale‚Äîwhen local component state and React Query aren't enough, and you need global state management solutions like Zustand or Redux Toolkit.</p>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="m07_l02_data_fetching_libraries.html" class="prev-link">‚Üê Previous: Data Fetching Libraries</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="m07_l04_state_management_at_scale.html" class="next-link">Next: State Management at Scale ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React Native & Expo Course. All rights reserved.</p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
